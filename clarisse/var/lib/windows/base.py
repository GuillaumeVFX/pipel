# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_base')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_base')
    _base = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_base', [dirname(__file__)])
        except ImportError:
            import _base
            return _base
        try:
            _mod = imp.load_module('_base', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _base = swig_import_helper()
    del swig_import_helper
else:
    import _base
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class CoreTypeInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreTypeInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreTypeInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_CoreTypeInfo
    __del__ = lambda self: None

    def get_name(self):
        return _base.CoreTypeInfo_get_name(self)

    def get_class_name(self):
        return _base.CoreTypeInfo_get_class_name(self)

    def is_reference(self):
        return _base.CoreTypeInfo_is_reference(self)

    def is_pointer(self):
        return _base.CoreTypeInfo_is_pointer(self)

    def get_template(self):
        return _base.CoreTypeInfo_get_template(self)
CoreTypeInfo_swigregister = _base.CoreTypeInfo_swigregister
CoreTypeInfo_swigregister(CoreTypeInfo)

class CoreArgInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreArgInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreArgInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_CoreArgInfo
    __del__ = lambda self: None

    def get_name(self):
        return _base.CoreArgInfo_get_name(self)

    def get_type(self):
        return _base.CoreArgInfo_get_type(self)

    def has_value(self):
        return _base.CoreArgInfo_has_value(self)

    def get_value(self):
        return _base.CoreArgInfo_get_value(self)
CoreArgInfo_swigregister = _base.CoreArgInfo_swigregister
CoreArgInfo_swigregister(CoreArgInfo)

class CoreConstructorInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreConstructorInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreConstructorInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_CoreConstructorInfo
    __del__ = lambda self: None

    def get_arguments(self):
        return _base.CoreConstructorInfo_get_arguments(self)

    def remove_all_arguments(self):
        return _base.CoreConstructorInfo_remove_all_arguments(self)

    def add_argument(self, name, type, value=None):
        return _base.CoreConstructorInfo_add_argument(self, name, type, value)

    def get_optional_argument_count(self):
        return _base.CoreConstructorInfo_get_optional_argument_count(self)

    def create_object(self, args=None, arg_count=0):
        return _base.CoreConstructorInfo_create_object(self, args, arg_count)
CoreConstructorInfo_swigregister = _base.CoreConstructorInfo_swigregister
CoreConstructorInfo_swigregister(CoreConstructorInfo)

class CoreMethodInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreMethodInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreMethodInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    TYPE_DEFAULT = _base.CoreMethodInfo_TYPE_DEFAULT
    TYPE_STATIC = _base.CoreMethodInfo_TYPE_STATIC
    TYPE_VIRTUAL = _base.CoreMethodInfo_TYPE_VIRTUAL
    __swig_destroy__ = _base.delete_CoreMethodInfo
    __del__ = lambda self: None

    def is_static(self):
        return _base.CoreMethodInfo_is_static(self)

    def is_virtual(self):
        return _base.CoreMethodInfo_is_virtual(self)

    def is_default(self):
        return _base.CoreMethodInfo_is_default(self)

    def get_name(self):
        return _base.CoreMethodInfo_get_name(self)

    def get_type(self):
        return _base.CoreMethodInfo_get_type(self)

    def get_return_type(self):
        return _base.CoreMethodInfo_get_return_type(self)

    def has_return_type(self):
        return _base.CoreMethodInfo_has_return_type(self)

    def get_arguments(self):
        return _base.CoreMethodInfo_get_arguments(self)

    def remove_all_arguments(self):
        return _base.CoreMethodInfo_remove_all_arguments(self)

    def add_argument(self, name, type, value=None):
        return _base.CoreMethodInfo_add_argument(self, name, type, value)

    def get_optional_argument_count(self):
        return _base.CoreMethodInfo_get_optional_argument_count(self)

    def call(self, instance=None, args=None, arg_count=0, ret_val=None):
        return _base.CoreMethodInfo_call(self, instance, args, arg_count, ret_val)
CoreMethodInfo_swigregister = _base.CoreMethodInfo_swigregister
CoreMethodInfo_swigregister(CoreMethodInfo)

class CoreEnumValueInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreEnumValueInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreEnumValueInfo, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _base.new_CoreEnumValueInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreEnumValueInfo
    __del__ = lambda self: None

    def get_name(self):
        return _base.CoreEnumValueInfo_get_name(self)

    def get_value(self):
        return _base.CoreEnumValueInfo_get_value(self)
CoreEnumValueInfo_swigregister = _base.CoreEnumValueInfo_swigregister
CoreEnumValueInfo_swigregister(CoreEnumValueInfo)

class CoreEnumInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreEnumInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreEnumInfo, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _base.new_CoreEnumInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreEnumInfo
    __del__ = lambda self: None

    def get_name(self):
        return _base.CoreEnumInfo_get_name(self)

    def get_values(self):
        return _base.CoreEnumInfo_get_values(self)

    def add_value(self, name, value):
        return _base.CoreEnumInfo_add_value(self, name, value)

    def remove_all_values(self):
        return _base.CoreEnumInfo_remove_all_values(self)
CoreEnumInfo_swigregister = _base.CoreEnumInfo_swigregister
CoreEnumInfo_swigregister(CoreEnumInfo)

class CoreClassInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreClassInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreClassInfo, name)
    __repr__ = _swig_repr

    def __init__(self, class_name, destructor, base_class_info=None, register_class=None):
        this = _base.new_CoreClassInfo(class_name, destructor, base_class_info, register_class)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreClassInfo
    __del__ = lambda self: None

    def get_name(self):
        return _base.CoreClassInfo_get_name(self)

    def get_id(self):
        return _base.CoreClassInfo_get_id(self)

    def get_index(self):
        return _base.CoreClassInfo_get_index(self)

    def is_base_class(self):
        return _base.CoreClassInfo_is_base_class(self)

    def get_base_class_info(self):
        return _base.CoreClassInfo_get_base_class_info(self)

    def is_kindof(self, cinfo):
        return _base.CoreClassInfo_is_kindof(self, cinfo)

    def __eq__(self, info):

        if not isinstance(obj, type(self)):
            return False


        return _base.CoreClassInfo___eq__(self, info)


    def __ne__(self, info):
        return _base.CoreClassInfo___ne__(self, info)

    def get_children_info(self):
        return _base.CoreClassInfo_get_children_info(self)

    def is_creatable(self):
        return _base.CoreClassInfo_is_creatable(self)

    def is_destroyable(self):
        return _base.CoreClassInfo_is_destroyable(self)

    def destroy(self, instance, is_array=False):
        return _base.CoreClassInfo_destroy(self, instance, is_array)

    def get_constructors(self, *args):
        return _base.CoreClassInfo_get_constructors(self, *args)

    def add_constructor(self, constructor):
        return _base.CoreClassInfo_add_constructor(self, constructor)

    def get_methods(self, *args):
        return _base.CoreClassInfo_get_methods(self, *args)

    def add_method(self, method, name, type, return_type=None):
        return _base.CoreClassInfo_add_method(self, method, name, type, return_type)

    def add_enum(self, name):
        return _base.CoreClassInfo_add_enum(self, name)

    def log(self, log_children=True):
        return _base.CoreClassInfo_log(self, log_children)

    def get_interface(self, name):
        return _base.CoreClassInfo_get_interface(self, name)
    if _newclass:
        is_class_exists = staticmethod(_base.CoreClassInfo_is_class_exists)
    else:
        is_class_exists = _base.CoreClassInfo_is_class_exists
    if _newclass:
        get_class = staticmethod(_base.CoreClassInfo_get_class)
    else:
        get_class = _base.CoreClassInfo_get_class
    if _newclass:
        new_class = staticmethod(_base.CoreClassInfo_new_class)
    else:
        new_class = _base.CoreClassInfo_new_class
    if _newclass:
        get_classes = staticmethod(_base.CoreClassInfo_get_classes)
    else:
        get_classes = _base.CoreClassInfo_get_classes
    if _newclass:
        get_class_by_index = staticmethod(_base.CoreClassInfo_get_class_by_index)
    else:
        get_class_by_index = _base.CoreClassInfo_get_class_by_index
    if _newclass:
        get_class_count = staticmethod(_base.CoreClassInfo_get_class_count)
    else:
        get_class_count = _base.CoreClassInfo_get_class_count
    if _newclass:
        is_enum_exists = staticmethod(_base.CoreClassInfo_is_enum_exists)
    else:
        is_enum_exists = _base.CoreClassInfo_is_enum_exists
    if _newclass:
        get_enum = staticmethod(_base.CoreClassInfo_get_enum)
    else:
        get_enum = _base.CoreClassInfo_get_enum
    if _newclass:
        get_enums = staticmethod(_base.CoreClassInfo_get_enums)
    else:
        get_enums = _base.CoreClassInfo_get_enums
CoreClassInfo_swigregister = _base.CoreClassInfo_swigregister
CoreClassInfo_swigregister(CoreClassInfo)

def CoreClassInfo_is_class_exists(*args):
    return _base.CoreClassInfo_is_class_exists(*args)
CoreClassInfo_is_class_exists = _base.CoreClassInfo_is_class_exists

def CoreClassInfo_get_class(class_name):
    return _base.CoreClassInfo_get_class(class_name)
CoreClassInfo_get_class = _base.CoreClassInfo_get_class

def CoreClassInfo_new_class(class_name, destructor, base_class_info=None, register_class=None):
    return _base.CoreClassInfo_new_class(class_name, destructor, base_class_info, register_class)
CoreClassInfo_new_class = _base.CoreClassInfo_new_class

def CoreClassInfo_get_classes(*args):
    return _base.CoreClassInfo_get_classes(*args)
CoreClassInfo_get_classes = _base.CoreClassInfo_get_classes

def CoreClassInfo_get_class_by_index(index):
    return _base.CoreClassInfo_get_class_by_index(index)
CoreClassInfo_get_class_by_index = _base.CoreClassInfo_get_class_by_index

def CoreClassInfo_get_class_count():
    return _base.CoreClassInfo_get_class_count()
CoreClassInfo_get_class_count = _base.CoreClassInfo_get_class_count

def CoreClassInfo_is_enum_exists(enum_name):
    return _base.CoreClassInfo_is_enum_exists(enum_name)
CoreClassInfo_is_enum_exists = _base.CoreClassInfo_is_enum_exists

def CoreClassInfo_get_enum(enum_name):
    return _base.CoreClassInfo_get_enum(enum_name)
CoreClassInfo_get_enum = _base.CoreClassInfo_get_enum

def CoreClassInfo_get_enums(*args):
    return _base.CoreClassInfo_get_enums(*args)
CoreClassInfo_get_enums = _base.CoreClassInfo_get_enums

class CoreBasicString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBasicString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBasicString, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.CoreBasicString_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_CoreBasicString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def is_empty(self):
        return _base.CoreBasicString_is_empty(self)

    def get_length(self):
        return _base.CoreBasicString_get_length(self)

    def get_count(self):
        return _base.CoreBasicString_get_count(self)

    def get_data(self):
        return _base.CoreBasicString_get_data(self)

    def front(self):
        return _base.CoreBasicString_front(self)

    def first(self):
        return _base.CoreBasicString_first(self)

    def back(self):
        return _base.CoreBasicString_back(self)

    def last(self):
        return _base.CoreBasicString_last(self)

    def start_with(self, *args):
        return _base.CoreBasicString_start_with(self, *args)

    def end_with(self, *args):
        return _base.CoreBasicString_end_with(self, *args)

    def contains(self, *args):
        return _base.CoreBasicString_contains(self, *args)

    def find(self, *args):
        return _base.CoreBasicString_find(self, *args)

    def rev_find(self, *args):
        return _base.CoreBasicString_rev_find(self, *args)

    def begin(self):
        return _base.CoreBasicString_begin(self)

    def end(self):
        return _base.CoreBasicString_end(self)

    def __eq__(self, *args):

        if not isinstance(obj, type(self)):
            return False


        return _base.CoreBasicString___eq__(self, *args)


    def __ne__(self, *args):
        return _base.CoreBasicString___ne__(self, *args)

    def __lt__(self, *args):
        return _base.CoreBasicString___lt__(self, *args)
    __swig_destroy__ = _base.delete_CoreBasicString
    __del__ = lambda self: None
CoreBasicString_swigregister = _base.CoreBasicString_swigregister
CoreBasicString_swigregister(CoreBasicString)

class CoreString(CoreBasicString):
    __swig_setmethods__ = {}
    for _s in [CoreBasicString]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreString, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBasicString]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreString, name)

    def __init__(self, *args):
        this = _base.new_CoreString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreString
    __del__ = lambda self: None

    def set_data(self, *args):
        return _base.CoreString_set_data(self, *args)

    def clear(self):
        return _base.CoreString_clear(self)

    def front(self):
        return _base.CoreString_front(self)

    def first(self):
        return _base.CoreString_first(self)

    def back(self):
        return _base.CoreString_back(self)

    def last(self):
        return _base.CoreString_last(self)

    def append(self, *args):
        return _base.CoreString_append(self, *args)

    def append_number_with_unit(self, number, short_scale=True):
        return _base.CoreString_append_number_with_unit(self, number, short_scale)

    def replace(self, *args):
        return _base.CoreString_replace(self, *args)

    def count_occurences(self, token):
        return _base.CoreString_count_occurences(self, token)

    def remove_occurences(self, token):
        return _base.CoreString_remove_occurences(self, token)

    def remove_last(self):
        return _base.CoreString_remove_last(self)

    def make_title(self):
        return _base.CoreString_make_title(self)

    def make_identifier(self):
        return _base.CoreString_make_identifier(self)

    def upper_case(self):
        return _base.CoreString_upper_case(self)

    def lower_case(self):
        return _base.CoreString_lower_case(self)

    def is_identifier(self):
        return _base.CoreString_is_identifier(self)

    def is_number(self):
        return _base.CoreString_is_number(self)

    def sub_string(self, start, length):
        return _base.CoreString_sub_string(self, start, length)

    def get_title(self):
        return _base.CoreString_get_title(self)

    def get_identifier(self):
        return _base.CoreString_get_identifier(self)

    def get_upper_case(self):
        return _base.CoreString_get_upper_case(self)

    def get_lower_case(self):
        return _base.CoreString_get_lower_case(self)

    def get_camel_case(self):
        return _base.CoreString_get_camel_case(self)

    def get_trim(self):
        return _base.CoreString_get_trim(self)

    def get_trim_left(self):
        return _base.CoreString_get_trim_left(self)

    def get_trim_right(self):
        return _base.CoreString_get_trim_right(self)

    def get_memory_size(self):
        return _base.CoreString_get_memory_size(self)

    def get_serial_size(self):
        return _base.CoreString_get_serial_size(self)

    def serialize(self, serial):
        return _base.CoreString_serialize(self, serial)

    def deserialize(self, serial):
        return _base.CoreString_deserialize(self, serial)

    def split(self, *args):
        return _base.CoreString_split(self, *args)

    def split_word(self, separator, slist, remove_blank=True):
        return _base.CoreString_split_word(self, separator, slist, remove_blank)
    if _newclass:
        join = staticmethod(_base.CoreString_join)
    else:
        join = _base.CoreString_join
    if _newclass:
        get_null_string = staticmethod(_base.CoreString_get_null_string)
    else:
        get_null_string = _base.CoreString_get_null_string
    if _newclass:
        camel_case = staticmethod(_base.CoreString_camel_case)
    else:
        camel_case = _base.CoreString_camel_case
    if _newclass:
        before_first = staticmethod(_base.CoreString_before_first)
    else:
        before_first = _base.CoreString_before_first
    if _newclass:
        after_first = staticmethod(_base.CoreString_after_first)
    else:
        after_first = _base.CoreString_after_first
    if _newclass:
        before_last = staticmethod(_base.CoreString_before_last)
    else:
        before_last = _base.CoreString_before_last
    if _newclass:
        after_last = staticmethod(_base.CoreString_after_last)
    else:
        after_last = _base.CoreString_after_last
    if _newclass:
        alpha_sort = staticmethod(_base.CoreString_alpha_sort)
    else:
        alpha_sort = _base.CoreString_alpha_sort
    if _newclass:
        compare = staticmethod(_base.CoreString_compare)
    else:
        compare = _base.CoreString_compare

    def begin(self, *args):
        return _base.CoreString_begin(self, *args)

    def end(self, *args):
        return _base.CoreString_end(self, *args)

    def shrink_to_fit(self):
        return _base.CoreString_shrink_to_fit(self)

    def capacity(self):
        return _base.CoreString_capacity(self)

    def __iadd__(self, *args):
        return _base.CoreString___iadd__(self, *args)

    def __lshift__(self, *args):
        return _base.CoreString___lshift__(self, *args)

    def __add__(self, *args):
        return _base.CoreString___add__(self, *args)

    def __nonzero__(self):
        return _base.CoreString___nonzero__(self)
    __bool__ = __nonzero__



    def __str__(self):
        return _base.CoreString___str__(self)

    def __repr__(self):
        return _base.CoreString___repr__(self)

    def __len__(self):
        return _base.CoreString___len__(self)

    def __setitem__(self, index, value):
        return _base.CoreString___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.CoreString___getitem__(self, index)
CoreString_swigregister = _base.CoreString_swigregister
CoreString_swigregister(CoreString)

def CoreString_join(strings, separator, keep_empty=False):
    return _base.CoreString_join(strings, separator, keep_empty)
CoreString_join = _base.CoreString_join

def CoreString_get_null_string():
    return _base.CoreString_get_null_string()
CoreString_get_null_string = _base.CoreString_get_null_string

def CoreString_camel_case(*args):
    return _base.CoreString_camel_case(*args)
CoreString_camel_case = _base.CoreString_camel_case

def CoreString_before_first(str, c):
    return _base.CoreString_before_first(str, c)
CoreString_before_first = _base.CoreString_before_first

def CoreString_after_first(str, c):
    return _base.CoreString_after_first(str, c)
CoreString_after_first = _base.CoreString_after_first

def CoreString_before_last(str, c):
    return _base.CoreString_before_last(str, c)
CoreString_before_last = _base.CoreString_before_last

def CoreString_after_last(str, c):
    return _base.CoreString_after_last(str, c)
CoreString_after_last = _base.CoreString_after_last

def CoreString_alpha_sort(*args):
    return _base.CoreString_alpha_sort(*args)
CoreString_alpha_sort = _base.CoreString_alpha_sort

def CoreString_compare(str1, str2):
    return _base.CoreString_compare(str1, str2)
CoreString_compare = _base.CoreString_compare

class CoreVariant(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreVariant, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreVariant, name)
    __repr__ = _swig_repr
    TYPE_VOID = _base.CoreVariant_TYPE_VOID
    TYPE_BOOL = _base.CoreVariant_TYPE_BOOL
    TYPE_LONG = _base.CoreVariant_TYPE_LONG
    TYPE_DOUBLE = _base.CoreVariant_TYPE_DOUBLE
    TYPE_STRING = _base.CoreVariant_TYPE_STRING
    TYPE_POINTER = _base.CoreVariant_TYPE_POINTER
    TYPE_CORE_BASE_OBJECT_PTR = _base.CoreVariant_TYPE_CORE_BASE_OBJECT_PTR
    TYPE_COUNT = _base.CoreVariant_TYPE_COUNT
    __swig_setmethods__["null_value"] = _base.CoreVariant_null_value_set
    __swig_getmethods__["null_value"] = _base.CoreVariant_null_value_get
    if _newclass:
        null_value = _swig_property(_base.CoreVariant_null_value_get, _base.CoreVariant_null_value_set)
    if _newclass:
        get_type_name = staticmethod(_base.CoreVariant_get_type_name)
    else:
        get_type_name = _base.CoreVariant_get_type_name

    def __init__(self, *args):
        this = _base.new_CoreVariant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreVariant
    __del__ = lambda self: None

    def get_memory_size(self):
        return _base.CoreVariant_get_memory_size(self)

    def get_type(self):
        return _base.CoreVariant_get_type(self)

    def __nonzero__(self):
        return _base.CoreVariant___nonzero__(self)
    __bool__ = __nonzero__



    def __eq__(self, other):

        if not isinstance(obj, type(self)):
            return False


        return _base.CoreVariant___eq__(self, other)


    def __ne__(self, other):
        return _base.CoreVariant___ne__(self, other)
CoreVariant_swigregister = _base.CoreVariant_swigregister
CoreVariant_swigregister(CoreVariant)
cvar = _base.cvar

def CoreVariant_get_type_name(type):
    return _base.CoreVariant_get_type_name(type)
CoreVariant_get_type_name = _base.CoreVariant_get_type_name


def core_container_is_empty(class_name, method_name):
    return _base.core_container_is_empty(class_name, method_name)
core_container_is_empty = _base.core_container_is_empty

def core_container_boundary_check(class_name, method_name, index, count):
    return _base.core_container_boundary_check(class_name, method_name, index, count)
core_container_boundary_check = _base.core_container_boundary_check
class CoreBaseType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseType, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _base.new_CoreBaseType()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBaseType
    __del__ = lambda self: None

    def is_kindof(self, cinfo):
        return _base.CoreBaseType_is_kindof(self, cinfo)
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreBaseType____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreBaseType____class_destructor__
    if _newclass:
        class_info = staticmethod(_base.CoreBaseType_class_info)
    else:
        class_info = _base.CoreBaseType_class_info

    def __eq__(self, obj):

        if not isinstance(obj, type(self)):
            return False


        return _base.CoreBaseType___eq__(self, obj)

CoreBaseType_swigregister = _base.CoreBaseType_swigregister
CoreBaseType_swigregister(CoreBaseType)

def CoreBaseType____class_destructor__(instance, is_array):
    return _base.CoreBaseType____class_destructor__(instance, is_array)
CoreBaseType____class_destructor__ = _base.CoreBaseType____class_destructor__

def CoreBaseType_class_info():
    return _base.CoreBaseType_class_info()
CoreBaseType_class_info = _base.CoreBaseType_class_info

class CoreBaseObject(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseObject, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseObject, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _base.new_CoreBaseObject()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBaseObject
    __del__ = lambda self: None

    def get_memory_size(self):
        return _base.CoreBaseObject_get_memory_size(self)

    def get_class_info_name(self):
        return _base.CoreBaseObject_get_class_info_name(self)

    def get_class_interface(self):
        return _base.CoreBaseObject_get_class_interface(self)

    def get_class_info_id(self):
        return _base.CoreBaseObject_get_class_info_id(self)

    def is_kindof(self, *args):
        return _base.CoreBaseObject_is_kindof(self, *args)

    def get_class_info(self):
        return _base.CoreBaseObject_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreBaseObject_class_info)
    else:
        class_info = _base.CoreBaseObject_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreBaseObject____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreBaseObject____class_destructor__

    def __eq__(self, obj):

        if not isinstance(obj, type(self)):
            return False


        return _base.CoreBaseObject___eq__(self, obj)

CoreBaseObject_swigregister = _base.CoreBaseObject_swigregister
CoreBaseObject_swigregister(CoreBaseObject)

def CoreBaseObject_class_info():
    return _base.CoreBaseObject_class_info()
CoreBaseObject_class_info = _base.CoreBaseObject_class_info

def CoreBaseObject____class_destructor__(instance, is_array):
    return _base.CoreBaseObject____class_destructor__(instance, is_array)
CoreBaseObject____class_destructor__ = _base.CoreBaseObject____class_destructor__


def get_next_core_basic_array_id():
    return _base.get_next_core_basic_array_id()
get_next_core_basic_array_id = _base.get_next_core_basic_array_id
CoreArrayResizeMode_KEEP_NONE = _base.CoreArrayResizeMode_KEEP_NONE
CoreArrayResizeMode_KEEP_LEFT = _base.CoreArrayResizeMode_KEEP_LEFT
CoreArrayResizeMode_KEEP_RIGHT = _base.CoreArrayResizeMode_KEEP_RIGHT

def get_next_core_array_id():
    return _base.get_next_core_array_id()
get_next_core_array_id = _base.get_next_core_array_id

def get_next_core_vector_id():
    return _base.get_next_core_vector_id()
get_next_core_vector_id = _base.get_next_core_vector_id
class CoreCustomData(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreCustomData, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreCustomData, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreCustomData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreCustomData
    __del__ = lambda self: None

    def add_custom_data(self, *args):
        return _base.CoreCustomData_add_custom_data(self, *args)

    def remove_custom_data(self, key):
        return _base.CoreCustomData_remove_custom_data(self, key)

    def remove_all_custom_data(self):
        return _base.CoreCustomData_remove_all_custom_data(self)

    def set_custom_data(self, *args):
        return _base.CoreCustomData_set_custom_data(self, *args)

    def get_custom_data(self, *args):
        return _base.CoreCustomData_get_custom_data(self, *args)

    def get_memory_size(self):
        return _base.CoreCustomData_get_memory_size(self)
    if _newclass:
        get_custom_data_key = staticmethod(_base.CoreCustomData_get_custom_data_key)
    else:
        get_custom_data_key = _base.CoreCustomData_get_custom_data_key
    if _newclass:
        class_info = staticmethod(_base.CoreCustomData_class_info)
    else:
        class_info = _base.CoreCustomData_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreCustomData____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreCustomData____class_destructor__

    def get_class_info(self):
        return _base.CoreCustomData_get_class_info(self)
CoreCustomData_swigregister = _base.CoreCustomData_swigregister
CoreCustomData_swigregister(CoreCustomData)

def CoreCustomData_get_custom_data_key(key):
    return _base.CoreCustomData_get_custom_data_key(key)
CoreCustomData_get_custom_data_key = _base.CoreCustomData_get_custom_data_key

def CoreCustomData_class_info():
    return _base.CoreCustomData_class_info()
CoreCustomData_class_info = _base.CoreCustomData_class_info

def CoreCustomData____class_destructor__(instance, is_array):
    return _base.CoreCustomData____class_destructor__(instance, is_array)
CoreCustomData____class_destructor__ = _base.CoreCustomData____class_destructor__

LOG_LEVEL_FATAL = _base.LOG_LEVEL_FATAL
LOG_LEVEL_ERROR = _base.LOG_LEVEL_ERROR
LOG_LEVEL_WARNING = _base.LOG_LEVEL_WARNING
LOG_LEVEL_INFO = _base.LOG_LEVEL_INFO
LOG_LEVEL_DEBUG = _base.LOG_LEVEL_DEBUG
LOG_LEVEL_COUNT = _base.LOG_LEVEL_COUNT

def to_string(level):
    return _base.to_string(level)
to_string = _base.to_string

def from_string(level):
    return _base.from_string(level)
from_string = _base.from_string
class CoreLogMessage(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreLogMessage, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreLogMessage, name)
    __repr__ = _swig_repr

    def __init__(self, level, message):
        this = _base.new_CoreLogMessage(level, message)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_str(self):
        return _base.CoreLogMessage_get_str(self)

    def get_level(self):
        return _base.CoreLogMessage_get_level(self)
    if _newclass:
        class_info = staticmethod(_base.CoreLogMessage_class_info)
    else:
        class_info = _base.CoreLogMessage_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreLogMessage____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreLogMessage____class_destructor__

    def get_class_info(self):
        return _base.CoreLogMessage_get_class_info(self)
    __swig_destroy__ = _base.delete_CoreLogMessage
    __del__ = lambda self: None
CoreLogMessage_swigregister = _base.CoreLogMessage_swigregister
CoreLogMessage_swigregister(CoreLogMessage)

def CoreLogMessage_class_info():
    return _base.CoreLogMessage_class_info()
CoreLogMessage_class_info = _base.CoreLogMessage_class_info

def CoreLogMessage____class_destructor__(instance, is_array):
    return _base.CoreLogMessage____class_destructor__(instance, is_array)
CoreLogMessage____class_destructor__ = _base.CoreLogMessage____class_destructor__

class CoreLogger(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreLogger, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreLogger, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _base.delete_CoreLogger
    __del__ = lambda self: None

    def output(self, msg):
        return _base.CoreLogger_output(self, msg)
    if _newclass:
        class_info = staticmethod(_base.CoreLogger_class_info)
    else:
        class_info = _base.CoreLogger_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreLogger____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreLogger____class_destructor__

    def get_class_info(self):
        return _base.CoreLogger_get_class_info(self)
CoreLogger_swigregister = _base.CoreLogger_swigregister
CoreLogger_swigregister(CoreLogger)

def CoreLogger_class_info():
    return _base.CoreLogger_class_info()
CoreLogger_class_info = _base.CoreLogger_class_info

def CoreLogger____class_destructor__(instance, is_array):
    return _base.CoreLogger____class_destructor__(instance, is_array)
CoreLogger____class_destructor__ = _base.CoreLogger____class_destructor__

class CoreLoggerStdout(CoreLogger):
    __swig_setmethods__ = {}
    for _s in [CoreLogger]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreLoggerStdout, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreLogger]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreLoggerStdout, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _base.new_CoreLoggerStdout()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def output(self, msg):
        return _base.CoreLoggerStdout_output(self, msg)
    if _newclass:
        class_info = staticmethod(_base.CoreLoggerStdout_class_info)
    else:
        class_info = _base.CoreLoggerStdout_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreLoggerStdout____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreLoggerStdout____class_destructor__

    def get_class_info(self):
        return _base.CoreLoggerStdout_get_class_info(self)
    __swig_destroy__ = _base.delete_CoreLoggerStdout
    __del__ = lambda self: None
CoreLoggerStdout_swigregister = _base.CoreLoggerStdout_swigregister
CoreLoggerStdout_swigregister(CoreLoggerStdout)

def CoreLoggerStdout_class_info():
    return _base.CoreLoggerStdout_class_info()
CoreLoggerStdout_class_info = _base.CoreLoggerStdout_class_info

def CoreLoggerStdout____class_destructor__(instance, is_array):
    return _base.CoreLoggerStdout____class_destructor__(instance, is_array)
CoreLoggerStdout____class_destructor__ = _base.CoreLoggerStdout____class_destructor__

class CoreLogStream(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreLogStream, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreLogStream, name)
    __repr__ = _swig_repr

    def get_string(self):
        return _base.CoreLogStream_get_string(self)

    def get_size(self):
        return _base.CoreLogStream_get_size(self)

    def clear(self):
        return _base.CoreLogStream_clear(self)

    def __lshift__(self, *args):
        return _base.CoreLogStream___lshift__(self, *args)
    if _newclass:
        class_info = staticmethod(_base.CoreLogStream_class_info)
    else:
        class_info = _base.CoreLogStream_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreLogStream____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreLogStream____class_destructor__

    def get_class_info(self):
        return _base.CoreLogStream_get_class_info(self)

    def __init__(self):
        this = _base.new_CoreLogStream()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreLogStream
    __del__ = lambda self: None
CoreLogStream_swigregister = _base.CoreLogStream_swigregister
CoreLogStream_swigregister(CoreLogStream)

def CoreLogStream_class_info():
    return _base.CoreLogStream_class_info()
CoreLogStream_class_info = _base.CoreLogStream_class_info

def CoreLogStream____class_destructor__(instance, is_array):
    return _base.CoreLogStream____class_destructor__(instance, is_array)
CoreLogStream____class_destructor__ = _base.CoreLogStream____class_destructor__

class CoreLogCtx(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreLogCtx, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreLogCtx, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _base.new_CoreLogCtx()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreLogCtx
    __del__ = lambda self: None

    def add_logger(self, logger):
        return _base.CoreLogCtx_add_logger(self, logger)

    def remove_logger(self, *args):
        return _base.CoreLogCtx_remove_logger(self, *args)

    def remove_all_loggers(self):
        return _base.CoreLogCtx_remove_all_loggers(self)

    def get_logger_count(self):
        return _base.CoreLogCtx_get_logger_count(self)

    def get_logger(self, idx):
        return _base.CoreLogCtx_get_logger(self, idx)

    def log(self, level, message):
        return _base.CoreLogCtx_log(self, level, message)
    if _newclass:
        class_info = staticmethod(_base.CoreLogCtx_class_info)
    else:
        class_info = _base.CoreLogCtx_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreLogCtx____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreLogCtx____class_destructor__

    def get_class_info(self):
        return _base.CoreLogCtx_get_class_info(self)
CoreLogCtx_swigregister = _base.CoreLogCtx_swigregister
CoreLogCtx_swigregister(CoreLogCtx)

def CoreLogCtx_class_info():
    return _base.CoreLogCtx_class_info()
CoreLogCtx_class_info = _base.CoreLogCtx_class_info

def CoreLogCtx____class_destructor__(instance, is_array):
    return _base.CoreLogCtx____class_destructor__(instance, is_array)
CoreLogCtx____class_destructor__ = _base.CoreLogCtx____class_destructor__

class CoreLogStreamer(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreLogStreamer, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreLogStreamer, name)
    __repr__ = _swig_repr

    def __init__(self, context):
        this = _base.new_CoreLogStreamer(context)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def append(self, level, msg):
        return _base.CoreLogStreamer_append(self, level, msg)

    def print_log(self, level, str):
        return _base.CoreLogStreamer_print_log(self, level, str)

    def flush(self, level):
        return _base.CoreLogStreamer_flush(self, level)

    def get_capacity(self):
        return _base.CoreLogStreamer_get_capacity(self)

    def set_capacity(self, capacity):
        return _base.CoreLogStreamer_set_capacity(self, capacity)
    if _newclass:
        class_info = staticmethod(_base.CoreLogStreamer_class_info)
    else:
        class_info = _base.CoreLogStreamer_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreLogStreamer____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreLogStreamer____class_destructor__

    def get_class_info(self):
        return _base.CoreLogStreamer_get_class_info(self)
    __swig_destroy__ = _base.delete_CoreLogStreamer
    __del__ = lambda self: None
CoreLogStreamer_swigregister = _base.CoreLogStreamer_swigregister
CoreLogStreamer_swigregister(CoreLogStreamer)

def CoreLogStreamer_class_info():
    return _base.CoreLogStreamer_class_info()
CoreLogStreamer_class_info = _base.CoreLogStreamer_class_info

def CoreLogStreamer____class_destructor__(instance, is_array):
    return _base.CoreLogStreamer____class_destructor__(instance, is_array)
CoreLogStreamer____class_destructor__ = _base.CoreLogStreamer____class_destructor__

class CoreLogHandler(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreLogHandler, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreLogHandler, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _base.new_CoreLogHandler()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreLogHandler
    __del__ = lambda self: None
    if _newclass:
        main_handler = staticmethod(_base.CoreLogHandler_main_handler)
    else:
        main_handler = _base.CoreLogHandler_main_handler

    def log(self, level, stream):
        return _base.CoreLogHandler_log(self, level, stream)

    def get_log_ctx(self):
        return _base.CoreLogHandler_get_log_ctx(self)

    def set_logger(self, logger):
        return _base.CoreLogHandler_set_logger(self, logger)

    def set_indent(self, indent):
        return _base.CoreLogHandler_set_indent(self, indent)

    def add_indent(self, indent):
        return _base.CoreLogHandler_add_indent(self, indent)

    def get_indent(self):
        return _base.CoreLogHandler_get_indent(self)

    def set_log_level(self, level):
        return _base.CoreLogHandler_set_log_level(self, level)

    def get_log_level(self):
        return _base.CoreLogHandler_get_log_level(self)

    def set_mute(self, mute):
        return _base.CoreLogHandler_set_mute(self, mute)

    def is_muted(self):
        return _base.CoreLogHandler_is_muted(self)
    if _newclass:
        class_info = staticmethod(_base.CoreLogHandler_class_info)
    else:
        class_info = _base.CoreLogHandler_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreLogHandler____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreLogHandler____class_destructor__

    def get_class_info(self):
        return _base.CoreLogHandler_get_class_info(self)
CoreLogHandler_swigregister = _base.CoreLogHandler_swigregister
CoreLogHandler_swigregister(CoreLogHandler)

def CoreLogHandler_main_handler():
    return _base.CoreLogHandler_main_handler()
CoreLogHandler_main_handler = _base.CoreLogHandler_main_handler

def CoreLogHandler_class_info():
    return _base.CoreLogHandler_class_info()
CoreLogHandler_class_info = _base.CoreLogHandler_class_info

def CoreLogHandler____class_destructor__(instance, is_array):
    return _base.CoreLogHandler____class_destructor__(instance, is_array)
CoreLogHandler____class_destructor__ = _base.CoreLogHandler____class_destructor__

class CoreBitFieldHelper(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBitFieldHelper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBitFieldHelper, name)
    __repr__ = _swig_repr
    MODE_DISABLE = _base.CoreBitFieldHelper_MODE_DISABLE
    MODE_EXACT_BITS = _base.CoreBitFieldHelper_MODE_EXACT_BITS
    MODE_ALL_BITS = _base.CoreBitFieldHelper_MODE_ALL_BITS
    MODE_ONE_BIT = _base.CoreBitFieldHelper_MODE_ONE_BIT
    MODE_COUNT = _base.CoreBitFieldHelper_MODE_COUNT

    def __init__(self, *args):
        this = _base.new_CoreBitFieldHelper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBitFieldHelper
    __del__ = lambda self: None

    def is_disabled(self):
        return _base.CoreBitFieldHelper_is_disabled(self)

    def tests_bits(self, bits):
        return _base.CoreBitFieldHelper_tests_bits(self, bits)

    def tests_include(self, bits):
        return _base.CoreBitFieldHelper_tests_include(self, bits)

    def tests_exclude(self, bits):
        return _base.CoreBitFieldHelper_tests_exclude(self, bits)
CoreBitFieldHelper_swigregister = _base.CoreBitFieldHelper_swigregister
CoreBitFieldHelper_swigregister(CoreBitFieldHelper)

class CoreBaseTypeBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseTypeBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseTypeBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.CoreBaseTypeBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_CoreBaseTypeBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBaseTypeBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.CoreBaseTypeBasicArray_get_count(self)

    def get_item(self, index):
        return _base.CoreBaseTypeBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.CoreBaseTypeBasicArray_set_item(self, index, item)

    def front(self):
        return _base.CoreBaseTypeBasicArray_front(self)

    def back(self):
        return _base.CoreBaseTypeBasicArray_back(self)

    def exists(self, item):
        return _base.CoreBaseTypeBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.CoreBaseTypeBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.CoreBaseTypeBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.CoreBaseTypeBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.CoreBaseTypeBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.CoreBaseTypeBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.CoreBaseTypeBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreBaseTypeBasicArray_class_info)
    else:
        class_info = _base.CoreBaseTypeBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreBaseTypeBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreBaseTypeBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.CoreBaseTypeBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.CoreBaseTypeBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

CoreBaseTypeBasicArray_swigregister = _base.CoreBaseTypeBasicArray_swigregister
CoreBaseTypeBasicArray_swigregister(CoreBaseTypeBasicArray)

def CoreBaseTypeBasicArray_class_info():
    return _base.CoreBaseTypeBasicArray_class_info()
CoreBaseTypeBasicArray_class_info = _base.CoreBaseTypeBasicArray_class_info

def CoreBaseTypeBasicArray____class_destructor__(instance, is_array):
    return _base.CoreBaseTypeBasicArray____class_destructor__(instance, is_array)
CoreBaseTypeBasicArray____class_destructor__ = _base.CoreBaseTypeBasicArray____class_destructor__

class CoreBaseTypeArray(CoreBaseTypeBasicArray):
    __swig_setmethods__ = {}
    for _s in [CoreBaseTypeBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseTypeArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseTypeBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseTypeArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreBaseTypeArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBaseTypeArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.CoreBaseTypeArray_append(self, *args)

    def get_count(self):
        return _base.CoreBaseTypeArray_get_count(self)

    def remove_all(self):
        return _base.CoreBaseTypeArray_remove_all(self)

    def resize(self, *args):
        return _base.CoreBaseTypeArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.CoreBaseTypeArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.CoreBaseTypeArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.CoreBaseTypeArray_get_list(self, list)

    def set_list(self, list):
        return _base.CoreBaseTypeArray_set_list(self, list)

    def get_memory_size(self):
        return _base.CoreBaseTypeArray_get_memory_size(self)

    def get_class_info(self):
        return _base.CoreBaseTypeArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreBaseTypeArray_class_info)
    else:
        class_info = _base.CoreBaseTypeArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreBaseTypeArray____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreBaseTypeArray____class_destructor__
CoreBaseTypeArray_swigregister = _base.CoreBaseTypeArray_swigregister
CoreBaseTypeArray_swigregister(CoreBaseTypeArray)

def CoreBaseTypeArray_class_info():
    return _base.CoreBaseTypeArray_class_info()
CoreBaseTypeArray_class_info = _base.CoreBaseTypeArray_class_info

def CoreBaseTypeArray____class_destructor__(instance, is_array):
    return _base.CoreBaseTypeArray____class_destructor__(instance, is_array)
CoreBaseTypeArray____class_destructor__ = _base.CoreBaseTypeArray____class_destructor__

class CoreBaseTypeVector(CoreBaseTypeBasicArray):
    __swig_setmethods__ = {}
    for _s in [CoreBaseTypeBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseTypeVector, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseTypeBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseTypeVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreBaseTypeVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBaseTypeVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.CoreBaseTypeVector_append(self, *args)

    def add(self, element):
        return _base.CoreBaseTypeVector_add(self, element)

    def insert(self, element, index):
        return _base.CoreBaseTypeVector_insert(self, element, index)

    def remove_last(self):
        return _base.CoreBaseTypeVector_remove_last(self)

    def empty(self):
        return _base.CoreBaseTypeVector_empty(self)

    def remove_all(self):
        return _base.CoreBaseTypeVector_remove_all(self)

    def clear(self, *args):
        return _base.CoreBaseTypeVector_clear(self, *args)

    def remove(self, *args):
        return _base.CoreBaseTypeVector_remove(self, *args)

    def is_empty(self):
        return _base.CoreBaseTypeVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.CoreBaseTypeVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.CoreBaseTypeVector_remove_items(self, item)

    def get_count(self):
        return _base.CoreBaseTypeVector_get_count(self)

    def get_capacity(self):
        return _base.CoreBaseTypeVector_get_capacity(self)

    def set_count(self, *args):
        return _base.CoreBaseTypeVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.CoreBaseTypeVector_set_capacity(self, *args)

    def refit(self):
        return _base.CoreBaseTypeVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.CoreBaseTypeVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.CoreBaseTypeVector_resize(self, *args)

    def reserve(self, *args):
        return _base.CoreBaseTypeVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.CoreBaseTypeVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.CoreBaseTypeVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.CoreBaseTypeVector_get_list(self, list)

    def set_list(self, list):
        return _base.CoreBaseTypeVector_set_list(self, list)

    def get_array(self, array):
        return _base.CoreBaseTypeVector_get_array(self, array)

    def set_array(self, array):
        return _base.CoreBaseTypeVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.CoreBaseTypeVector_move(self, arg2, to)

    def item(self, index):
        return _base.CoreBaseTypeVector_item(self, index)

    def get_memory_size(self):
        return _base.CoreBaseTypeVector_get_memory_size(self)

    def get_class_info(self):
        return _base.CoreBaseTypeVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreBaseTypeVector_class_info)
    else:
        class_info = _base.CoreBaseTypeVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreBaseTypeVector____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreBaseTypeVector____class_destructor__
CoreBaseTypeVector_swigregister = _base.CoreBaseTypeVector_swigregister
CoreBaseTypeVector_swigregister(CoreBaseTypeVector)

def CoreBaseTypeVector_class_info():
    return _base.CoreBaseTypeVector_class_info()
CoreBaseTypeVector_class_info = _base.CoreBaseTypeVector_class_info

def CoreBaseTypeVector____class_destructor__(instance, is_array):
    return _base.CoreBaseTypeVector____class_destructor__(instance, is_array)
CoreBaseTypeVector____class_destructor__ = _base.CoreBaseTypeVector____class_destructor__

class CoreBaseTypeSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseTypeSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseTypeSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreBaseTypeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.CoreBaseTypeSet_get_count(self)

    def exists(self, *args):
        return _base.CoreBaseTypeSet_exists(self, *args)

    def is_empty(self):
        return _base.CoreBaseTypeSet_is_empty(self)

    def is_included(self, set):
        return _base.CoreBaseTypeSet_is_included(self, set)

    def get_items(self):
        return _base.CoreBaseTypeSet_get_items(self)

    def get_item(self, index):
        return _base.CoreBaseTypeSet_get_item(self, index)

    def back(self, *args):
        return _base.CoreBaseTypeSet_back(self, *args)

    def get_array(self, array):
        return _base.CoreBaseTypeSet_get_array(self, array)

    def get_list(self, list):
        return _base.CoreBaseTypeSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.CoreBaseTypeSet_get_vector(self, vector)

    def to_array(self):
        return _base.CoreBaseTypeSet_to_array(self)

    def add(self, *args):
        return _base.CoreBaseTypeSet_add(self, *args)

    def remove(self, index):
        return _base.CoreBaseTypeSet_remove(self, index)

    def remove_item(self, item):
        return _base.CoreBaseTypeSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.CoreBaseTypeSet_remove_set(self, set)

    def remove_all(self):
        return _base.CoreBaseTypeSet_remove_all(self)

    def toggle(self, item):
        return _base.CoreBaseTypeSet_toggle(self, item)

    def unite(self, set):
        return _base.CoreBaseTypeSet_unite(self, set)

    def intersect(self, set):
        return _base.CoreBaseTypeSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.CoreBaseTypeSet___eq__(self, set)


    def __ne__(self, set):
        return _base.CoreBaseTypeSet___ne__(self, set)

    def begin(self, *args):
        return _base.CoreBaseTypeSet_begin(self, *args)

    def end(self, *args):
        return _base.CoreBaseTypeSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.CoreBaseTypeSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.CoreBaseTypeSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.CoreBaseTypeSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.CoreBaseTypeSet___setitem__(self, index, value)

    def __len__(self):
        return _base.CoreBaseTypeSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_CoreBaseTypeSet
    __del__ = lambda self: None
CoreBaseTypeSet_swigregister = _base.CoreBaseTypeSet_swigregister
CoreBaseTypeSet_swigregister(CoreBaseTypeSet)

def CoreBaseTypeSet_get_linear_search_threshold():
    return _base.CoreBaseTypeSet_get_linear_search_threshold()
CoreBaseTypeSet_get_linear_search_threshold = _base.CoreBaseTypeSet_get_linear_search_threshold

class CoreBaseObjectBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseObjectBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseObjectBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.CoreBaseObjectBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_CoreBaseObjectBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBaseObjectBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.CoreBaseObjectBasicArray_get_count(self)

    def get_item(self, index):
        return _base.CoreBaseObjectBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.CoreBaseObjectBasicArray_set_item(self, index, item)

    def front(self):
        return _base.CoreBaseObjectBasicArray_front(self)

    def back(self):
        return _base.CoreBaseObjectBasicArray_back(self)

    def exists(self, item):
        return _base.CoreBaseObjectBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.CoreBaseObjectBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.CoreBaseObjectBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.CoreBaseObjectBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.CoreBaseObjectBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.CoreBaseObjectBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.CoreBaseObjectBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreBaseObjectBasicArray_class_info)
    else:
        class_info = _base.CoreBaseObjectBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreBaseObjectBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreBaseObjectBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.CoreBaseObjectBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.CoreBaseObjectBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

CoreBaseObjectBasicArray_swigregister = _base.CoreBaseObjectBasicArray_swigregister
CoreBaseObjectBasicArray_swigregister(CoreBaseObjectBasicArray)

def CoreBaseObjectBasicArray_class_info():
    return _base.CoreBaseObjectBasicArray_class_info()
CoreBaseObjectBasicArray_class_info = _base.CoreBaseObjectBasicArray_class_info

def CoreBaseObjectBasicArray____class_destructor__(instance, is_array):
    return _base.CoreBaseObjectBasicArray____class_destructor__(instance, is_array)
CoreBaseObjectBasicArray____class_destructor__ = _base.CoreBaseObjectBasicArray____class_destructor__

class CoreBaseObjectArray(CoreBaseObjectBasicArray):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObjectBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseObjectArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObjectBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseObjectArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreBaseObjectArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBaseObjectArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.CoreBaseObjectArray_append(self, *args)

    def get_count(self):
        return _base.CoreBaseObjectArray_get_count(self)

    def remove_all(self):
        return _base.CoreBaseObjectArray_remove_all(self)

    def resize(self, *args):
        return _base.CoreBaseObjectArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.CoreBaseObjectArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.CoreBaseObjectArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.CoreBaseObjectArray_get_list(self, list)

    def set_list(self, list):
        return _base.CoreBaseObjectArray_set_list(self, list)

    def get_memory_size(self):
        return _base.CoreBaseObjectArray_get_memory_size(self)

    def get_class_info(self):
        return _base.CoreBaseObjectArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreBaseObjectArray_class_info)
    else:
        class_info = _base.CoreBaseObjectArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreBaseObjectArray____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreBaseObjectArray____class_destructor__
CoreBaseObjectArray_swigregister = _base.CoreBaseObjectArray_swigregister
CoreBaseObjectArray_swigregister(CoreBaseObjectArray)

def CoreBaseObjectArray_class_info():
    return _base.CoreBaseObjectArray_class_info()
CoreBaseObjectArray_class_info = _base.CoreBaseObjectArray_class_info

def CoreBaseObjectArray____class_destructor__(instance, is_array):
    return _base.CoreBaseObjectArray____class_destructor__(instance, is_array)
CoreBaseObjectArray____class_destructor__ = _base.CoreBaseObjectArray____class_destructor__

class CoreBaseObjectVector(CoreBaseObjectBasicArray):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObjectBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseObjectVector, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObjectBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseObjectVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreBaseObjectVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreBaseObjectVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.CoreBaseObjectVector_append(self, *args)

    def add(self, element):
        return _base.CoreBaseObjectVector_add(self, element)

    def insert(self, element, index):
        return _base.CoreBaseObjectVector_insert(self, element, index)

    def remove_last(self):
        return _base.CoreBaseObjectVector_remove_last(self)

    def empty(self):
        return _base.CoreBaseObjectVector_empty(self)

    def remove_all(self):
        return _base.CoreBaseObjectVector_remove_all(self)

    def clear(self, *args):
        return _base.CoreBaseObjectVector_clear(self, *args)

    def remove(self, *args):
        return _base.CoreBaseObjectVector_remove(self, *args)

    def is_empty(self):
        return _base.CoreBaseObjectVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.CoreBaseObjectVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.CoreBaseObjectVector_remove_items(self, item)

    def get_count(self):
        return _base.CoreBaseObjectVector_get_count(self)

    def get_capacity(self):
        return _base.CoreBaseObjectVector_get_capacity(self)

    def set_count(self, *args):
        return _base.CoreBaseObjectVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.CoreBaseObjectVector_set_capacity(self, *args)

    def refit(self):
        return _base.CoreBaseObjectVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.CoreBaseObjectVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.CoreBaseObjectVector_resize(self, *args)

    def reserve(self, *args):
        return _base.CoreBaseObjectVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.CoreBaseObjectVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.CoreBaseObjectVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.CoreBaseObjectVector_get_list(self, list)

    def set_list(self, list):
        return _base.CoreBaseObjectVector_set_list(self, list)

    def get_array(self, array):
        return _base.CoreBaseObjectVector_get_array(self, array)

    def set_array(self, array):
        return _base.CoreBaseObjectVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.CoreBaseObjectVector_move(self, arg2, to)

    def item(self, index):
        return _base.CoreBaseObjectVector_item(self, index)

    def get_memory_size(self):
        return _base.CoreBaseObjectVector_get_memory_size(self)

    def get_class_info(self):
        return _base.CoreBaseObjectVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreBaseObjectVector_class_info)
    else:
        class_info = _base.CoreBaseObjectVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreBaseObjectVector____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreBaseObjectVector____class_destructor__
CoreBaseObjectVector_swigregister = _base.CoreBaseObjectVector_swigregister
CoreBaseObjectVector_swigregister(CoreBaseObjectVector)

def CoreBaseObjectVector_class_info():
    return _base.CoreBaseObjectVector_class_info()
CoreBaseObjectVector_class_info = _base.CoreBaseObjectVector_class_info

def CoreBaseObjectVector____class_destructor__(instance, is_array):
    return _base.CoreBaseObjectVector____class_destructor__(instance, is_array)
CoreBaseObjectVector____class_destructor__ = _base.CoreBaseObjectVector____class_destructor__

class CoreBaseObjectSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreBaseObjectSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreBaseObjectSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreBaseObjectSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.CoreBaseObjectSet_get_count(self)

    def exists(self, *args):
        return _base.CoreBaseObjectSet_exists(self, *args)

    def is_empty(self):
        return _base.CoreBaseObjectSet_is_empty(self)

    def is_included(self, set):
        return _base.CoreBaseObjectSet_is_included(self, set)

    def get_items(self):
        return _base.CoreBaseObjectSet_get_items(self)

    def get_item(self, index):
        return _base.CoreBaseObjectSet_get_item(self, index)

    def back(self, *args):
        return _base.CoreBaseObjectSet_back(self, *args)

    def get_array(self, array):
        return _base.CoreBaseObjectSet_get_array(self, array)

    def get_list(self, list):
        return _base.CoreBaseObjectSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.CoreBaseObjectSet_get_vector(self, vector)

    def to_array(self):
        return _base.CoreBaseObjectSet_to_array(self)

    def add(self, *args):
        return _base.CoreBaseObjectSet_add(self, *args)

    def remove(self, index):
        return _base.CoreBaseObjectSet_remove(self, index)

    def remove_item(self, item):
        return _base.CoreBaseObjectSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.CoreBaseObjectSet_remove_set(self, set)

    def remove_all(self):
        return _base.CoreBaseObjectSet_remove_all(self)

    def toggle(self, item):
        return _base.CoreBaseObjectSet_toggle(self, item)

    def unite(self, set):
        return _base.CoreBaseObjectSet_unite(self, set)

    def intersect(self, set):
        return _base.CoreBaseObjectSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.CoreBaseObjectSet___eq__(self, set)


    def __ne__(self, set):
        return _base.CoreBaseObjectSet___ne__(self, set)

    def begin(self, *args):
        return _base.CoreBaseObjectSet_begin(self, *args)

    def end(self, *args):
        return _base.CoreBaseObjectSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.CoreBaseObjectSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.CoreBaseObjectSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.CoreBaseObjectSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.CoreBaseObjectSet___setitem__(self, index, value)

    def __len__(self):
        return _base.CoreBaseObjectSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_CoreBaseObjectSet
    __del__ = lambda self: None
CoreBaseObjectSet_swigregister = _base.CoreBaseObjectSet_swigregister
CoreBaseObjectSet_swigregister(CoreBaseObjectSet)

def CoreBaseObjectSet_get_linear_search_threshold():
    return _base.CoreBaseObjectSet_get_linear_search_threshold()
CoreBaseObjectSet_get_linear_search_threshold = _base.CoreBaseObjectSet_get_linear_search_threshold

class CoreStringBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreStringBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreStringBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.CoreStringBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_CoreStringBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreStringBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.CoreStringBasicArray_get_count(self)

    def get_item(self, index):
        return _base.CoreStringBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.CoreStringBasicArray_set_item(self, index, item)

    def front(self):
        return _base.CoreStringBasicArray_front(self)

    def back(self):
        return _base.CoreStringBasicArray_back(self)

    def exists(self, item):
        return _base.CoreStringBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.CoreStringBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.CoreStringBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.CoreStringBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.CoreStringBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.CoreStringBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.CoreStringBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreStringBasicArray_class_info)
    else:
        class_info = _base.CoreStringBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreStringBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreStringBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.CoreStringBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.CoreStringBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

CoreStringBasicArray_swigregister = _base.CoreStringBasicArray_swigregister
CoreStringBasicArray_swigregister(CoreStringBasicArray)

def CoreStringBasicArray_class_info():
    return _base.CoreStringBasicArray_class_info()
CoreStringBasicArray_class_info = _base.CoreStringBasicArray_class_info

def CoreStringBasicArray____class_destructor__(instance, is_array):
    return _base.CoreStringBasicArray____class_destructor__(instance, is_array)
CoreStringBasicArray____class_destructor__ = _base.CoreStringBasicArray____class_destructor__

class CoreStringArray(CoreStringBasicArray):
    __swig_setmethods__ = {}
    for _s in [CoreStringBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreStringArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreStringBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreStringArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreStringArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreStringArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.CoreStringArray_append(self, *args)

    def get_count(self):
        return _base.CoreStringArray_get_count(self)

    def remove_all(self):
        return _base.CoreStringArray_remove_all(self)

    def resize(self, *args):
        return _base.CoreStringArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.CoreStringArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.CoreStringArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.CoreStringArray_get_list(self, list)

    def set_list(self, list):
        return _base.CoreStringArray_set_list(self, list)

    def get_memory_size(self):
        return _base.CoreStringArray_get_memory_size(self)

    def get_class_info(self):
        return _base.CoreStringArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreStringArray_class_info)
    else:
        class_info = _base.CoreStringArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreStringArray____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreStringArray____class_destructor__
CoreStringArray_swigregister = _base.CoreStringArray_swigregister
CoreStringArray_swigregister(CoreStringArray)

def CoreStringArray_class_info():
    return _base.CoreStringArray_class_info()
CoreStringArray_class_info = _base.CoreStringArray_class_info

def CoreStringArray____class_destructor__(instance, is_array):
    return _base.CoreStringArray____class_destructor__(instance, is_array)
CoreStringArray____class_destructor__ = _base.CoreStringArray____class_destructor__

class CoreStringVector(CoreStringBasicArray):
    __swig_setmethods__ = {}
    for _s in [CoreStringBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreStringVector, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreStringBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreStringVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreStringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CoreStringVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.CoreStringVector_append(self, *args)

    def add(self, element):
        return _base.CoreStringVector_add(self, element)

    def insert(self, element, index):
        return _base.CoreStringVector_insert(self, element, index)

    def remove_last(self):
        return _base.CoreStringVector_remove_last(self)

    def empty(self):
        return _base.CoreStringVector_empty(self)

    def remove_all(self):
        return _base.CoreStringVector_remove_all(self)

    def clear(self, *args):
        return _base.CoreStringVector_clear(self, *args)

    def remove(self, *args):
        return _base.CoreStringVector_remove(self, *args)

    def is_empty(self):
        return _base.CoreStringVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.CoreStringVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.CoreStringVector_remove_items(self, item)

    def get_count(self):
        return _base.CoreStringVector_get_count(self)

    def get_capacity(self):
        return _base.CoreStringVector_get_capacity(self)

    def set_count(self, *args):
        return _base.CoreStringVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.CoreStringVector_set_capacity(self, *args)

    def refit(self):
        return _base.CoreStringVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.CoreStringVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.CoreStringVector_resize(self, *args)

    def reserve(self, *args):
        return _base.CoreStringVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.CoreStringVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.CoreStringVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.CoreStringVector_get_list(self, list)

    def set_list(self, list):
        return _base.CoreStringVector_set_list(self, list)

    def get_array(self, array):
        return _base.CoreStringVector_get_array(self, array)

    def set_array(self, array):
        return _base.CoreStringVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.CoreStringVector_move(self, arg2, to)

    def item(self, index):
        return _base.CoreStringVector_item(self, index)

    def get_memory_size(self):
        return _base.CoreStringVector_get_memory_size(self)

    def get_class_info(self):
        return _base.CoreStringVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CoreStringVector_class_info)
    else:
        class_info = _base.CoreStringVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CoreStringVector____class_destructor__)
    else:
        ___class_destructor__ = _base.CoreStringVector____class_destructor__
CoreStringVector_swigregister = _base.CoreStringVector_swigregister
CoreStringVector_swigregister(CoreStringVector)

def CoreStringVector_class_info():
    return _base.CoreStringVector_class_info()
CoreStringVector_class_info = _base.CoreStringVector_class_info

def CoreStringVector____class_destructor__(instance, is_array):
    return _base.CoreStringVector____class_destructor__(instance, is_array)
CoreStringVector____class_destructor__ = _base.CoreStringVector____class_destructor__

class CoreStringSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CoreStringSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CoreStringSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CoreStringSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.CoreStringSet_get_count(self)

    def exists(self, *args):
        return _base.CoreStringSet_exists(self, *args)

    def is_empty(self):
        return _base.CoreStringSet_is_empty(self)

    def is_included(self, set):
        return _base.CoreStringSet_is_included(self, set)

    def get_items(self):
        return _base.CoreStringSet_get_items(self)

    def get_item(self, index):
        return _base.CoreStringSet_get_item(self, index)

    def back(self, *args):
        return _base.CoreStringSet_back(self, *args)

    def get_array(self, array):
        return _base.CoreStringSet_get_array(self, array)

    def get_list(self, list):
        return _base.CoreStringSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.CoreStringSet_get_vector(self, vector)

    def to_array(self):
        return _base.CoreStringSet_to_array(self)

    def add(self, *args):
        return _base.CoreStringSet_add(self, *args)

    def remove(self, index):
        return _base.CoreStringSet_remove(self, index)

    def remove_item(self, item):
        return _base.CoreStringSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.CoreStringSet_remove_set(self, set)

    def remove_all(self):
        return _base.CoreStringSet_remove_all(self)

    def toggle(self, item):
        return _base.CoreStringSet_toggle(self, item)

    def unite(self, set):
        return _base.CoreStringSet_unite(self, set)

    def intersect(self, set):
        return _base.CoreStringSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.CoreStringSet___eq__(self, set)


    def __ne__(self, set):
        return _base.CoreStringSet___ne__(self, set)

    def begin(self, *args):
        return _base.CoreStringSet_begin(self, *args)

    def end(self, *args):
        return _base.CoreStringSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.CoreStringSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.CoreStringSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.CoreStringSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.CoreStringSet___setitem__(self, index, value)

    def __len__(self):
        return _base.CoreStringSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_CoreStringSet
    __del__ = lambda self: None
CoreStringSet_swigregister = _base.CoreStringSet_swigregister
CoreStringSet_swigregister(CoreStringSet)

def CoreStringSet_get_linear_search_threshold():
    return _base.CoreStringSet_get_linear_search_threshold()
CoreStringSet_get_linear_search_threshold = _base.CoreStringSet_get_linear_search_threshold

class PyObjectBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyObjectBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PyObjectBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.PyObjectBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_PyObjectBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_PyObjectBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.PyObjectBasicArray_get_count(self)

    def get_item(self, index):
        return _base.PyObjectBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.PyObjectBasicArray_set_item(self, index, item)

    def front(self):
        return _base.PyObjectBasicArray_front(self)

    def back(self):
        return _base.PyObjectBasicArray_back(self)

    def exists(self, item):
        return _base.PyObjectBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.PyObjectBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.PyObjectBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.PyObjectBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.PyObjectBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.PyObjectBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.PyObjectBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.PyObjectBasicArray_class_info)
    else:
        class_info = _base.PyObjectBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.PyObjectBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.PyObjectBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.PyObjectBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.PyObjectBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

PyObjectBasicArray_swigregister = _base.PyObjectBasicArray_swigregister
PyObjectBasicArray_swigregister(PyObjectBasicArray)

def PyObjectBasicArray_class_info():
    return _base.PyObjectBasicArray_class_info()
PyObjectBasicArray_class_info = _base.PyObjectBasicArray_class_info

def PyObjectBasicArray____class_destructor__(instance, is_array):
    return _base.PyObjectBasicArray____class_destructor__(instance, is_array)
PyObjectBasicArray____class_destructor__ = _base.PyObjectBasicArray____class_destructor__

class PyObjectArray(PyObjectBasicArray):
    __swig_setmethods__ = {}
    for _s in [PyObjectBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyObjectArray, name, value)
    __swig_getmethods__ = {}
    for _s in [PyObjectBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PyObjectArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_PyObjectArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_PyObjectArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.PyObjectArray_append(self, *args)

    def get_count(self):
        return _base.PyObjectArray_get_count(self)

    def remove_all(self):
        return _base.PyObjectArray_remove_all(self)

    def resize(self, *args):
        return _base.PyObjectArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.PyObjectArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.PyObjectArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.PyObjectArray_get_list(self, list)

    def set_list(self, list):
        return _base.PyObjectArray_set_list(self, list)

    def get_memory_size(self):
        return _base.PyObjectArray_get_memory_size(self)

    def get_class_info(self):
        return _base.PyObjectArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.PyObjectArray_class_info)
    else:
        class_info = _base.PyObjectArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.PyObjectArray____class_destructor__)
    else:
        ___class_destructor__ = _base.PyObjectArray____class_destructor__
PyObjectArray_swigregister = _base.PyObjectArray_swigregister
PyObjectArray_swigregister(PyObjectArray)

def PyObjectArray_class_info():
    return _base.PyObjectArray_class_info()
PyObjectArray_class_info = _base.PyObjectArray_class_info

def PyObjectArray____class_destructor__(instance, is_array):
    return _base.PyObjectArray____class_destructor__(instance, is_array)
PyObjectArray____class_destructor__ = _base.PyObjectArray____class_destructor__

class PyObjectVector(PyObjectBasicArray):
    __swig_setmethods__ = {}
    for _s in [PyObjectBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyObjectVector, name, value)
    __swig_getmethods__ = {}
    for _s in [PyObjectBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PyObjectVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_PyObjectVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_PyObjectVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.PyObjectVector_append(self, *args)

    def add(self, element):
        return _base.PyObjectVector_add(self, element)

    def insert(self, element, index):
        return _base.PyObjectVector_insert(self, element, index)

    def remove_last(self):
        return _base.PyObjectVector_remove_last(self)

    def empty(self):
        return _base.PyObjectVector_empty(self)

    def remove_all(self):
        return _base.PyObjectVector_remove_all(self)

    def clear(self, *args):
        return _base.PyObjectVector_clear(self, *args)

    def remove(self, *args):
        return _base.PyObjectVector_remove(self, *args)

    def is_empty(self):
        return _base.PyObjectVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.PyObjectVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.PyObjectVector_remove_items(self, item)

    def get_count(self):
        return _base.PyObjectVector_get_count(self)

    def get_capacity(self):
        return _base.PyObjectVector_get_capacity(self)

    def set_count(self, *args):
        return _base.PyObjectVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.PyObjectVector_set_capacity(self, *args)

    def refit(self):
        return _base.PyObjectVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.PyObjectVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.PyObjectVector_resize(self, *args)

    def reserve(self, *args):
        return _base.PyObjectVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.PyObjectVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.PyObjectVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.PyObjectVector_get_list(self, list)

    def set_list(self, list):
        return _base.PyObjectVector_set_list(self, list)

    def get_array(self, array):
        return _base.PyObjectVector_get_array(self, array)

    def set_array(self, array):
        return _base.PyObjectVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.PyObjectVector_move(self, arg2, to)

    def item(self, index):
        return _base.PyObjectVector_item(self, index)

    def get_memory_size(self):
        return _base.PyObjectVector_get_memory_size(self)

    def get_class_info(self):
        return _base.PyObjectVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.PyObjectVector_class_info)
    else:
        class_info = _base.PyObjectVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.PyObjectVector____class_destructor__)
    else:
        ___class_destructor__ = _base.PyObjectVector____class_destructor__
PyObjectVector_swigregister = _base.PyObjectVector_swigregister
PyObjectVector_swigregister(PyObjectVector)

def PyObjectVector_class_info():
    return _base.PyObjectVector_class_info()
PyObjectVector_class_info = _base.PyObjectVector_class_info

def PyObjectVector____class_destructor__(instance, is_array):
    return _base.PyObjectVector____class_destructor__(instance, is_array)
PyObjectVector____class_destructor__ = _base.PyObjectVector____class_destructor__

class PyObjectSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyObjectSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PyObjectSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_PyObjectSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.PyObjectSet_get_count(self)

    def exists(self, *args):
        return _base.PyObjectSet_exists(self, *args)

    def is_empty(self):
        return _base.PyObjectSet_is_empty(self)

    def is_included(self, set):
        return _base.PyObjectSet_is_included(self, set)

    def get_items(self):
        return _base.PyObjectSet_get_items(self)

    def get_item(self, index):
        return _base.PyObjectSet_get_item(self, index)

    def back(self, *args):
        return _base.PyObjectSet_back(self, *args)

    def get_array(self, array):
        return _base.PyObjectSet_get_array(self, array)

    def get_list(self, list):
        return _base.PyObjectSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.PyObjectSet_get_vector(self, vector)

    def to_array(self):
        return _base.PyObjectSet_to_array(self)

    def add(self, *args):
        return _base.PyObjectSet_add(self, *args)

    def remove(self, index):
        return _base.PyObjectSet_remove(self, index)

    def remove_item(self, item):
        return _base.PyObjectSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.PyObjectSet_remove_set(self, set)

    def remove_all(self):
        return _base.PyObjectSet_remove_all(self)

    def toggle(self, item):
        return _base.PyObjectSet_toggle(self, item)

    def unite(self, set):
        return _base.PyObjectSet_unite(self, set)

    def intersect(self, set):
        return _base.PyObjectSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.PyObjectSet___eq__(self, set)


    def __ne__(self, set):
        return _base.PyObjectSet___ne__(self, set)

    def begin(self, *args):
        return _base.PyObjectSet_begin(self, *args)

    def end(self, *args):
        return _base.PyObjectSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.PyObjectSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.PyObjectSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.PyObjectSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.PyObjectSet___setitem__(self, index, value)

    def __len__(self):
        return _base.PyObjectSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_PyObjectSet
    __del__ = lambda self: None
PyObjectSet_swigregister = _base.PyObjectSet_swigregister
PyObjectSet_swigregister(PyObjectSet)

def PyObjectSet_get_linear_search_threshold():
    return _base.PyObjectSet_get_linear_search_threshold()
PyObjectSet_get_linear_search_threshold = _base.PyObjectSet_get_linear_search_threshold

class BoolBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoolBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoolBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.BoolBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_BoolBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_BoolBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.BoolBasicArray_get_count(self)

    def get_item(self, index):
        return _base.BoolBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.BoolBasicArray_set_item(self, index, item)

    def front(self):
        return _base.BoolBasicArray_front(self)

    def back(self):
        return _base.BoolBasicArray_back(self)

    def exists(self, item):
        return _base.BoolBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.BoolBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.BoolBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.BoolBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.BoolBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.BoolBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.BoolBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.BoolBasicArray_class_info)
    else:
        class_info = _base.BoolBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.BoolBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.BoolBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.BoolBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.BoolBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

BoolBasicArray_swigregister = _base.BoolBasicArray_swigregister
BoolBasicArray_swigregister(BoolBasicArray)

def BoolBasicArray_class_info():
    return _base.BoolBasicArray_class_info()
BoolBasicArray_class_info = _base.BoolBasicArray_class_info

def BoolBasicArray____class_destructor__(instance, is_array):
    return _base.BoolBasicArray____class_destructor__(instance, is_array)
BoolBasicArray____class_destructor__ = _base.BoolBasicArray____class_destructor__

class BoolArray(BoolBasicArray):
    __swig_setmethods__ = {}
    for _s in [BoolBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoolArray, name, value)
    __swig_getmethods__ = {}
    for _s in [BoolBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoolArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_BoolArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_BoolArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.BoolArray_append(self, *args)

    def get_count(self):
        return _base.BoolArray_get_count(self)

    def remove_all(self):
        return _base.BoolArray_remove_all(self)

    def resize(self, *args):
        return _base.BoolArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.BoolArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.BoolArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.BoolArray_get_list(self, list)

    def set_list(self, list):
        return _base.BoolArray_set_list(self, list)

    def get_memory_size(self):
        return _base.BoolArray_get_memory_size(self)

    def get_class_info(self):
        return _base.BoolArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.BoolArray_class_info)
    else:
        class_info = _base.BoolArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.BoolArray____class_destructor__)
    else:
        ___class_destructor__ = _base.BoolArray____class_destructor__
BoolArray_swigregister = _base.BoolArray_swigregister
BoolArray_swigregister(BoolArray)

def BoolArray_class_info():
    return _base.BoolArray_class_info()
BoolArray_class_info = _base.BoolArray_class_info

def BoolArray____class_destructor__(instance, is_array):
    return _base.BoolArray____class_destructor__(instance, is_array)
BoolArray____class_destructor__ = _base.BoolArray____class_destructor__

class BoolVector(BoolBasicArray):
    __swig_setmethods__ = {}
    for _s in [BoolBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoolVector, name, value)
    __swig_getmethods__ = {}
    for _s in [BoolBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoolVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_BoolVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_BoolVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.BoolVector_append(self, *args)

    def add(self, element):
        return _base.BoolVector_add(self, element)

    def insert(self, element, index):
        return _base.BoolVector_insert(self, element, index)

    def remove_last(self):
        return _base.BoolVector_remove_last(self)

    def empty(self):
        return _base.BoolVector_empty(self)

    def remove_all(self):
        return _base.BoolVector_remove_all(self)

    def clear(self, *args):
        return _base.BoolVector_clear(self, *args)

    def remove(self, *args):
        return _base.BoolVector_remove(self, *args)

    def is_empty(self):
        return _base.BoolVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.BoolVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.BoolVector_remove_items(self, item)

    def get_count(self):
        return _base.BoolVector_get_count(self)

    def get_capacity(self):
        return _base.BoolVector_get_capacity(self)

    def set_count(self, *args):
        return _base.BoolVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.BoolVector_set_capacity(self, *args)

    def refit(self):
        return _base.BoolVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.BoolVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.BoolVector_resize(self, *args)

    def reserve(self, *args):
        return _base.BoolVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.BoolVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.BoolVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.BoolVector_get_list(self, list)

    def set_list(self, list):
        return _base.BoolVector_set_list(self, list)

    def get_array(self, array):
        return _base.BoolVector_get_array(self, array)

    def set_array(self, array):
        return _base.BoolVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.BoolVector_move(self, arg2, to)

    def item(self, index):
        return _base.BoolVector_item(self, index)

    def get_memory_size(self):
        return _base.BoolVector_get_memory_size(self)

    def get_class_info(self):
        return _base.BoolVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.BoolVector_class_info)
    else:
        class_info = _base.BoolVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.BoolVector____class_destructor__)
    else:
        ___class_destructor__ = _base.BoolVector____class_destructor__
BoolVector_swigregister = _base.BoolVector_swigregister
BoolVector_swigregister(BoolVector)

def BoolVector_class_info():
    return _base.BoolVector_class_info()
BoolVector_class_info = _base.BoolVector_class_info

def BoolVector____class_destructor__(instance, is_array):
    return _base.BoolVector____class_destructor__(instance, is_array)
BoolVector____class_destructor__ = _base.BoolVector____class_destructor__

class CharBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.CharBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_CharBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CharBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.CharBasicArray_get_count(self)

    def get_item(self, index):
        return _base.CharBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.CharBasicArray_set_item(self, index, item)

    def front(self):
        return _base.CharBasicArray_front(self)

    def back(self):
        return _base.CharBasicArray_back(self)

    def exists(self, item):
        return _base.CharBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.CharBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.CharBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.CharBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.CharBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.CharBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.CharBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CharBasicArray_class_info)
    else:
        class_info = _base.CharBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CharBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.CharBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.CharBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.CharBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

CharBasicArray_swigregister = _base.CharBasicArray_swigregister
CharBasicArray_swigregister(CharBasicArray)

def CharBasicArray_class_info():
    return _base.CharBasicArray_class_info()
CharBasicArray_class_info = _base.CharBasicArray_class_info

def CharBasicArray____class_destructor__(instance, is_array):
    return _base.CharBasicArray____class_destructor__(instance, is_array)
CharBasicArray____class_destructor__ = _base.CharBasicArray____class_destructor__

class CharArray(CharBasicArray):
    __swig_setmethods__ = {}
    for _s in [CharBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CharBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CharArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CharArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.CharArray_append(self, *args)

    def get_count(self):
        return _base.CharArray_get_count(self)

    def remove_all(self):
        return _base.CharArray_remove_all(self)

    def resize(self, *args):
        return _base.CharArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.CharArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.CharArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.CharArray_get_list(self, list)

    def set_list(self, list):
        return _base.CharArray_set_list(self, list)

    def get_memory_size(self):
        return _base.CharArray_get_memory_size(self)

    def get_class_info(self):
        return _base.CharArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CharArray_class_info)
    else:
        class_info = _base.CharArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CharArray____class_destructor__)
    else:
        ___class_destructor__ = _base.CharArray____class_destructor__
CharArray_swigregister = _base.CharArray_swigregister
CharArray_swigregister(CharArray)

def CharArray_class_info():
    return _base.CharArray_class_info()
CharArray_class_info = _base.CharArray_class_info

def CharArray____class_destructor__(instance, is_array):
    return _base.CharArray____class_destructor__(instance, is_array)
CharArray____class_destructor__ = _base.CharArray____class_destructor__

class CharVector(CharBasicArray):
    __swig_setmethods__ = {}
    for _s in [CharBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharVector, name, value)
    __swig_getmethods__ = {}
    for _s in [CharBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CharVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_CharVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.CharVector_append(self, *args)

    def add(self, element):
        return _base.CharVector_add(self, element)

    def insert(self, element, index):
        return _base.CharVector_insert(self, element, index)

    def remove_last(self):
        return _base.CharVector_remove_last(self)

    def empty(self):
        return _base.CharVector_empty(self)

    def remove_all(self):
        return _base.CharVector_remove_all(self)

    def clear(self, *args):
        return _base.CharVector_clear(self, *args)

    def remove(self, *args):
        return _base.CharVector_remove(self, *args)

    def is_empty(self):
        return _base.CharVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.CharVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.CharVector_remove_items(self, item)

    def get_count(self):
        return _base.CharVector_get_count(self)

    def get_capacity(self):
        return _base.CharVector_get_capacity(self)

    def set_count(self, *args):
        return _base.CharVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.CharVector_set_capacity(self, *args)

    def refit(self):
        return _base.CharVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.CharVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.CharVector_resize(self, *args)

    def reserve(self, *args):
        return _base.CharVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.CharVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.CharVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.CharVector_get_list(self, list)

    def set_list(self, list):
        return _base.CharVector_set_list(self, list)

    def get_array(self, array):
        return _base.CharVector_get_array(self, array)

    def set_array(self, array):
        return _base.CharVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.CharVector_move(self, arg2, to)

    def item(self, index):
        return _base.CharVector_item(self, index)

    def get_memory_size(self):
        return _base.CharVector_get_memory_size(self)

    def get_class_info(self):
        return _base.CharVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.CharVector_class_info)
    else:
        class_info = _base.CharVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.CharVector____class_destructor__)
    else:
        ___class_destructor__ = _base.CharVector____class_destructor__
CharVector_swigregister = _base.CharVector_swigregister
CharVector_swigregister(CharVector)

def CharVector_class_info():
    return _base.CharVector_class_info()
CharVector_class_info = _base.CharVector_class_info

def CharVector____class_destructor__(instance, is_array):
    return _base.CharVector____class_destructor__(instance, is_array)
CharVector____class_destructor__ = _base.CharVector____class_destructor__

class CharSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CharSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_CharSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.CharSet_get_count(self)

    def exists(self, *args):
        return _base.CharSet_exists(self, *args)

    def is_empty(self):
        return _base.CharSet_is_empty(self)

    def is_included(self, set):
        return _base.CharSet_is_included(self, set)

    def get_items(self):
        return _base.CharSet_get_items(self)

    def get_item(self, index):
        return _base.CharSet_get_item(self, index)

    def back(self, *args):
        return _base.CharSet_back(self, *args)

    def get_array(self, array):
        return _base.CharSet_get_array(self, array)

    def get_list(self, list):
        return _base.CharSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.CharSet_get_vector(self, vector)

    def to_array(self):
        return _base.CharSet_to_array(self)

    def add(self, *args):
        return _base.CharSet_add(self, *args)

    def remove(self, index):
        return _base.CharSet_remove(self, index)

    def remove_item(self, item):
        return _base.CharSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.CharSet_remove_set(self, set)

    def remove_all(self):
        return _base.CharSet_remove_all(self)

    def toggle(self, item):
        return _base.CharSet_toggle(self, item)

    def unite(self, set):
        return _base.CharSet_unite(self, set)

    def intersect(self, set):
        return _base.CharSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.CharSet___eq__(self, set)


    def __ne__(self, set):
        return _base.CharSet___ne__(self, set)

    def begin(self, *args):
        return _base.CharSet_begin(self, *args)

    def end(self, *args):
        return _base.CharSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.CharSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.CharSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.CharSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.CharSet___setitem__(self, index, value)

    def __len__(self):
        return _base.CharSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_CharSet
    __del__ = lambda self: None
CharSet_swigregister = _base.CharSet_swigregister
CharSet_swigregister(CharSet)

def CharSet_get_linear_search_threshold():
    return _base.CharSet_get_linear_search_threshold()
CharSet_get_linear_search_threshold = _base.CharSet_get_linear_search_threshold

class UCharBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UCharBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UCharBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.UCharBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_UCharBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UCharBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.UCharBasicArray_get_count(self)

    def get_item(self, index):
        return _base.UCharBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.UCharBasicArray_set_item(self, index, item)

    def front(self):
        return _base.UCharBasicArray_front(self)

    def back(self):
        return _base.UCharBasicArray_back(self)

    def exists(self, item):
        return _base.UCharBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.UCharBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.UCharBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.UCharBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.UCharBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.UCharBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.UCharBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UCharBasicArray_class_info)
    else:
        class_info = _base.UCharBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UCharBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.UCharBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.UCharBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.UCharBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

UCharBasicArray_swigregister = _base.UCharBasicArray_swigregister
UCharBasicArray_swigregister(UCharBasicArray)

def UCharBasicArray_class_info():
    return _base.UCharBasicArray_class_info()
UCharBasicArray_class_info = _base.UCharBasicArray_class_info

def UCharBasicArray____class_destructor__(instance, is_array):
    return _base.UCharBasicArray____class_destructor__(instance, is_array)
UCharBasicArray____class_destructor__ = _base.UCharBasicArray____class_destructor__

class UCharArray(UCharBasicArray):
    __swig_setmethods__ = {}
    for _s in [UCharBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UCharArray, name, value)
    __swig_getmethods__ = {}
    for _s in [UCharBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UCharArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UCharArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UCharArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.UCharArray_append(self, *args)

    def get_count(self):
        return _base.UCharArray_get_count(self)

    def remove_all(self):
        return _base.UCharArray_remove_all(self)

    def resize(self, *args):
        return _base.UCharArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.UCharArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.UCharArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.UCharArray_get_list(self, list)

    def set_list(self, list):
        return _base.UCharArray_set_list(self, list)

    def get_memory_size(self):
        return _base.UCharArray_get_memory_size(self)

    def get_class_info(self):
        return _base.UCharArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UCharArray_class_info)
    else:
        class_info = _base.UCharArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UCharArray____class_destructor__)
    else:
        ___class_destructor__ = _base.UCharArray____class_destructor__
UCharArray_swigregister = _base.UCharArray_swigregister
UCharArray_swigregister(UCharArray)

def UCharArray_class_info():
    return _base.UCharArray_class_info()
UCharArray_class_info = _base.UCharArray_class_info

def UCharArray____class_destructor__(instance, is_array):
    return _base.UCharArray____class_destructor__(instance, is_array)
UCharArray____class_destructor__ = _base.UCharArray____class_destructor__

class UCharVector(UCharBasicArray):
    __swig_setmethods__ = {}
    for _s in [UCharBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UCharVector, name, value)
    __swig_getmethods__ = {}
    for _s in [UCharBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UCharVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UCharVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UCharVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.UCharVector_append(self, *args)

    def add(self, element):
        return _base.UCharVector_add(self, element)

    def insert(self, element, index):
        return _base.UCharVector_insert(self, element, index)

    def remove_last(self):
        return _base.UCharVector_remove_last(self)

    def empty(self):
        return _base.UCharVector_empty(self)

    def remove_all(self):
        return _base.UCharVector_remove_all(self)

    def clear(self, *args):
        return _base.UCharVector_clear(self, *args)

    def remove(self, *args):
        return _base.UCharVector_remove(self, *args)

    def is_empty(self):
        return _base.UCharVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.UCharVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.UCharVector_remove_items(self, item)

    def get_count(self):
        return _base.UCharVector_get_count(self)

    def get_capacity(self):
        return _base.UCharVector_get_capacity(self)

    def set_count(self, *args):
        return _base.UCharVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.UCharVector_set_capacity(self, *args)

    def refit(self):
        return _base.UCharVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.UCharVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.UCharVector_resize(self, *args)

    def reserve(self, *args):
        return _base.UCharVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.UCharVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.UCharVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.UCharVector_get_list(self, list)

    def set_list(self, list):
        return _base.UCharVector_set_list(self, list)

    def get_array(self, array):
        return _base.UCharVector_get_array(self, array)

    def set_array(self, array):
        return _base.UCharVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.UCharVector_move(self, arg2, to)

    def item(self, index):
        return _base.UCharVector_item(self, index)

    def get_memory_size(self):
        return _base.UCharVector_get_memory_size(self)

    def get_class_info(self):
        return _base.UCharVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UCharVector_class_info)
    else:
        class_info = _base.UCharVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UCharVector____class_destructor__)
    else:
        ___class_destructor__ = _base.UCharVector____class_destructor__
UCharVector_swigregister = _base.UCharVector_swigregister
UCharVector_swigregister(UCharVector)

def UCharVector_class_info():
    return _base.UCharVector_class_info()
UCharVector_class_info = _base.UCharVector_class_info

def UCharVector____class_destructor__(instance, is_array):
    return _base.UCharVector____class_destructor__(instance, is_array)
UCharVector____class_destructor__ = _base.UCharVector____class_destructor__

class UCharSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UCharSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UCharSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UCharSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.UCharSet_get_count(self)

    def exists(self, *args):
        return _base.UCharSet_exists(self, *args)

    def is_empty(self):
        return _base.UCharSet_is_empty(self)

    def is_included(self, set):
        return _base.UCharSet_is_included(self, set)

    def get_items(self):
        return _base.UCharSet_get_items(self)

    def get_item(self, index):
        return _base.UCharSet_get_item(self, index)

    def back(self, *args):
        return _base.UCharSet_back(self, *args)

    def get_array(self, array):
        return _base.UCharSet_get_array(self, array)

    def get_list(self, list):
        return _base.UCharSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.UCharSet_get_vector(self, vector)

    def to_array(self):
        return _base.UCharSet_to_array(self)

    def add(self, *args):
        return _base.UCharSet_add(self, *args)

    def remove(self, index):
        return _base.UCharSet_remove(self, index)

    def remove_item(self, item):
        return _base.UCharSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.UCharSet_remove_set(self, set)

    def remove_all(self):
        return _base.UCharSet_remove_all(self)

    def toggle(self, item):
        return _base.UCharSet_toggle(self, item)

    def unite(self, set):
        return _base.UCharSet_unite(self, set)

    def intersect(self, set):
        return _base.UCharSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.UCharSet___eq__(self, set)


    def __ne__(self, set):
        return _base.UCharSet___ne__(self, set)

    def begin(self, *args):
        return _base.UCharSet_begin(self, *args)

    def end(self, *args):
        return _base.UCharSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.UCharSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.UCharSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.UCharSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.UCharSet___setitem__(self, index, value)

    def __len__(self):
        return _base.UCharSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_UCharSet
    __del__ = lambda self: None
UCharSet_swigregister = _base.UCharSet_swigregister
UCharSet_swigregister(UCharSet)

def UCharSet_get_linear_search_threshold():
    return _base.UCharSet_get_linear_search_threshold()
UCharSet_get_linear_search_threshold = _base.UCharSet_get_linear_search_threshold

class ShortBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.ShortBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_ShortBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ShortBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.ShortBasicArray_get_count(self)

    def get_item(self, index):
        return _base.ShortBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.ShortBasicArray_set_item(self, index, item)

    def front(self):
        return _base.ShortBasicArray_front(self)

    def back(self):
        return _base.ShortBasicArray_back(self)

    def exists(self, item):
        return _base.ShortBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.ShortBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.ShortBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.ShortBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.ShortBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.ShortBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.ShortBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ShortBasicArray_class_info)
    else:
        class_info = _base.ShortBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ShortBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.ShortBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.ShortBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.ShortBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

ShortBasicArray_swigregister = _base.ShortBasicArray_swigregister
ShortBasicArray_swigregister(ShortBasicArray)

def ShortBasicArray_class_info():
    return _base.ShortBasicArray_class_info()
ShortBasicArray_class_info = _base.ShortBasicArray_class_info

def ShortBasicArray____class_destructor__(instance, is_array):
    return _base.ShortBasicArray____class_destructor__(instance, is_array)
ShortBasicArray____class_destructor__ = _base.ShortBasicArray____class_destructor__

class ShortArray(ShortBasicArray):
    __swig_setmethods__ = {}
    for _s in [ShortBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortArray, name, value)
    __swig_getmethods__ = {}
    for _s in [ShortBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ShortArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ShortArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.ShortArray_append(self, *args)

    def get_count(self):
        return _base.ShortArray_get_count(self)

    def remove_all(self):
        return _base.ShortArray_remove_all(self)

    def resize(self, *args):
        return _base.ShortArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.ShortArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.ShortArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.ShortArray_get_list(self, list)

    def set_list(self, list):
        return _base.ShortArray_set_list(self, list)

    def get_memory_size(self):
        return _base.ShortArray_get_memory_size(self)

    def get_class_info(self):
        return _base.ShortArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ShortArray_class_info)
    else:
        class_info = _base.ShortArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ShortArray____class_destructor__)
    else:
        ___class_destructor__ = _base.ShortArray____class_destructor__
ShortArray_swigregister = _base.ShortArray_swigregister
ShortArray_swigregister(ShortArray)

def ShortArray_class_info():
    return _base.ShortArray_class_info()
ShortArray_class_info = _base.ShortArray_class_info

def ShortArray____class_destructor__(instance, is_array):
    return _base.ShortArray____class_destructor__(instance, is_array)
ShortArray____class_destructor__ = _base.ShortArray____class_destructor__

class ShortVector(ShortBasicArray):
    __swig_setmethods__ = {}
    for _s in [ShortBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortVector, name, value)
    __swig_getmethods__ = {}
    for _s in [ShortBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ShortVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ShortVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.ShortVector_append(self, *args)

    def add(self, element):
        return _base.ShortVector_add(self, element)

    def insert(self, element, index):
        return _base.ShortVector_insert(self, element, index)

    def remove_last(self):
        return _base.ShortVector_remove_last(self)

    def empty(self):
        return _base.ShortVector_empty(self)

    def remove_all(self):
        return _base.ShortVector_remove_all(self)

    def clear(self, *args):
        return _base.ShortVector_clear(self, *args)

    def remove(self, *args):
        return _base.ShortVector_remove(self, *args)

    def is_empty(self):
        return _base.ShortVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.ShortVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.ShortVector_remove_items(self, item)

    def get_count(self):
        return _base.ShortVector_get_count(self)

    def get_capacity(self):
        return _base.ShortVector_get_capacity(self)

    def set_count(self, *args):
        return _base.ShortVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.ShortVector_set_capacity(self, *args)

    def refit(self):
        return _base.ShortVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.ShortVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.ShortVector_resize(self, *args)

    def reserve(self, *args):
        return _base.ShortVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.ShortVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.ShortVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.ShortVector_get_list(self, list)

    def set_list(self, list):
        return _base.ShortVector_set_list(self, list)

    def get_array(self, array):
        return _base.ShortVector_get_array(self, array)

    def set_array(self, array):
        return _base.ShortVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.ShortVector_move(self, arg2, to)

    def item(self, index):
        return _base.ShortVector_item(self, index)

    def get_memory_size(self):
        return _base.ShortVector_get_memory_size(self)

    def get_class_info(self):
        return _base.ShortVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ShortVector_class_info)
    else:
        class_info = _base.ShortVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ShortVector____class_destructor__)
    else:
        ___class_destructor__ = _base.ShortVector____class_destructor__
ShortVector_swigregister = _base.ShortVector_swigregister
ShortVector_swigregister(ShortVector)

def ShortVector_class_info():
    return _base.ShortVector_class_info()
ShortVector_class_info = _base.ShortVector_class_info

def ShortVector____class_destructor__(instance, is_array):
    return _base.ShortVector____class_destructor__(instance, is_array)
ShortVector____class_destructor__ = _base.ShortVector____class_destructor__

class ShortSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ShortSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ShortSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ShortSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.ShortSet_get_count(self)

    def exists(self, *args):
        return _base.ShortSet_exists(self, *args)

    def is_empty(self):
        return _base.ShortSet_is_empty(self)

    def is_included(self, set):
        return _base.ShortSet_is_included(self, set)

    def get_items(self):
        return _base.ShortSet_get_items(self)

    def get_item(self, index):
        return _base.ShortSet_get_item(self, index)

    def back(self, *args):
        return _base.ShortSet_back(self, *args)

    def get_array(self, array):
        return _base.ShortSet_get_array(self, array)

    def get_list(self, list):
        return _base.ShortSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.ShortSet_get_vector(self, vector)

    def to_array(self):
        return _base.ShortSet_to_array(self)

    def add(self, *args):
        return _base.ShortSet_add(self, *args)

    def remove(self, index):
        return _base.ShortSet_remove(self, index)

    def remove_item(self, item):
        return _base.ShortSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.ShortSet_remove_set(self, set)

    def remove_all(self):
        return _base.ShortSet_remove_all(self)

    def toggle(self, item):
        return _base.ShortSet_toggle(self, item)

    def unite(self, set):
        return _base.ShortSet_unite(self, set)

    def intersect(self, set):
        return _base.ShortSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.ShortSet___eq__(self, set)


    def __ne__(self, set):
        return _base.ShortSet___ne__(self, set)

    def begin(self, *args):
        return _base.ShortSet_begin(self, *args)

    def end(self, *args):
        return _base.ShortSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.ShortSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.ShortSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.ShortSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.ShortSet___setitem__(self, index, value)

    def __len__(self):
        return _base.ShortSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_ShortSet
    __del__ = lambda self: None
ShortSet_swigregister = _base.ShortSet_swigregister
ShortSet_swigregister(ShortSet)

def ShortSet_get_linear_search_threshold():
    return _base.ShortSet_get_linear_search_threshold()
ShortSet_get_linear_search_threshold = _base.ShortSet_get_linear_search_threshold

class UShortBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UShortBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UShortBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.UShortBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_UShortBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UShortBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.UShortBasicArray_get_count(self)

    def get_item(self, index):
        return _base.UShortBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.UShortBasicArray_set_item(self, index, item)

    def front(self):
        return _base.UShortBasicArray_front(self)

    def back(self):
        return _base.UShortBasicArray_back(self)

    def exists(self, item):
        return _base.UShortBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.UShortBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.UShortBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.UShortBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.UShortBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.UShortBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.UShortBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UShortBasicArray_class_info)
    else:
        class_info = _base.UShortBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UShortBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.UShortBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.UShortBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.UShortBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

UShortBasicArray_swigregister = _base.UShortBasicArray_swigregister
UShortBasicArray_swigregister(UShortBasicArray)

def UShortBasicArray_class_info():
    return _base.UShortBasicArray_class_info()
UShortBasicArray_class_info = _base.UShortBasicArray_class_info

def UShortBasicArray____class_destructor__(instance, is_array):
    return _base.UShortBasicArray____class_destructor__(instance, is_array)
UShortBasicArray____class_destructor__ = _base.UShortBasicArray____class_destructor__

class UShortArray(UShortBasicArray):
    __swig_setmethods__ = {}
    for _s in [UShortBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UShortArray, name, value)
    __swig_getmethods__ = {}
    for _s in [UShortBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UShortArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UShortArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UShortArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.UShortArray_append(self, *args)

    def get_count(self):
        return _base.UShortArray_get_count(self)

    def remove_all(self):
        return _base.UShortArray_remove_all(self)

    def resize(self, *args):
        return _base.UShortArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.UShortArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.UShortArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.UShortArray_get_list(self, list)

    def set_list(self, list):
        return _base.UShortArray_set_list(self, list)

    def get_memory_size(self):
        return _base.UShortArray_get_memory_size(self)

    def get_class_info(self):
        return _base.UShortArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UShortArray_class_info)
    else:
        class_info = _base.UShortArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UShortArray____class_destructor__)
    else:
        ___class_destructor__ = _base.UShortArray____class_destructor__
UShortArray_swigregister = _base.UShortArray_swigregister
UShortArray_swigregister(UShortArray)

def UShortArray_class_info():
    return _base.UShortArray_class_info()
UShortArray_class_info = _base.UShortArray_class_info

def UShortArray____class_destructor__(instance, is_array):
    return _base.UShortArray____class_destructor__(instance, is_array)
UShortArray____class_destructor__ = _base.UShortArray____class_destructor__

class UShortVector(UShortBasicArray):
    __swig_setmethods__ = {}
    for _s in [UShortBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UShortVector, name, value)
    __swig_getmethods__ = {}
    for _s in [UShortBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UShortVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UShortVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UShortVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.UShortVector_append(self, *args)

    def add(self, element):
        return _base.UShortVector_add(self, element)

    def insert(self, element, index):
        return _base.UShortVector_insert(self, element, index)

    def remove_last(self):
        return _base.UShortVector_remove_last(self)

    def empty(self):
        return _base.UShortVector_empty(self)

    def remove_all(self):
        return _base.UShortVector_remove_all(self)

    def clear(self, *args):
        return _base.UShortVector_clear(self, *args)

    def remove(self, *args):
        return _base.UShortVector_remove(self, *args)

    def is_empty(self):
        return _base.UShortVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.UShortVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.UShortVector_remove_items(self, item)

    def get_count(self):
        return _base.UShortVector_get_count(self)

    def get_capacity(self):
        return _base.UShortVector_get_capacity(self)

    def set_count(self, *args):
        return _base.UShortVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.UShortVector_set_capacity(self, *args)

    def refit(self):
        return _base.UShortVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.UShortVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.UShortVector_resize(self, *args)

    def reserve(self, *args):
        return _base.UShortVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.UShortVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.UShortVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.UShortVector_get_list(self, list)

    def set_list(self, list):
        return _base.UShortVector_set_list(self, list)

    def get_array(self, array):
        return _base.UShortVector_get_array(self, array)

    def set_array(self, array):
        return _base.UShortVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.UShortVector_move(self, arg2, to)

    def item(self, index):
        return _base.UShortVector_item(self, index)

    def get_memory_size(self):
        return _base.UShortVector_get_memory_size(self)

    def get_class_info(self):
        return _base.UShortVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UShortVector_class_info)
    else:
        class_info = _base.UShortVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UShortVector____class_destructor__)
    else:
        ___class_destructor__ = _base.UShortVector____class_destructor__
UShortVector_swigregister = _base.UShortVector_swigregister
UShortVector_swigregister(UShortVector)

def UShortVector_class_info():
    return _base.UShortVector_class_info()
UShortVector_class_info = _base.UShortVector_class_info

def UShortVector____class_destructor__(instance, is_array):
    return _base.UShortVector____class_destructor__(instance, is_array)
UShortVector____class_destructor__ = _base.UShortVector____class_destructor__

class UShortSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UShortSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UShortSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UShortSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.UShortSet_get_count(self)

    def exists(self, *args):
        return _base.UShortSet_exists(self, *args)

    def is_empty(self):
        return _base.UShortSet_is_empty(self)

    def is_included(self, set):
        return _base.UShortSet_is_included(self, set)

    def get_items(self):
        return _base.UShortSet_get_items(self)

    def get_item(self, index):
        return _base.UShortSet_get_item(self, index)

    def back(self, *args):
        return _base.UShortSet_back(self, *args)

    def get_array(self, array):
        return _base.UShortSet_get_array(self, array)

    def get_list(self, list):
        return _base.UShortSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.UShortSet_get_vector(self, vector)

    def to_array(self):
        return _base.UShortSet_to_array(self)

    def add(self, *args):
        return _base.UShortSet_add(self, *args)

    def remove(self, index):
        return _base.UShortSet_remove(self, index)

    def remove_item(self, item):
        return _base.UShortSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.UShortSet_remove_set(self, set)

    def remove_all(self):
        return _base.UShortSet_remove_all(self)

    def toggle(self, item):
        return _base.UShortSet_toggle(self, item)

    def unite(self, set):
        return _base.UShortSet_unite(self, set)

    def intersect(self, set):
        return _base.UShortSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.UShortSet___eq__(self, set)


    def __ne__(self, set):
        return _base.UShortSet___ne__(self, set)

    def begin(self, *args):
        return _base.UShortSet_begin(self, *args)

    def end(self, *args):
        return _base.UShortSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.UShortSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.UShortSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.UShortSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.UShortSet___setitem__(self, index, value)

    def __len__(self):
        return _base.UShortSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_UShortSet
    __del__ = lambda self: None
UShortSet_swigregister = _base.UShortSet_swigregister
UShortSet_swigregister(UShortSet)

def UShortSet_get_linear_search_threshold():
    return _base.UShortSet_get_linear_search_threshold()
UShortSet_get_linear_search_threshold = _base.UShortSet_get_linear_search_threshold

class IntBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.IntBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_IntBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_IntBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.IntBasicArray_get_count(self)

    def get_item(self, index):
        return _base.IntBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.IntBasicArray_set_item(self, index, item)

    def front(self):
        return _base.IntBasicArray_front(self)

    def back(self):
        return _base.IntBasicArray_back(self)

    def exists(self, item):
        return _base.IntBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.IntBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.IntBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.IntBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.IntBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.IntBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.IntBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.IntBasicArray_class_info)
    else:
        class_info = _base.IntBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.IntBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.IntBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.IntBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.IntBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

IntBasicArray_swigregister = _base.IntBasicArray_swigregister
IntBasicArray_swigregister(IntBasicArray)

def IntBasicArray_class_info():
    return _base.IntBasicArray_class_info()
IntBasicArray_class_info = _base.IntBasicArray_class_info

def IntBasicArray____class_destructor__(instance, is_array):
    return _base.IntBasicArray____class_destructor__(instance, is_array)
IntBasicArray____class_destructor__ = _base.IntBasicArray____class_destructor__

class IntArray(IntBasicArray):
    __swig_setmethods__ = {}
    for _s in [IntBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntArray, name, value)
    __swig_getmethods__ = {}
    for _s in [IntBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_IntArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_IntArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.IntArray_append(self, *args)

    def get_count(self):
        return _base.IntArray_get_count(self)

    def remove_all(self):
        return _base.IntArray_remove_all(self)

    def resize(self, *args):
        return _base.IntArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.IntArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.IntArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.IntArray_get_list(self, list)

    def set_list(self, list):
        return _base.IntArray_set_list(self, list)

    def get_memory_size(self):
        return _base.IntArray_get_memory_size(self)

    def get_class_info(self):
        return _base.IntArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.IntArray_class_info)
    else:
        class_info = _base.IntArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.IntArray____class_destructor__)
    else:
        ___class_destructor__ = _base.IntArray____class_destructor__
IntArray_swigregister = _base.IntArray_swigregister
IntArray_swigregister(IntArray)

def IntArray_class_info():
    return _base.IntArray_class_info()
IntArray_class_info = _base.IntArray_class_info

def IntArray____class_destructor__(instance, is_array):
    return _base.IntArray____class_destructor__(instance, is_array)
IntArray____class_destructor__ = _base.IntArray____class_destructor__

class IntVector(IntBasicArray):
    __swig_setmethods__ = {}
    for _s in [IntBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntVector, name, value)
    __swig_getmethods__ = {}
    for _s in [IntBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_IntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_IntVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.IntVector_append(self, *args)

    def add(self, element):
        return _base.IntVector_add(self, element)

    def insert(self, element, index):
        return _base.IntVector_insert(self, element, index)

    def remove_last(self):
        return _base.IntVector_remove_last(self)

    def empty(self):
        return _base.IntVector_empty(self)

    def remove_all(self):
        return _base.IntVector_remove_all(self)

    def clear(self, *args):
        return _base.IntVector_clear(self, *args)

    def remove(self, *args):
        return _base.IntVector_remove(self, *args)

    def is_empty(self):
        return _base.IntVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.IntVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.IntVector_remove_items(self, item)

    def get_count(self):
        return _base.IntVector_get_count(self)

    def get_capacity(self):
        return _base.IntVector_get_capacity(self)

    def set_count(self, *args):
        return _base.IntVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.IntVector_set_capacity(self, *args)

    def refit(self):
        return _base.IntVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.IntVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.IntVector_resize(self, *args)

    def reserve(self, *args):
        return _base.IntVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.IntVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.IntVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.IntVector_get_list(self, list)

    def set_list(self, list):
        return _base.IntVector_set_list(self, list)

    def get_array(self, array):
        return _base.IntVector_get_array(self, array)

    def set_array(self, array):
        return _base.IntVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.IntVector_move(self, arg2, to)

    def item(self, index):
        return _base.IntVector_item(self, index)

    def get_memory_size(self):
        return _base.IntVector_get_memory_size(self)

    def get_class_info(self):
        return _base.IntVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.IntVector_class_info)
    else:
        class_info = _base.IntVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.IntVector____class_destructor__)
    else:
        ___class_destructor__ = _base.IntVector____class_destructor__
IntVector_swigregister = _base.IntVector_swigregister
IntVector_swigregister(IntVector)

def IntVector_class_info():
    return _base.IntVector_class_info()
IntVector_class_info = _base.IntVector_class_info

def IntVector____class_destructor__(instance, is_array):
    return _base.IntVector____class_destructor__(instance, is_array)
IntVector____class_destructor__ = _base.IntVector____class_destructor__

class IntSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IntSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_IntSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.IntSet_get_count(self)

    def exists(self, *args):
        return _base.IntSet_exists(self, *args)

    def is_empty(self):
        return _base.IntSet_is_empty(self)

    def is_included(self, set):
        return _base.IntSet_is_included(self, set)

    def get_items(self):
        return _base.IntSet_get_items(self)

    def get_item(self, index):
        return _base.IntSet_get_item(self, index)

    def back(self, *args):
        return _base.IntSet_back(self, *args)

    def get_array(self, array):
        return _base.IntSet_get_array(self, array)

    def get_list(self, list):
        return _base.IntSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.IntSet_get_vector(self, vector)

    def to_array(self):
        return _base.IntSet_to_array(self)

    def add(self, *args):
        return _base.IntSet_add(self, *args)

    def remove(self, index):
        return _base.IntSet_remove(self, index)

    def remove_item(self, item):
        return _base.IntSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.IntSet_remove_set(self, set)

    def remove_all(self):
        return _base.IntSet_remove_all(self)

    def toggle(self, item):
        return _base.IntSet_toggle(self, item)

    def unite(self, set):
        return _base.IntSet_unite(self, set)

    def intersect(self, set):
        return _base.IntSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.IntSet___eq__(self, set)


    def __ne__(self, set):
        return _base.IntSet___ne__(self, set)

    def begin(self, *args):
        return _base.IntSet_begin(self, *args)

    def end(self, *args):
        return _base.IntSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.IntSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.IntSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.IntSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.IntSet___setitem__(self, index, value)

    def __len__(self):
        return _base.IntSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_IntSet
    __del__ = lambda self: None
IntSet_swigregister = _base.IntSet_swigregister
IntSet_swigregister(IntSet)

def IntSet_get_linear_search_threshold():
    return _base.IntSet_get_linear_search_threshold()
IntSet_get_linear_search_threshold = _base.IntSet_get_linear_search_threshold

class UIntBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UIntBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.UIntBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_UIntBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UIntBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.UIntBasicArray_get_count(self)

    def get_item(self, index):
        return _base.UIntBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.UIntBasicArray_set_item(self, index, item)

    def front(self):
        return _base.UIntBasicArray_front(self)

    def back(self):
        return _base.UIntBasicArray_back(self)

    def exists(self, item):
        return _base.UIntBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.UIntBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.UIntBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.UIntBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.UIntBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.UIntBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.UIntBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UIntBasicArray_class_info)
    else:
        class_info = _base.UIntBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UIntBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.UIntBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.UIntBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.UIntBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

UIntBasicArray_swigregister = _base.UIntBasicArray_swigregister
UIntBasicArray_swigregister(UIntBasicArray)

def UIntBasicArray_class_info():
    return _base.UIntBasicArray_class_info()
UIntBasicArray_class_info = _base.UIntBasicArray_class_info

def UIntBasicArray____class_destructor__(instance, is_array):
    return _base.UIntBasicArray____class_destructor__(instance, is_array)
UIntBasicArray____class_destructor__ = _base.UIntBasicArray____class_destructor__

class UIntArray(UIntBasicArray):
    __swig_setmethods__ = {}
    for _s in [UIntBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntArray, name, value)
    __swig_getmethods__ = {}
    for _s in [UIntBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UIntArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UIntArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UIntArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.UIntArray_append(self, *args)

    def get_count(self):
        return _base.UIntArray_get_count(self)

    def remove_all(self):
        return _base.UIntArray_remove_all(self)

    def resize(self, *args):
        return _base.UIntArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.UIntArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.UIntArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.UIntArray_get_list(self, list)

    def set_list(self, list):
        return _base.UIntArray_set_list(self, list)

    def get_memory_size(self):
        return _base.UIntArray_get_memory_size(self)

    def get_class_info(self):
        return _base.UIntArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UIntArray_class_info)
    else:
        class_info = _base.UIntArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UIntArray____class_destructor__)
    else:
        ___class_destructor__ = _base.UIntArray____class_destructor__
UIntArray_swigregister = _base.UIntArray_swigregister
UIntArray_swigregister(UIntArray)

def UIntArray_class_info():
    return _base.UIntArray_class_info()
UIntArray_class_info = _base.UIntArray_class_info

def UIntArray____class_destructor__(instance, is_array):
    return _base.UIntArray____class_destructor__(instance, is_array)
UIntArray____class_destructor__ = _base.UIntArray____class_destructor__

class UIntVector(UIntBasicArray):
    __swig_setmethods__ = {}
    for _s in [UIntBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntVector, name, value)
    __swig_getmethods__ = {}
    for _s in [UIntBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UIntVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UIntVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_UIntVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.UIntVector_append(self, *args)

    def add(self, element):
        return _base.UIntVector_add(self, element)

    def insert(self, element, index):
        return _base.UIntVector_insert(self, element, index)

    def remove_last(self):
        return _base.UIntVector_remove_last(self)

    def empty(self):
        return _base.UIntVector_empty(self)

    def remove_all(self):
        return _base.UIntVector_remove_all(self)

    def clear(self, *args):
        return _base.UIntVector_clear(self, *args)

    def remove(self, *args):
        return _base.UIntVector_remove(self, *args)

    def is_empty(self):
        return _base.UIntVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.UIntVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.UIntVector_remove_items(self, item)

    def get_count(self):
        return _base.UIntVector_get_count(self)

    def get_capacity(self):
        return _base.UIntVector_get_capacity(self)

    def set_count(self, *args):
        return _base.UIntVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.UIntVector_set_capacity(self, *args)

    def refit(self):
        return _base.UIntVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.UIntVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.UIntVector_resize(self, *args)

    def reserve(self, *args):
        return _base.UIntVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.UIntVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.UIntVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.UIntVector_get_list(self, list)

    def set_list(self, list):
        return _base.UIntVector_set_list(self, list)

    def get_array(self, array):
        return _base.UIntVector_get_array(self, array)

    def set_array(self, array):
        return _base.UIntVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.UIntVector_move(self, arg2, to)

    def item(self, index):
        return _base.UIntVector_item(self, index)

    def get_memory_size(self):
        return _base.UIntVector_get_memory_size(self)

    def get_class_info(self):
        return _base.UIntVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.UIntVector_class_info)
    else:
        class_info = _base.UIntVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.UIntVector____class_destructor__)
    else:
        ___class_destructor__ = _base.UIntVector____class_destructor__
UIntVector_swigregister = _base.UIntVector_swigregister
UIntVector_swigregister(UIntVector)

def UIntVector_class_info():
    return _base.UIntVector_class_info()
UIntVector_class_info = _base.UIntVector_class_info

def UIntVector____class_destructor__(instance, is_array):
    return _base.UIntVector____class_destructor__(instance, is_array)
UIntVector____class_destructor__ = _base.UIntVector____class_destructor__

class UIntSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UIntSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_UIntSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.UIntSet_get_count(self)

    def exists(self, *args):
        return _base.UIntSet_exists(self, *args)

    def is_empty(self):
        return _base.UIntSet_is_empty(self)

    def is_included(self, set):
        return _base.UIntSet_is_included(self, set)

    def get_items(self):
        return _base.UIntSet_get_items(self)

    def get_item(self, index):
        return _base.UIntSet_get_item(self, index)

    def back(self, *args):
        return _base.UIntSet_back(self, *args)

    def get_array(self, array):
        return _base.UIntSet_get_array(self, array)

    def get_list(self, list):
        return _base.UIntSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.UIntSet_get_vector(self, vector)

    def to_array(self):
        return _base.UIntSet_to_array(self)

    def add(self, *args):
        return _base.UIntSet_add(self, *args)

    def remove(self, index):
        return _base.UIntSet_remove(self, index)

    def remove_item(self, item):
        return _base.UIntSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.UIntSet_remove_set(self, set)

    def remove_all(self):
        return _base.UIntSet_remove_all(self)

    def toggle(self, item):
        return _base.UIntSet_toggle(self, item)

    def unite(self, set):
        return _base.UIntSet_unite(self, set)

    def intersect(self, set):
        return _base.UIntSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.UIntSet___eq__(self, set)


    def __ne__(self, set):
        return _base.UIntSet___ne__(self, set)

    def begin(self, *args):
        return _base.UIntSet_begin(self, *args)

    def end(self, *args):
        return _base.UIntSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.UIntSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.UIntSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.UIntSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.UIntSet___setitem__(self, index, value)

    def __len__(self):
        return _base.UIntSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_UIntSet
    __del__ = lambda self: None
UIntSet_swigregister = _base.UIntSet_swigregister
UIntSet_swigregister(UIntSet)

def UIntSet_get_linear_search_threshold():
    return _base.UIntSet_get_linear_search_threshold()
UIntSet_get_linear_search_threshold = _base.UIntSet_get_linear_search_threshold

class LongBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.LongBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_LongBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_LongBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.LongBasicArray_get_count(self)

    def get_item(self, index):
        return _base.LongBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.LongBasicArray_set_item(self, index, item)

    def front(self):
        return _base.LongBasicArray_front(self)

    def back(self):
        return _base.LongBasicArray_back(self)

    def exists(self, item):
        return _base.LongBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.LongBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.LongBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.LongBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.LongBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.LongBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.LongBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.LongBasicArray_class_info)
    else:
        class_info = _base.LongBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.LongBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.LongBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.LongBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.LongBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

LongBasicArray_swigregister = _base.LongBasicArray_swigregister
LongBasicArray_swigregister(LongBasicArray)

def LongBasicArray_class_info():
    return _base.LongBasicArray_class_info()
LongBasicArray_class_info = _base.LongBasicArray_class_info

def LongBasicArray____class_destructor__(instance, is_array):
    return _base.LongBasicArray____class_destructor__(instance, is_array)
LongBasicArray____class_destructor__ = _base.LongBasicArray____class_destructor__

class LongArray(LongBasicArray):
    __swig_setmethods__ = {}
    for _s in [LongBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongArray, name, value)
    __swig_getmethods__ = {}
    for _s in [LongBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_LongArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_LongArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.LongArray_append(self, *args)

    def get_count(self):
        return _base.LongArray_get_count(self)

    def remove_all(self):
        return _base.LongArray_remove_all(self)

    def resize(self, *args):
        return _base.LongArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.LongArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.LongArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.LongArray_get_list(self, list)

    def set_list(self, list):
        return _base.LongArray_set_list(self, list)

    def get_memory_size(self):
        return _base.LongArray_get_memory_size(self)

    def get_class_info(self):
        return _base.LongArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.LongArray_class_info)
    else:
        class_info = _base.LongArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.LongArray____class_destructor__)
    else:
        ___class_destructor__ = _base.LongArray____class_destructor__
LongArray_swigregister = _base.LongArray_swigregister
LongArray_swigregister(LongArray)

def LongArray_class_info():
    return _base.LongArray_class_info()
LongArray_class_info = _base.LongArray_class_info

def LongArray____class_destructor__(instance, is_array):
    return _base.LongArray____class_destructor__(instance, is_array)
LongArray____class_destructor__ = _base.LongArray____class_destructor__

class LongVector(LongBasicArray):
    __swig_setmethods__ = {}
    for _s in [LongBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongVector, name, value)
    __swig_getmethods__ = {}
    for _s in [LongBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_LongVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_LongVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.LongVector_append(self, *args)

    def add(self, element):
        return _base.LongVector_add(self, element)

    def insert(self, element, index):
        return _base.LongVector_insert(self, element, index)

    def remove_last(self):
        return _base.LongVector_remove_last(self)

    def empty(self):
        return _base.LongVector_empty(self)

    def remove_all(self):
        return _base.LongVector_remove_all(self)

    def clear(self, *args):
        return _base.LongVector_clear(self, *args)

    def remove(self, *args):
        return _base.LongVector_remove(self, *args)

    def is_empty(self):
        return _base.LongVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.LongVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.LongVector_remove_items(self, item)

    def get_count(self):
        return _base.LongVector_get_count(self)

    def get_capacity(self):
        return _base.LongVector_get_capacity(self)

    def set_count(self, *args):
        return _base.LongVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.LongVector_set_capacity(self, *args)

    def refit(self):
        return _base.LongVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.LongVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.LongVector_resize(self, *args)

    def reserve(self, *args):
        return _base.LongVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.LongVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.LongVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.LongVector_get_list(self, list)

    def set_list(self, list):
        return _base.LongVector_set_list(self, list)

    def get_array(self, array):
        return _base.LongVector_get_array(self, array)

    def set_array(self, array):
        return _base.LongVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.LongVector_move(self, arg2, to)

    def item(self, index):
        return _base.LongVector_item(self, index)

    def get_memory_size(self):
        return _base.LongVector_get_memory_size(self)

    def get_class_info(self):
        return _base.LongVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.LongVector_class_info)
    else:
        class_info = _base.LongVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.LongVector____class_destructor__)
    else:
        ___class_destructor__ = _base.LongVector____class_destructor__
LongVector_swigregister = _base.LongVector_swigregister
LongVector_swigregister(LongVector)

def LongVector_class_info():
    return _base.LongVector_class_info()
LongVector_class_info = _base.LongVector_class_info

def LongVector____class_destructor__(instance, is_array):
    return _base.LongVector____class_destructor__(instance, is_array)
LongVector____class_destructor__ = _base.LongVector____class_destructor__

class LongSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_LongSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.LongSet_get_count(self)

    def exists(self, *args):
        return _base.LongSet_exists(self, *args)

    def is_empty(self):
        return _base.LongSet_is_empty(self)

    def is_included(self, set):
        return _base.LongSet_is_included(self, set)

    def get_items(self):
        return _base.LongSet_get_items(self)

    def get_item(self, index):
        return _base.LongSet_get_item(self, index)

    def back(self, *args):
        return _base.LongSet_back(self, *args)

    def get_array(self, array):
        return _base.LongSet_get_array(self, array)

    def get_list(self, list):
        return _base.LongSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.LongSet_get_vector(self, vector)

    def to_array(self):
        return _base.LongSet_to_array(self)

    def add(self, *args):
        return _base.LongSet_add(self, *args)

    def remove(self, index):
        return _base.LongSet_remove(self, index)

    def remove_item(self, item):
        return _base.LongSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.LongSet_remove_set(self, set)

    def remove_all(self):
        return _base.LongSet_remove_all(self)

    def toggle(self, item):
        return _base.LongSet_toggle(self, item)

    def unite(self, set):
        return _base.LongSet_unite(self, set)

    def intersect(self, set):
        return _base.LongSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.LongSet___eq__(self, set)


    def __ne__(self, set):
        return _base.LongSet___ne__(self, set)

    def begin(self, *args):
        return _base.LongSet_begin(self, *args)

    def end(self, *args):
        return _base.LongSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.LongSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.LongSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.LongSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.LongSet___setitem__(self, index, value)

    def __len__(self):
        return _base.LongSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_LongSet
    __del__ = lambda self: None
LongSet_swigregister = _base.LongSet_swigregister
LongSet_swigregister(LongSet)

def LongSet_get_linear_search_threshold():
    return _base.LongSet_get_linear_search_threshold()
LongSet_get_linear_search_threshold = _base.LongSet_get_linear_search_threshold

class LongLongBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongLongBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongLongBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.LongLongBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_LongLongBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_LongLongBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.LongLongBasicArray_get_count(self)

    def get_item(self, index):
        return _base.LongLongBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.LongLongBasicArray_set_item(self, index, item)

    def front(self):
        return _base.LongLongBasicArray_front(self)

    def back(self):
        return _base.LongLongBasicArray_back(self)

    def exists(self, item):
        return _base.LongLongBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.LongLongBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.LongLongBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.LongLongBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.LongLongBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.LongLongBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.LongLongBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.LongLongBasicArray_class_info)
    else:
        class_info = _base.LongLongBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.LongLongBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.LongLongBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.LongLongBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.LongLongBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

LongLongBasicArray_swigregister = _base.LongLongBasicArray_swigregister
LongLongBasicArray_swigregister(LongLongBasicArray)

def LongLongBasicArray_class_info():
    return _base.LongLongBasicArray_class_info()
LongLongBasicArray_class_info = _base.LongLongBasicArray_class_info

def LongLongBasicArray____class_destructor__(instance, is_array):
    return _base.LongLongBasicArray____class_destructor__(instance, is_array)
LongLongBasicArray____class_destructor__ = _base.LongLongBasicArray____class_destructor__

class LongLongArray(LongLongBasicArray):
    __swig_setmethods__ = {}
    for _s in [LongLongBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongLongArray, name, value)
    __swig_getmethods__ = {}
    for _s in [LongLongBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongLongArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_LongLongArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_LongLongArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.LongLongArray_append(self, *args)

    def get_count(self):
        return _base.LongLongArray_get_count(self)

    def remove_all(self):
        return _base.LongLongArray_remove_all(self)

    def resize(self, *args):
        return _base.LongLongArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.LongLongArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.LongLongArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.LongLongArray_get_list(self, list)

    def set_list(self, list):
        return _base.LongLongArray_set_list(self, list)

    def get_memory_size(self):
        return _base.LongLongArray_get_memory_size(self)

    def get_class_info(self):
        return _base.LongLongArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.LongLongArray_class_info)
    else:
        class_info = _base.LongLongArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.LongLongArray____class_destructor__)
    else:
        ___class_destructor__ = _base.LongLongArray____class_destructor__
LongLongArray_swigregister = _base.LongLongArray_swigregister
LongLongArray_swigregister(LongLongArray)

def LongLongArray_class_info():
    return _base.LongLongArray_class_info()
LongLongArray_class_info = _base.LongLongArray_class_info

def LongLongArray____class_destructor__(instance, is_array):
    return _base.LongLongArray____class_destructor__(instance, is_array)
LongLongArray____class_destructor__ = _base.LongLongArray____class_destructor__

class LongLongVector(LongLongBasicArray):
    __swig_setmethods__ = {}
    for _s in [LongLongBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongLongVector, name, value)
    __swig_getmethods__ = {}
    for _s in [LongLongBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongLongVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_LongLongVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_LongLongVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.LongLongVector_append(self, *args)

    def add(self, element):
        return _base.LongLongVector_add(self, element)

    def insert(self, element, index):
        return _base.LongLongVector_insert(self, element, index)

    def remove_last(self):
        return _base.LongLongVector_remove_last(self)

    def empty(self):
        return _base.LongLongVector_empty(self)

    def remove_all(self):
        return _base.LongLongVector_remove_all(self)

    def clear(self, *args):
        return _base.LongLongVector_clear(self, *args)

    def remove(self, *args):
        return _base.LongLongVector_remove(self, *args)

    def is_empty(self):
        return _base.LongLongVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.LongLongVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.LongLongVector_remove_items(self, item)

    def get_count(self):
        return _base.LongLongVector_get_count(self)

    def get_capacity(self):
        return _base.LongLongVector_get_capacity(self)

    def set_count(self, *args):
        return _base.LongLongVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.LongLongVector_set_capacity(self, *args)

    def refit(self):
        return _base.LongLongVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.LongLongVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.LongLongVector_resize(self, *args)

    def reserve(self, *args):
        return _base.LongLongVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.LongLongVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.LongLongVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.LongLongVector_get_list(self, list)

    def set_list(self, list):
        return _base.LongLongVector_set_list(self, list)

    def get_array(self, array):
        return _base.LongLongVector_get_array(self, array)

    def set_array(self, array):
        return _base.LongLongVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.LongLongVector_move(self, arg2, to)

    def item(self, index):
        return _base.LongLongVector_item(self, index)

    def get_memory_size(self):
        return _base.LongLongVector_get_memory_size(self)

    def get_class_info(self):
        return _base.LongLongVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.LongLongVector_class_info)
    else:
        class_info = _base.LongLongVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.LongLongVector____class_destructor__)
    else:
        ___class_destructor__ = _base.LongLongVector____class_destructor__
LongLongVector_swigregister = _base.LongLongVector_swigregister
LongLongVector_swigregister(LongLongVector)

def LongLongVector_class_info():
    return _base.LongLongVector_class_info()
LongLongVector_class_info = _base.LongLongVector_class_info

def LongLongVector____class_destructor__(instance, is_array):
    return _base.LongLongVector____class_destructor__(instance, is_array)
LongLongVector____class_destructor__ = _base.LongLongVector____class_destructor__

class LongLongSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LongLongSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LongLongSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_LongLongSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.LongLongSet_get_count(self)

    def exists(self, *args):
        return _base.LongLongSet_exists(self, *args)

    def is_empty(self):
        return _base.LongLongSet_is_empty(self)

    def is_included(self, set):
        return _base.LongLongSet_is_included(self, set)

    def get_items(self):
        return _base.LongLongSet_get_items(self)

    def get_item(self, index):
        return _base.LongLongSet_get_item(self, index)

    def back(self, *args):
        return _base.LongLongSet_back(self, *args)

    def get_array(self, array):
        return _base.LongLongSet_get_array(self, array)

    def get_list(self, list):
        return _base.LongLongSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.LongLongSet_get_vector(self, vector)

    def to_array(self):
        return _base.LongLongSet_to_array(self)

    def add(self, *args):
        return _base.LongLongSet_add(self, *args)

    def remove(self, index):
        return _base.LongLongSet_remove(self, index)

    def remove_item(self, item):
        return _base.LongLongSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.LongLongSet_remove_set(self, set)

    def remove_all(self):
        return _base.LongLongSet_remove_all(self)

    def toggle(self, item):
        return _base.LongLongSet_toggle(self, item)

    def unite(self, set):
        return _base.LongLongSet_unite(self, set)

    def intersect(self, set):
        return _base.LongLongSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.LongLongSet___eq__(self, set)


    def __ne__(self, set):
        return _base.LongLongSet___ne__(self, set)

    def begin(self, *args):
        return _base.LongLongSet_begin(self, *args)

    def end(self, *args):
        return _base.LongLongSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.LongLongSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.LongLongSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.LongLongSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.LongLongSet___setitem__(self, index, value)

    def __len__(self):
        return _base.LongLongSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_LongLongSet
    __del__ = lambda self: None
LongLongSet_swigregister = _base.LongLongSet_swigregister
LongLongSet_swigregister(LongLongSet)

def LongLongSet_get_linear_search_threshold():
    return _base.LongLongSet_get_linear_search_threshold()
LongLongSet_get_linear_search_threshold = _base.LongLongSet_get_linear_search_threshold

class ULongBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.ULongBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_ULongBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ULongBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.ULongBasicArray_get_count(self)

    def get_item(self, index):
        return _base.ULongBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.ULongBasicArray_set_item(self, index, item)

    def front(self):
        return _base.ULongBasicArray_front(self)

    def back(self):
        return _base.ULongBasicArray_back(self)

    def exists(self, item):
        return _base.ULongBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.ULongBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.ULongBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.ULongBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.ULongBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.ULongBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.ULongBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ULongBasicArray_class_info)
    else:
        class_info = _base.ULongBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ULongBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.ULongBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.ULongBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.ULongBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

ULongBasicArray_swigregister = _base.ULongBasicArray_swigregister
ULongBasicArray_swigregister(ULongBasicArray)

def ULongBasicArray_class_info():
    return _base.ULongBasicArray_class_info()
ULongBasicArray_class_info = _base.ULongBasicArray_class_info

def ULongBasicArray____class_destructor__(instance, is_array):
    return _base.ULongBasicArray____class_destructor__(instance, is_array)
ULongBasicArray____class_destructor__ = _base.ULongBasicArray____class_destructor__

class ULongArray(ULongBasicArray):
    __swig_setmethods__ = {}
    for _s in [ULongBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongArray, name, value)
    __swig_getmethods__ = {}
    for _s in [ULongBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ULongArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ULongArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.ULongArray_append(self, *args)

    def get_count(self):
        return _base.ULongArray_get_count(self)

    def remove_all(self):
        return _base.ULongArray_remove_all(self)

    def resize(self, *args):
        return _base.ULongArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.ULongArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.ULongArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.ULongArray_get_list(self, list)

    def set_list(self, list):
        return _base.ULongArray_set_list(self, list)

    def get_memory_size(self):
        return _base.ULongArray_get_memory_size(self)

    def get_class_info(self):
        return _base.ULongArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ULongArray_class_info)
    else:
        class_info = _base.ULongArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ULongArray____class_destructor__)
    else:
        ___class_destructor__ = _base.ULongArray____class_destructor__
ULongArray_swigregister = _base.ULongArray_swigregister
ULongArray_swigregister(ULongArray)

def ULongArray_class_info():
    return _base.ULongArray_class_info()
ULongArray_class_info = _base.ULongArray_class_info

def ULongArray____class_destructor__(instance, is_array):
    return _base.ULongArray____class_destructor__(instance, is_array)
ULongArray____class_destructor__ = _base.ULongArray____class_destructor__

class ULongVector(ULongBasicArray):
    __swig_setmethods__ = {}
    for _s in [ULongBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongVector, name, value)
    __swig_getmethods__ = {}
    for _s in [ULongBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ULongVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ULongVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.ULongVector_append(self, *args)

    def add(self, element):
        return _base.ULongVector_add(self, element)

    def insert(self, element, index):
        return _base.ULongVector_insert(self, element, index)

    def remove_last(self):
        return _base.ULongVector_remove_last(self)

    def empty(self):
        return _base.ULongVector_empty(self)

    def remove_all(self):
        return _base.ULongVector_remove_all(self)

    def clear(self, *args):
        return _base.ULongVector_clear(self, *args)

    def remove(self, *args):
        return _base.ULongVector_remove(self, *args)

    def is_empty(self):
        return _base.ULongVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.ULongVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.ULongVector_remove_items(self, item)

    def get_count(self):
        return _base.ULongVector_get_count(self)

    def get_capacity(self):
        return _base.ULongVector_get_capacity(self)

    def set_count(self, *args):
        return _base.ULongVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.ULongVector_set_capacity(self, *args)

    def refit(self):
        return _base.ULongVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.ULongVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.ULongVector_resize(self, *args)

    def reserve(self, *args):
        return _base.ULongVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.ULongVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.ULongVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.ULongVector_get_list(self, list)

    def set_list(self, list):
        return _base.ULongVector_set_list(self, list)

    def get_array(self, array):
        return _base.ULongVector_get_array(self, array)

    def set_array(self, array):
        return _base.ULongVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.ULongVector_move(self, arg2, to)

    def item(self, index):
        return _base.ULongVector_item(self, index)

    def get_memory_size(self):
        return _base.ULongVector_get_memory_size(self)

    def get_class_info(self):
        return _base.ULongVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ULongVector_class_info)
    else:
        class_info = _base.ULongVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ULongVector____class_destructor__)
    else:
        ___class_destructor__ = _base.ULongVector____class_destructor__
ULongVector_swigregister = _base.ULongVector_swigregister
ULongVector_swigregister(ULongVector)

def ULongVector_class_info():
    return _base.ULongVector_class_info()
ULongVector_class_info = _base.ULongVector_class_info

def ULongVector____class_destructor__(instance, is_array):
    return _base.ULongVector____class_destructor__(instance, is_array)
ULongVector____class_destructor__ = _base.ULongVector____class_destructor__

class ULongSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ULongSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.ULongSet_get_count(self)

    def exists(self, *args):
        return _base.ULongSet_exists(self, *args)

    def is_empty(self):
        return _base.ULongSet_is_empty(self)

    def is_included(self, set):
        return _base.ULongSet_is_included(self, set)

    def get_items(self):
        return _base.ULongSet_get_items(self)

    def get_item(self, index):
        return _base.ULongSet_get_item(self, index)

    def back(self, *args):
        return _base.ULongSet_back(self, *args)

    def get_array(self, array):
        return _base.ULongSet_get_array(self, array)

    def get_list(self, list):
        return _base.ULongSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.ULongSet_get_vector(self, vector)

    def to_array(self):
        return _base.ULongSet_to_array(self)

    def add(self, *args):
        return _base.ULongSet_add(self, *args)

    def remove(self, index):
        return _base.ULongSet_remove(self, index)

    def remove_item(self, item):
        return _base.ULongSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.ULongSet_remove_set(self, set)

    def remove_all(self):
        return _base.ULongSet_remove_all(self)

    def toggle(self, item):
        return _base.ULongSet_toggle(self, item)

    def unite(self, set):
        return _base.ULongSet_unite(self, set)

    def intersect(self, set):
        return _base.ULongSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.ULongSet___eq__(self, set)


    def __ne__(self, set):
        return _base.ULongSet___ne__(self, set)

    def begin(self, *args):
        return _base.ULongSet_begin(self, *args)

    def end(self, *args):
        return _base.ULongSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.ULongSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.ULongSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.ULongSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.ULongSet___setitem__(self, index, value)

    def __len__(self):
        return _base.ULongSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_ULongSet
    __del__ = lambda self: None
ULongSet_swigregister = _base.ULongSet_swigregister
ULongSet_swigregister(ULongSet)

def ULongSet_get_linear_search_threshold():
    return _base.ULongSet_get_linear_search_threshold()
ULongSet_get_linear_search_threshold = _base.ULongSet_get_linear_search_threshold

class ULongLongBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongLongBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongLongBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.ULongLongBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_ULongLongBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ULongLongBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.ULongLongBasicArray_get_count(self)

    def get_item(self, index):
        return _base.ULongLongBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.ULongLongBasicArray_set_item(self, index, item)

    def front(self):
        return _base.ULongLongBasicArray_front(self)

    def back(self):
        return _base.ULongLongBasicArray_back(self)

    def exists(self, item):
        return _base.ULongLongBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.ULongLongBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.ULongLongBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.ULongLongBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.ULongLongBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.ULongLongBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.ULongLongBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ULongLongBasicArray_class_info)
    else:
        class_info = _base.ULongLongBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ULongLongBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.ULongLongBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.ULongLongBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.ULongLongBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

ULongLongBasicArray_swigregister = _base.ULongLongBasicArray_swigregister
ULongLongBasicArray_swigregister(ULongLongBasicArray)

def ULongLongBasicArray_class_info():
    return _base.ULongLongBasicArray_class_info()
ULongLongBasicArray_class_info = _base.ULongLongBasicArray_class_info

def ULongLongBasicArray____class_destructor__(instance, is_array):
    return _base.ULongLongBasicArray____class_destructor__(instance, is_array)
ULongLongBasicArray____class_destructor__ = _base.ULongLongBasicArray____class_destructor__

class ULongLongArray(ULongLongBasicArray):
    __swig_setmethods__ = {}
    for _s in [ULongLongBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongLongArray, name, value)
    __swig_getmethods__ = {}
    for _s in [ULongLongBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongLongArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ULongLongArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ULongLongArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.ULongLongArray_append(self, *args)

    def get_count(self):
        return _base.ULongLongArray_get_count(self)

    def remove_all(self):
        return _base.ULongLongArray_remove_all(self)

    def resize(self, *args):
        return _base.ULongLongArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.ULongLongArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.ULongLongArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.ULongLongArray_get_list(self, list)

    def set_list(self, list):
        return _base.ULongLongArray_set_list(self, list)

    def get_memory_size(self):
        return _base.ULongLongArray_get_memory_size(self)

    def get_class_info(self):
        return _base.ULongLongArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ULongLongArray_class_info)
    else:
        class_info = _base.ULongLongArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ULongLongArray____class_destructor__)
    else:
        ___class_destructor__ = _base.ULongLongArray____class_destructor__
ULongLongArray_swigregister = _base.ULongLongArray_swigregister
ULongLongArray_swigregister(ULongLongArray)

def ULongLongArray_class_info():
    return _base.ULongLongArray_class_info()
ULongLongArray_class_info = _base.ULongLongArray_class_info

def ULongLongArray____class_destructor__(instance, is_array):
    return _base.ULongLongArray____class_destructor__(instance, is_array)
ULongLongArray____class_destructor__ = _base.ULongLongArray____class_destructor__

class ULongLongVector(ULongLongBasicArray):
    __swig_setmethods__ = {}
    for _s in [ULongLongBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongLongVector, name, value)
    __swig_getmethods__ = {}
    for _s in [ULongLongBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongLongVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ULongLongVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ULongLongVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.ULongLongVector_append(self, *args)

    def add(self, element):
        return _base.ULongLongVector_add(self, element)

    def insert(self, element, index):
        return _base.ULongLongVector_insert(self, element, index)

    def remove_last(self):
        return _base.ULongLongVector_remove_last(self)

    def empty(self):
        return _base.ULongLongVector_empty(self)

    def remove_all(self):
        return _base.ULongLongVector_remove_all(self)

    def clear(self, *args):
        return _base.ULongLongVector_clear(self, *args)

    def remove(self, *args):
        return _base.ULongLongVector_remove(self, *args)

    def is_empty(self):
        return _base.ULongLongVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.ULongLongVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.ULongLongVector_remove_items(self, item)

    def get_count(self):
        return _base.ULongLongVector_get_count(self)

    def get_capacity(self):
        return _base.ULongLongVector_get_capacity(self)

    def set_count(self, *args):
        return _base.ULongLongVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.ULongLongVector_set_capacity(self, *args)

    def refit(self):
        return _base.ULongLongVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.ULongLongVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.ULongLongVector_resize(self, *args)

    def reserve(self, *args):
        return _base.ULongLongVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.ULongLongVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.ULongLongVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.ULongLongVector_get_list(self, list)

    def set_list(self, list):
        return _base.ULongLongVector_set_list(self, list)

    def get_array(self, array):
        return _base.ULongLongVector_get_array(self, array)

    def set_array(self, array):
        return _base.ULongLongVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.ULongLongVector_move(self, arg2, to)

    def item(self, index):
        return _base.ULongLongVector_item(self, index)

    def get_memory_size(self):
        return _base.ULongLongVector_get_memory_size(self)

    def get_class_info(self):
        return _base.ULongLongVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.ULongLongVector_class_info)
    else:
        class_info = _base.ULongLongVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.ULongLongVector____class_destructor__)
    else:
        ___class_destructor__ = _base.ULongLongVector____class_destructor__
ULongLongVector_swigregister = _base.ULongLongVector_swigregister
ULongLongVector_swigregister(ULongLongVector)

def ULongLongVector_class_info():
    return _base.ULongLongVector_class_info()
ULongLongVector_class_info = _base.ULongLongVector_class_info

def ULongLongVector____class_destructor__(instance, is_array):
    return _base.ULongLongVector____class_destructor__(instance, is_array)
ULongLongVector____class_destructor__ = _base.ULongLongVector____class_destructor__

class ULongLongSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ULongLongSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ULongLongSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ULongLongSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.ULongLongSet_get_count(self)

    def exists(self, *args):
        return _base.ULongLongSet_exists(self, *args)

    def is_empty(self):
        return _base.ULongLongSet_is_empty(self)

    def is_included(self, set):
        return _base.ULongLongSet_is_included(self, set)

    def get_items(self):
        return _base.ULongLongSet_get_items(self)

    def get_item(self, index):
        return _base.ULongLongSet_get_item(self, index)

    def back(self, *args):
        return _base.ULongLongSet_back(self, *args)

    def get_array(self, array):
        return _base.ULongLongSet_get_array(self, array)

    def get_list(self, list):
        return _base.ULongLongSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.ULongLongSet_get_vector(self, vector)

    def to_array(self):
        return _base.ULongLongSet_to_array(self)

    def add(self, *args):
        return _base.ULongLongSet_add(self, *args)

    def remove(self, index):
        return _base.ULongLongSet_remove(self, index)

    def remove_item(self, item):
        return _base.ULongLongSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.ULongLongSet_remove_set(self, set)

    def remove_all(self):
        return _base.ULongLongSet_remove_all(self)

    def toggle(self, item):
        return _base.ULongLongSet_toggle(self, item)

    def unite(self, set):
        return _base.ULongLongSet_unite(self, set)

    def intersect(self, set):
        return _base.ULongLongSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.ULongLongSet___eq__(self, set)


    def __ne__(self, set):
        return _base.ULongLongSet___ne__(self, set)

    def begin(self, *args):
        return _base.ULongLongSet_begin(self, *args)

    def end(self, *args):
        return _base.ULongLongSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.ULongLongSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.ULongLongSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.ULongLongSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.ULongLongSet___setitem__(self, index, value)

    def __len__(self):
        return _base.ULongLongSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_ULongLongSet
    __del__ = lambda self: None
ULongLongSet_swigregister = _base.ULongLongSet_swigregister
ULongLongSet_swigregister(ULongLongSet)

def ULongLongSet_get_linear_search_threshold():
    return _base.ULongLongSet_get_linear_search_threshold()
ULongLongSet_get_linear_search_threshold = _base.ULongLongSet_get_linear_search_threshold

class FloatBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.FloatBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_FloatBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_FloatBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.FloatBasicArray_get_count(self)

    def get_item(self, index):
        return _base.FloatBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.FloatBasicArray_set_item(self, index, item)

    def front(self):
        return _base.FloatBasicArray_front(self)

    def back(self):
        return _base.FloatBasicArray_back(self)

    def exists(self, item):
        return _base.FloatBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.FloatBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.FloatBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.FloatBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.FloatBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.FloatBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.FloatBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.FloatBasicArray_class_info)
    else:
        class_info = _base.FloatBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.FloatBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.FloatBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.FloatBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.FloatBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

FloatBasicArray_swigregister = _base.FloatBasicArray_swigregister
FloatBasicArray_swigregister(FloatBasicArray)

def FloatBasicArray_class_info():
    return _base.FloatBasicArray_class_info()
FloatBasicArray_class_info = _base.FloatBasicArray_class_info

def FloatBasicArray____class_destructor__(instance, is_array):
    return _base.FloatBasicArray____class_destructor__(instance, is_array)
FloatBasicArray____class_destructor__ = _base.FloatBasicArray____class_destructor__

class FloatArray(FloatBasicArray):
    __swig_setmethods__ = {}
    for _s in [FloatBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatArray, name, value)
    __swig_getmethods__ = {}
    for _s in [FloatBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_FloatArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_FloatArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.FloatArray_append(self, *args)

    def get_count(self):
        return _base.FloatArray_get_count(self)

    def remove_all(self):
        return _base.FloatArray_remove_all(self)

    def resize(self, *args):
        return _base.FloatArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.FloatArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.FloatArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.FloatArray_get_list(self, list)

    def set_list(self, list):
        return _base.FloatArray_set_list(self, list)

    def get_memory_size(self):
        return _base.FloatArray_get_memory_size(self)

    def get_class_info(self):
        return _base.FloatArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.FloatArray_class_info)
    else:
        class_info = _base.FloatArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.FloatArray____class_destructor__)
    else:
        ___class_destructor__ = _base.FloatArray____class_destructor__
FloatArray_swigregister = _base.FloatArray_swigregister
FloatArray_swigregister(FloatArray)

def FloatArray_class_info():
    return _base.FloatArray_class_info()
FloatArray_class_info = _base.FloatArray_class_info

def FloatArray____class_destructor__(instance, is_array):
    return _base.FloatArray____class_destructor__(instance, is_array)
FloatArray____class_destructor__ = _base.FloatArray____class_destructor__

class FloatVector(FloatBasicArray):
    __swig_setmethods__ = {}
    for _s in [FloatBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatVector, name, value)
    __swig_getmethods__ = {}
    for _s in [FloatBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_FloatVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_FloatVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.FloatVector_append(self, *args)

    def add(self, element):
        return _base.FloatVector_add(self, element)

    def insert(self, element, index):
        return _base.FloatVector_insert(self, element, index)

    def remove_last(self):
        return _base.FloatVector_remove_last(self)

    def empty(self):
        return _base.FloatVector_empty(self)

    def remove_all(self):
        return _base.FloatVector_remove_all(self)

    def clear(self, *args):
        return _base.FloatVector_clear(self, *args)

    def remove(self, *args):
        return _base.FloatVector_remove(self, *args)

    def is_empty(self):
        return _base.FloatVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.FloatVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.FloatVector_remove_items(self, item)

    def get_count(self):
        return _base.FloatVector_get_count(self)

    def get_capacity(self):
        return _base.FloatVector_get_capacity(self)

    def set_count(self, *args):
        return _base.FloatVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.FloatVector_set_capacity(self, *args)

    def refit(self):
        return _base.FloatVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.FloatVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.FloatVector_resize(self, *args)

    def reserve(self, *args):
        return _base.FloatVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.FloatVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.FloatVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.FloatVector_get_list(self, list)

    def set_list(self, list):
        return _base.FloatVector_set_list(self, list)

    def get_array(self, array):
        return _base.FloatVector_get_array(self, array)

    def set_array(self, array):
        return _base.FloatVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.FloatVector_move(self, arg2, to)

    def item(self, index):
        return _base.FloatVector_item(self, index)

    def get_memory_size(self):
        return _base.FloatVector_get_memory_size(self)

    def get_class_info(self):
        return _base.FloatVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.FloatVector_class_info)
    else:
        class_info = _base.FloatVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.FloatVector____class_destructor__)
    else:
        ___class_destructor__ = _base.FloatVector____class_destructor__
FloatVector_swigregister = _base.FloatVector_swigregister
FloatVector_swigregister(FloatVector)

def FloatVector_class_info():
    return _base.FloatVector_class_info()
FloatVector_class_info = _base.FloatVector_class_info

def FloatVector____class_destructor__(instance, is_array):
    return _base.FloatVector____class_destructor__(instance, is_array)
FloatVector____class_destructor__ = _base.FloatVector____class_destructor__

class FloatSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FloatSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FloatSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_FloatSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.FloatSet_get_count(self)

    def exists(self, *args):
        return _base.FloatSet_exists(self, *args)

    def is_empty(self):
        return _base.FloatSet_is_empty(self)

    def is_included(self, set):
        return _base.FloatSet_is_included(self, set)

    def get_items(self):
        return _base.FloatSet_get_items(self)

    def get_item(self, index):
        return _base.FloatSet_get_item(self, index)

    def back(self, *args):
        return _base.FloatSet_back(self, *args)

    def get_array(self, array):
        return _base.FloatSet_get_array(self, array)

    def get_list(self, list):
        return _base.FloatSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.FloatSet_get_vector(self, vector)

    def to_array(self):
        return _base.FloatSet_to_array(self)

    def add(self, *args):
        return _base.FloatSet_add(self, *args)

    def remove(self, index):
        return _base.FloatSet_remove(self, index)

    def remove_item(self, item):
        return _base.FloatSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.FloatSet_remove_set(self, set)

    def remove_all(self):
        return _base.FloatSet_remove_all(self)

    def toggle(self, item):
        return _base.FloatSet_toggle(self, item)

    def unite(self, set):
        return _base.FloatSet_unite(self, set)

    def intersect(self, set):
        return _base.FloatSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.FloatSet___eq__(self, set)


    def __ne__(self, set):
        return _base.FloatSet___ne__(self, set)

    def begin(self, *args):
        return _base.FloatSet_begin(self, *args)

    def end(self, *args):
        return _base.FloatSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.FloatSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.FloatSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.FloatSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.FloatSet___setitem__(self, index, value)

    def __len__(self):
        return _base.FloatSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_FloatSet
    __del__ = lambda self: None
FloatSet_swigregister = _base.FloatSet_swigregister
FloatSet_swigregister(FloatSet)

def FloatSet_get_linear_search_threshold():
    return _base.FloatSet_get_linear_search_threshold()
FloatSet_get_linear_search_threshold = _base.FloatSet_get_linear_search_threshold

class DoubleBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.DoubleBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_DoubleBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_DoubleBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.DoubleBasicArray_get_count(self)

    def get_item(self, index):
        return _base.DoubleBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.DoubleBasicArray_set_item(self, index, item)

    def front(self):
        return _base.DoubleBasicArray_front(self)

    def back(self):
        return _base.DoubleBasicArray_back(self)

    def exists(self, item):
        return _base.DoubleBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.DoubleBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.DoubleBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.DoubleBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.DoubleBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.DoubleBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.DoubleBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.DoubleBasicArray_class_info)
    else:
        class_info = _base.DoubleBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.DoubleBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.DoubleBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.DoubleBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.DoubleBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

DoubleBasicArray_swigregister = _base.DoubleBasicArray_swigregister
DoubleBasicArray_swigregister(DoubleBasicArray)

def DoubleBasicArray_class_info():
    return _base.DoubleBasicArray_class_info()
DoubleBasicArray_class_info = _base.DoubleBasicArray_class_info

def DoubleBasicArray____class_destructor__(instance, is_array):
    return _base.DoubleBasicArray____class_destructor__(instance, is_array)
DoubleBasicArray____class_destructor__ = _base.DoubleBasicArray____class_destructor__

class DoubleArray(DoubleBasicArray):
    __swig_setmethods__ = {}
    for _s in [DoubleBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleArray, name, value)
    __swig_getmethods__ = {}
    for _s in [DoubleBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_DoubleArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_DoubleArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.DoubleArray_append(self, *args)

    def get_count(self):
        return _base.DoubleArray_get_count(self)

    def remove_all(self):
        return _base.DoubleArray_remove_all(self)

    def resize(self, *args):
        return _base.DoubleArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.DoubleArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.DoubleArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.DoubleArray_get_list(self, list)

    def set_list(self, list):
        return _base.DoubleArray_set_list(self, list)

    def get_memory_size(self):
        return _base.DoubleArray_get_memory_size(self)

    def get_class_info(self):
        return _base.DoubleArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.DoubleArray_class_info)
    else:
        class_info = _base.DoubleArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.DoubleArray____class_destructor__)
    else:
        ___class_destructor__ = _base.DoubleArray____class_destructor__
DoubleArray_swigregister = _base.DoubleArray_swigregister
DoubleArray_swigregister(DoubleArray)

def DoubleArray_class_info():
    return _base.DoubleArray_class_info()
DoubleArray_class_info = _base.DoubleArray_class_info

def DoubleArray____class_destructor__(instance, is_array):
    return _base.DoubleArray____class_destructor__(instance, is_array)
DoubleArray____class_destructor__ = _base.DoubleArray____class_destructor__

class DoubleVector(DoubleBasicArray):
    __swig_setmethods__ = {}
    for _s in [DoubleBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleVector, name, value)
    __swig_getmethods__ = {}
    for _s in [DoubleBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_DoubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_DoubleVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.DoubleVector_append(self, *args)

    def add(self, element):
        return _base.DoubleVector_add(self, element)

    def insert(self, element, index):
        return _base.DoubleVector_insert(self, element, index)

    def remove_last(self):
        return _base.DoubleVector_remove_last(self)

    def empty(self):
        return _base.DoubleVector_empty(self)

    def remove_all(self):
        return _base.DoubleVector_remove_all(self)

    def clear(self, *args):
        return _base.DoubleVector_clear(self, *args)

    def remove(self, *args):
        return _base.DoubleVector_remove(self, *args)

    def is_empty(self):
        return _base.DoubleVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.DoubleVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.DoubleVector_remove_items(self, item)

    def get_count(self):
        return _base.DoubleVector_get_count(self)

    def get_capacity(self):
        return _base.DoubleVector_get_capacity(self)

    def set_count(self, *args):
        return _base.DoubleVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.DoubleVector_set_capacity(self, *args)

    def refit(self):
        return _base.DoubleVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.DoubleVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.DoubleVector_resize(self, *args)

    def reserve(self, *args):
        return _base.DoubleVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.DoubleVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.DoubleVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.DoubleVector_get_list(self, list)

    def set_list(self, list):
        return _base.DoubleVector_set_list(self, list)

    def get_array(self, array):
        return _base.DoubleVector_get_array(self, array)

    def set_array(self, array):
        return _base.DoubleVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.DoubleVector_move(self, arg2, to)

    def item(self, index):
        return _base.DoubleVector_item(self, index)

    def get_memory_size(self):
        return _base.DoubleVector_get_memory_size(self)

    def get_class_info(self):
        return _base.DoubleVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.DoubleVector_class_info)
    else:
        class_info = _base.DoubleVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.DoubleVector____class_destructor__)
    else:
        ___class_destructor__ = _base.DoubleVector____class_destructor__
DoubleVector_swigregister = _base.DoubleVector_swigregister
DoubleVector_swigregister(DoubleVector)

def DoubleVector_class_info():
    return _base.DoubleVector_class_info()
DoubleVector_class_info = _base.DoubleVector_class_info

def DoubleVector____class_destructor__(instance, is_array):
    return _base.DoubleVector____class_destructor__(instance, is_array)
DoubleVector____class_destructor__ = _base.DoubleVector____class_destructor__

class DoubleSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_DoubleSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.DoubleSet_get_count(self)

    def exists(self, *args):
        return _base.DoubleSet_exists(self, *args)

    def is_empty(self):
        return _base.DoubleSet_is_empty(self)

    def is_included(self, set):
        return _base.DoubleSet_is_included(self, set)

    def get_items(self):
        return _base.DoubleSet_get_items(self)

    def get_item(self, index):
        return _base.DoubleSet_get_item(self, index)

    def back(self, *args):
        return _base.DoubleSet_back(self, *args)

    def get_array(self, array):
        return _base.DoubleSet_get_array(self, array)

    def get_list(self, list):
        return _base.DoubleSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.DoubleSet_get_vector(self, vector)

    def to_array(self):
        return _base.DoubleSet_to_array(self)

    def add(self, *args):
        return _base.DoubleSet_add(self, *args)

    def remove(self, index):
        return _base.DoubleSet_remove(self, index)

    def remove_item(self, item):
        return _base.DoubleSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.DoubleSet_remove_set(self, set)

    def remove_all(self):
        return _base.DoubleSet_remove_all(self)

    def toggle(self, item):
        return _base.DoubleSet_toggle(self, item)

    def unite(self, set):
        return _base.DoubleSet_unite(self, set)

    def intersect(self, set):
        return _base.DoubleSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.DoubleSet___eq__(self, set)


    def __ne__(self, set):
        return _base.DoubleSet___ne__(self, set)

    def begin(self, *args):
        return _base.DoubleSet_begin(self, *args)

    def end(self, *args):
        return _base.DoubleSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.DoubleSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.DoubleSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.DoubleSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.DoubleSet___setitem__(self, index, value)

    def __len__(self):
        return _base.DoubleSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_DoubleSet
    __del__ = lambda self: None
DoubleSet_swigregister = _base.DoubleSet_swigregister
DoubleSet_swigregister(DoubleSet)

def DoubleSet_get_linear_search_threshold():
    return _base.DoubleSet_get_linear_search_threshold()
DoubleSet_get_linear_search_threshold = _base.DoubleSet_get_linear_search_threshold

GMATH_EXPF_DECAY_LIMIT = _base.GMATH_EXPF_DECAY_LIMIT
GMATH_EXPD_DECAY_LIMIT = _base.GMATH_EXPD_DECAY_LIMIT
AXIS_X = _base.AXIS_X
AXIS_Y = _base.AXIS_Y
AXIS_Z = _base.AXIS_Z
AXIS_COUNT = _base.AXIS_COUNT

def gmath_get_axis_name(axis):
    return _base.gmath_get_axis_name(axis)
gmath_get_axis_name = _base.gmath_get_axis_name
GMATH_ROTATION_ORDER_ZYX = _base.GMATH_ROTATION_ORDER_ZYX
GMATH_ROTATION_ORDER_YZX = _base.GMATH_ROTATION_ORDER_YZX
GMATH_ROTATION_ORDER_XZY = _base.GMATH_ROTATION_ORDER_XZY
GMATH_ROTATION_ORDER_ZXY = _base.GMATH_ROTATION_ORDER_ZXY
GMATH_ROTATION_ORDER_YXZ = _base.GMATH_ROTATION_ORDER_YXZ
GMATH_ROTATION_ORDER_XYZ = _base.GMATH_ROTATION_ORDER_XYZ
GMATH_ROTATION_ORDER_COUNT = _base.GMATH_ROTATION_ORDER_COUNT

def gmath_get_rotation_order_axis(rot_order, position):
    return _base.gmath_get_rotation_order_axis(rot_order, position)
gmath_get_rotation_order_axis = _base.gmath_get_rotation_order_axis

def gmath_get_rotation_order_name(order):
    return _base.gmath_get_rotation_order_name(order)
gmath_get_rotation_order_name = _base.gmath_get_rotation_order_name

def gmath_isfinitef(v):
    return _base.gmath_isfinitef(v)
gmath_isfinitef = _base.gmath_isfinitef

def gmath_isfinited(v):
    return _base.gmath_isfinited(v)
gmath_isfinited = _base.gmath_isfinited

def gmath_isfiniteld(v):
    return _base.gmath_isfiniteld(v)
gmath_isfiniteld = _base.gmath_isfiniteld

def gmath_isnanf(v):
    return _base.gmath_isnanf(v)
gmath_isnanf = _base.gmath_isnanf

def gmath_isnand(v):
    return _base.gmath_isnand(v)
gmath_isnand = _base.gmath_isnand

def gmath_isnanld(v):
    return _base.gmath_isnanld(v)
gmath_isnanld = _base.gmath_isnanld

def gmath_isinff(v):
    return _base.gmath_isinff(v)
gmath_isinff = _base.gmath_isinff

def gmath_isinfd(v):
    return _base.gmath_isinfd(v)
gmath_isinfd = _base.gmath_isinfd

def gmath_isinfld(v):
    return _base.gmath_isinfld(v)
gmath_isinfld = _base.gmath_isinfld

def gmath_next_pow2(x):
    return _base.gmath_next_pow2(x)
gmath_next_pow2 = _base.gmath_next_pow2

def gmath_is_pow2(v):
    return _base.gmath_is_pow2(v)
gmath_is_pow2 = _base.gmath_is_pow2

def gmath_round(*args):
    return _base.gmath_round(*args)
gmath_round = _base.gmath_round

def gmath_mini(a, b):
    return _base.gmath_mini(a, b)
gmath_mini = _base.gmath_mini

def gmath_maxi(a, b):
    return _base.gmath_maxi(a, b)
gmath_maxi = _base.gmath_maxi

def gmath_modi(i, d):
    return _base.gmath_modi(i, d)
gmath_modi = _base.gmath_modi

def gmath_minui(a, b):
    return _base.gmath_minui(a, b)
gmath_minui = _base.gmath_minui

def gmath_maxui(a, b):
    return _base.gmath_maxui(a, b)
gmath_maxui = _base.gmath_maxui

def gmath_minf(a, b):
    return _base.gmath_minf(a, b)
gmath_minf = _base.gmath_minf

def gmath_maxf(a, b):
    return _base.gmath_maxf(a, b)
gmath_maxf = _base.gmath_maxf

def gmath_mind(a, b):
    return _base.gmath_mind(a, b)
gmath_mind = _base.gmath_mind

def gmath_maxd(a, b):
    return _base.gmath_maxd(a, b)
gmath_maxd = _base.gmath_maxd

def gmath_clampi(v, min, max):
    return _base.gmath_clampi(v, min, max)
gmath_clampi = _base.gmath_clampi

def gmath_clampf(v, min, max):
    return _base.gmath_clampf(v, min, max)
gmath_clampf = _base.gmath_clampf

def gmath_clampd(v, min, max):
    return _base.gmath_clampd(v, min, max)
gmath_clampd = _base.gmath_clampd

def gmath_lerpf(a, b, t):
    return _base.gmath_lerpf(a, b, t)
gmath_lerpf = _base.gmath_lerpf

def gmath_lerpd(a, b, t):
    return _base.gmath_lerpd(a, b, t)
gmath_lerpd = _base.gmath_lerpd

def gmath_smooth_stepf(a, b, x):
    return _base.gmath_smooth_stepf(a, b, x)
gmath_smooth_stepf = _base.gmath_smooth_stepf

def gmath_smooth_stepd(a, b, x):
    return _base.gmath_smooth_stepd(a, b, x)
gmath_smooth_stepd = _base.gmath_smooth_stepd

def gmath_lut_lerpf(lut_sample_count, value, span_index, span_weight):
    return _base.gmath_lut_lerpf(lut_sample_count, value, span_index, span_weight)
gmath_lut_lerpf = _base.gmath_lut_lerpf

def gmath_lut_lerpd(lut_sample_count, value, span_index, span_weight):
    return _base.gmath_lut_lerpd(lut_sample_count, value, span_index, span_weight)
gmath_lut_lerpd = _base.gmath_lut_lerpd

def gmath_epsilon_gt(*args):
    return _base.gmath_epsilon_gt(*args)
gmath_epsilon_gt = _base.gmath_epsilon_gt

def gmath_epsilon_lt(*args):
    return _base.gmath_epsilon_lt(*args)
gmath_epsilon_lt = _base.gmath_epsilon_lt

def gmath_epsilon_geq(*args):
    return _base.gmath_epsilon_geq(*args)
gmath_epsilon_geq = _base.gmath_epsilon_geq

def gmath_epsilon_leq(*args):
    return _base.gmath_epsilon_leq(*args)
gmath_epsilon_leq = _base.gmath_epsilon_leq

def gmath_div_ceili(x, y):
    return _base.gmath_div_ceili(x, y)
gmath_div_ceili = _base.gmath_div_ceili

def gmath_div_floori(x, y):
    return _base.gmath_div_floori(x, y)
gmath_div_floori = _base.gmath_div_floori

def gmath_div_roundi(x, y):
    return _base.gmath_div_roundi(x, y)
gmath_div_roundi = _base.gmath_div_roundi

def gmath_epsilon_eq(*args):
    return _base.gmath_epsilon_eq(*args)
gmath_epsilon_eq = _base.gmath_epsilon_eq

def gmath_epsilon_neq(*args):
    return _base.gmath_epsilon_neq(*args)
gmath_epsilon_neq = _base.gmath_epsilon_neq
class GMathQuat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathQuat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GMathQuat, name)

    def __init__(self, *args):
        this = _base.new_GMathQuat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        get_identity = staticmethod(_base.GMathQuat_get_identity)
    else:
        get_identity = _base.GMathQuat_get_identity

    def conjugate(self):
        return _base.GMathQuat_conjugate(self)

    def conjugated(self):
        return _base.GMathQuat_conjugated(self)

    def invert(self):
        return _base.GMathQuat_invert(self)

    def inverse(self):
        return _base.GMathQuat_inverse(self)

    def set_rotation(self, *args):
        return _base.GMathQuat_set_rotation(self, *args)

    def get_rotation(self, *args):
        return _base.GMathQuat_get_rotation(self, *args)

    def rotate(self, v):
        return _base.GMathQuat_rotate(self, v)

    def get_sqr_norm(self):
        return _base.GMathQuat_get_sqr_norm(self)

    def get_length(self):
        return _base.GMathQuat_get_length(self)

    def normalize(self):
        return _base.GMathQuat_normalize(self)

    def normalized(self):
        return _base.GMathQuat_normalized(self)

    def get_w(self):
        return _base.GMathQuat_get_w(self)

    def get_xyz(self):
        return _base.GMathQuat_get_xyz(self)

    def is_equal_to(self, *args):
        return _base.GMathQuat_is_equal_to(self, *args)

    def dot(self, q):
        return _base.GMathQuat_dot(self, q)

    def swing_twist_decomposition(self, direction, swing, twist):
        return _base.GMathQuat_swing_twist_decomposition(self, direction, swing, twist)

    def slerp(self, *args):
        return _base.GMathQuat_slerp(self, *args)

    def __add__(self, q):
        return _base.GMathQuat___add__(self, q)

    def __sub__(self, q):
        return _base.GMathQuat___sub__(self, q)

    def __neg__(self):
        return _base.GMathQuat___neg__(self)

    def __mul__(self, *args):
        return _base.GMathQuat___mul__(self, *args)

    def __imul__(self, d):
        return _base.GMathQuat___imul__(self, d)

    def __itruediv__(self, *args):
        return _base.GMathQuat___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __eq__(self, q):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathQuat___eq__(self, q)


    def __ne__(self, q):
        return _base.GMathQuat___ne__(self, q)

    def __repr__(self):
        return _base.GMathQuat___repr__(self)
    __swig_destroy__ = _base.delete_GMathQuat
    __del__ = lambda self: None
GMathQuat_swigregister = _base.GMathQuat_swigregister
GMathQuat_swigregister(GMathQuat)

def GMathQuat_get_identity():
    return _base.GMathQuat_get_identity()
GMathQuat_get_identity = _base.GMathQuat_get_identity


def core_get_hash(*args):
    return _base.core_get_hash(*args)
core_get_hash = _base.core_get_hash

def gmath_intersect_bbox2f(*args):
    return _base.gmath_intersect_bbox2f(*args)
gmath_intersect_bbox2f = _base.gmath_intersect_bbox2f
class GMathTimeSampling(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathTimeSampling, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathTimeSampling, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathTimeSampling(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def init(self, *args):
        return _base.GMathTimeSampling_init(self, *args)

    def clear(self):
        return _base.GMathTimeSampling_clear(self)

    def apply_offset(self, offset):
        return _base.GMathTimeSampling_apply_offset(self, offset)

    def copy_from(self, other, offset=0.0):
        return _base.GMathTimeSampling_copy_from(self, other, offset)

    def get_memory_size(self):
        return _base.GMathTimeSampling_get_memory_size(self)

    def is_uniform(self):
        return _base.GMathTimeSampling_is_uniform(self)

    def get_sample_spacing(self):
        return _base.GMathTimeSampling_get_sample_spacing(self)

    def get_sample_frequency(self):
        return _base.GMathTimeSampling_get_sample_frequency(self)

    def get_sample_count(self):
        return _base.GMathTimeSampling_get_sample_count(self)

    def get_sample_time(self, index):
        return _base.GMathTimeSampling_get_sample_time(self, index)

    def get_start_time(self):
        return _base.GMathTimeSampling_get_start_time(self)

    def get_end_time(self):
        return _base.GMathTimeSampling_get_end_time(self)

    def get_samples(self):
        return _base.GMathTimeSampling_get_samples(self)

    def get_span(self, time, span_index, span_t):
        return _base.GMathTimeSampling_get_span(self, time, span_index, span_t)

    def get_floor_sample(self, time):
        return _base.GMathTimeSampling_get_floor_sample(self, time)

    def get_nearest_sample(self, time):
        return _base.GMathTimeSampling_get_nearest_sample(self, time)

    def get_ceil_sample(self, time):
        return _base.GMathTimeSampling_get_ceil_sample(self, time)

    def get_serial_size(self):
        return _base.GMathTimeSampling_get_serial_size(self)

    def serialize(self, serial):
        return _base.GMathTimeSampling_serialize(self, serial)

    def deserialize(self, serial):
        return _base.GMathTimeSampling_deserialize(self, serial)
    if _newclass:
        class_info = staticmethod(_base.GMathTimeSampling_class_info)
    else:
        class_info = _base.GMathTimeSampling_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathTimeSampling____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathTimeSampling____class_destructor__

    def get_class_info(self):
        return _base.GMathTimeSampling_get_class_info(self)
    __swig_destroy__ = _base.delete_GMathTimeSampling
    __del__ = lambda self: None
GMathTimeSampling_swigregister = _base.GMathTimeSampling_swigregister
GMathTimeSampling_swigregister(GMathTimeSampling)

def GMathTimeSampling_class_info():
    return _base.GMathTimeSampling_class_info()
GMathTimeSampling_class_info = _base.GMathTimeSampling_class_info

def GMathTimeSampling____class_destructor__(instance, is_array):
    return _base.GMathTimeSampling____class_destructor__(instance, is_array)
GMathTimeSampling____class_destructor__ = _base.GMathTimeSampling____class_destructor__

class GMathHalfFloatConverter(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathHalfFloatConverter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GMathHalfFloatConverter, name)
    __repr__ = _swig_repr
    if _newclass:
        convert_half_to_float = staticmethod(_base.GMathHalfFloatConverter_convert_half_to_float)
    else:
        convert_half_to_float = _base.GMathHalfFloatConverter_convert_half_to_float
    if _newclass:
        convert_float_to_half = staticmethod(_base.GMathHalfFloatConverter_convert_float_to_half)
    else:
        convert_float_to_half = _base.GMathHalfFloatConverter_convert_float_to_half
    if _newclass:
        convert_normalized_half_to_float = staticmethod(_base.GMathHalfFloatConverter_convert_normalized_half_to_float)
    else:
        convert_normalized_half_to_float = _base.GMathHalfFloatConverter_convert_normalized_half_to_float
    if _newclass:
        convert_float_to_normalized_half = staticmethod(_base.GMathHalfFloatConverter_convert_float_to_normalized_half)
    else:
        convert_float_to_normalized_half = _base.GMathHalfFloatConverter_convert_float_to_normalized_half

    def __init__(self):
        this = _base.new_GMathHalfFloatConverter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathHalfFloatConverter
    __del__ = lambda self: None
GMathHalfFloatConverter_swigregister = _base.GMathHalfFloatConverter_swigregister
GMathHalfFloatConverter_swigregister(GMathHalfFloatConverter)

def GMathHalfFloatConverter_convert_half_to_float(h):
    return _base.GMathHalfFloatConverter_convert_half_to_float(h)
GMathHalfFloatConverter_convert_half_to_float = _base.GMathHalfFloatConverter_convert_half_to_float

def GMathHalfFloatConverter_convert_float_to_half(f):
    return _base.GMathHalfFloatConverter_convert_float_to_half(f)
GMathHalfFloatConverter_convert_float_to_half = _base.GMathHalfFloatConverter_convert_float_to_half

def GMathHalfFloatConverter_convert_normalized_half_to_float(n):
    return _base.GMathHalfFloatConverter_convert_normalized_half_to_float(n)
GMathHalfFloatConverter_convert_normalized_half_to_float = _base.GMathHalfFloatConverter_convert_normalized_half_to_float

def GMathHalfFloatConverter_convert_float_to_normalized_half(f):
    return _base.GMathHalfFloatConverter_convert_float_to_normalized_half(f)
GMathHalfFloatConverter_convert_float_to_normalized_half = _base.GMathHalfFloatConverter_convert_float_to_normalized_half

class GMathHalfFloat(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathHalfFloat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GMathHalfFloat, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathHalfFloat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __neg__(self):
        return _base.GMathHalfFloat___neg__(self)

    def __add__(self, h):
        return _base.GMathHalfFloat___add__(self, h)

    def __iadd__(self, *args):
        return _base.GMathHalfFloat___iadd__(self, *args)

    def __sub__(self, h):
        return _base.GMathHalfFloat___sub__(self, h)

    def __isub__(self, *args):
        return _base.GMathHalfFloat___isub__(self, *args)

    def __mul__(self, h):
        return _base.GMathHalfFloat___mul__(self, h)

    def __imul__(self, *args):
        return _base.GMathHalfFloat___imul__(self, *args)

    def __truediv__(self, *args):
        return _base.GMathHalfFloat___truediv__(self, *args)
    __div__ = __truediv__



    def __itruediv__(self, *args):
        return _base.GMathHalfFloat___itruediv__(self, *args)
    __idiv__ = __itruediv__


    __swig_destroy__ = _base.delete_GMathHalfFloat
    __del__ = lambda self: None
GMathHalfFloat_swigregister = _base.GMathHalfFloat_swigregister
GMathHalfFloat_swigregister(GMathHalfFloat)

class GMathHalfFloatNormalized(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathHalfFloatNormalized, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GMathHalfFloatNormalized, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathHalfFloatNormalized(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __neg__(self):
        return _base.GMathHalfFloatNormalized___neg__(self)

    def is_null(self):
        return _base.GMathHalfFloatNormalized_is_null(self)

    def __eq__(self, n):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathHalfFloatNormalized___eq__(self, n)


    def __ne__(self, n):
        return _base.GMathHalfFloatNormalized___ne__(self, n)
    __swig_destroy__ = _base.delete_GMathHalfFloatNormalized
    __del__ = lambda self: None
GMathHalfFloatNormalized_swigregister = _base.GMathHalfFloatNormalized_swigregister
GMathHalfFloatNormalized_swigregister(GMathHalfFloatNormalized)

class GMathQuatBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathQuatBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathQuatBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathQuatBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathQuatBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathQuatBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathQuatBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathQuatBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathQuatBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathQuatBasicArray_front(self)

    def back(self):
        return _base.GMathQuatBasicArray_back(self)

    def exists(self, item):
        return _base.GMathQuatBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathQuatBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathQuatBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathQuatBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathQuatBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathQuatBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathQuatBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathQuatBasicArray_class_info)
    else:
        class_info = _base.GMathQuatBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathQuatBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathQuatBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathQuatBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathQuatBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathQuatBasicArray_swigregister = _base.GMathQuatBasicArray_swigregister
GMathQuatBasicArray_swigregister(GMathQuatBasicArray)

def GMathQuatBasicArray_class_info():
    return _base.GMathQuatBasicArray_class_info()
GMathQuatBasicArray_class_info = _base.GMathQuatBasicArray_class_info

def GMathQuatBasicArray____class_destructor__(instance, is_array):
    return _base.GMathQuatBasicArray____class_destructor__(instance, is_array)
GMathQuatBasicArray____class_destructor__ = _base.GMathQuatBasicArray____class_destructor__

class GMathQuatArray(GMathQuatBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathQuatBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathQuatArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathQuatBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathQuatArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathQuatArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathQuatArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathQuatArray_append(self, *args)

    def get_count(self):
        return _base.GMathQuatArray_get_count(self)

    def remove_all(self):
        return _base.GMathQuatArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathQuatArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathQuatArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathQuatArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathQuatArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathQuatArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathQuatArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathQuatArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathQuatArray_class_info)
    else:
        class_info = _base.GMathQuatArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathQuatArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathQuatArray____class_destructor__
GMathQuatArray_swigregister = _base.GMathQuatArray_swigregister
GMathQuatArray_swigregister(GMathQuatArray)

def GMathQuatArray_class_info():
    return _base.GMathQuatArray_class_info()
GMathQuatArray_class_info = _base.GMathQuatArray_class_info

def GMathQuatArray____class_destructor__(instance, is_array):
    return _base.GMathQuatArray____class_destructor__(instance, is_array)
GMathQuatArray____class_destructor__ = _base.GMathQuatArray____class_destructor__

class GMathQuatVector(GMathQuatBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathQuatBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathQuatVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathQuatBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathQuatVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathQuatVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathQuatVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathQuatVector_append(self, *args)

    def add(self, element):
        return _base.GMathQuatVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathQuatVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathQuatVector_remove_last(self)

    def empty(self):
        return _base.GMathQuatVector_empty(self)

    def remove_all(self):
        return _base.GMathQuatVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathQuatVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathQuatVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathQuatVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathQuatVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathQuatVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathQuatVector_get_count(self)

    def get_capacity(self):
        return _base.GMathQuatVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathQuatVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathQuatVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathQuatVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathQuatVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathQuatVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathQuatVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathQuatVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathQuatVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathQuatVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathQuatVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathQuatVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathQuatVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathQuatVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathQuatVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathQuatVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathQuatVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathQuatVector_class_info)
    else:
        class_info = _base.GMathQuatVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathQuatVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathQuatVector____class_destructor__
GMathQuatVector_swigregister = _base.GMathQuatVector_swigregister
GMathQuatVector_swigregister(GMathQuatVector)

def GMathQuatVector_class_info():
    return _base.GMathQuatVector_class_info()
GMathQuatVector_class_info = _base.GMathQuatVector_class_info

def GMathQuatVector____class_destructor__(instance, is_array):
    return _base.GMathQuatVector____class_destructor__(instance, is_array)
GMathQuatVector____class_destructor__ = _base.GMathQuatVector____class_destructor__

class GMathQuatSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathQuatSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathQuatSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathQuatSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathQuatSet_get_count(self)

    def exists(self, *args):
        return _base.GMathQuatSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathQuatSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathQuatSet_is_included(self, set)

    def get_items(self):
        return _base.GMathQuatSet_get_items(self)

    def get_item(self, index):
        return _base.GMathQuatSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathQuatSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathQuatSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathQuatSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathQuatSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathQuatSet_to_array(self)

    def add(self, *args):
        return _base.GMathQuatSet_add(self, *args)

    def remove(self, index):
        return _base.GMathQuatSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathQuatSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathQuatSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathQuatSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathQuatSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathQuatSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathQuatSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathQuatSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathQuatSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathQuatSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathQuatSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathQuatSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathQuatSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathQuatSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathQuatSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathQuatSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathQuatSet
    __del__ = lambda self: None
GMathQuatSet_swigregister = _base.GMathQuatSet_swigregister
GMathQuatSet_swigregister(GMathQuatSet)

def GMathQuatSet_get_linear_search_threshold():
    return _base.GMathQuatSet_get_linear_search_threshold()
GMathQuatSet_get_linear_search_threshold = _base.GMathQuatSet_get_linear_search_threshold

class GMathVec2uc(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2uc, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2uc, name)

    def __init__(self, *args):
        this = _base.new_GMathVec2uc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec2uc_nullify(self)

    def get_value(self, index):
        return _base.GMathVec2uc_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec2uc_set_value(self, index, value)

    def get_width(self):
        return _base.GMathVec2uc_get_width(self)

    def set_width(self, width):
        return _base.GMathVec2uc_set_width(self, width)

    def get_height(self):
        return _base.GMathVec2uc_get_height(self)

    def set_height(self, height):
        return _base.GMathVec2uc_set_height(self, height)

    def get_x(self):
        return _base.GMathVec2uc_get_x(self)

    def set_x(self, x):
        return _base.GMathVec2uc_set_x(self, x)

    def get_y(self):
        return _base.GMathVec2uc_get_y(self)

    def set_y(self, y):
        return _base.GMathVec2uc_set_y(self, y)

    def get_red(self):
        return _base.GMathVec2uc_get_red(self)

    def get_u(self):
        return _base.GMathVec2uc_get_u(self)

    def set_u(self, u):
        return _base.GMathVec2uc_set_u(self, u)

    def get_v(self):
        return _base.GMathVec2uc_get_v(self)

    def set_v(self, v):
        return _base.GMathVec2uc_set_v(self, v)

    def sub(self, *args):
        return _base.GMathVec2uc_sub(self, *args)

    def absolute(self):
        return _base.GMathVec2uc_absolute(self)

    def get_sqr_length(self):
        return _base.GMathVec2uc_get_sqr_length(self)

    def get_length(self):
        return _base.GMathVec2uc_get_length(self)

    def get_max_norm_signed(self):
        return _base.GMathVec2uc_get_max_norm_signed(self)

    def get_max_norm(self):
        return _base.GMathVec2uc_get_max_norm(self)

    def normalize(self, *args):
        return _base.GMathVec2uc_normalize(self, *args)

    def get_copy(self):
        return _base.GMathVec2uc_get_copy(self)

    def copy_from(self, v):
        return _base.GMathVec2uc_copy_from(self, v)

    def copy_to(self, v):
        return _base.GMathVec2uc_copy_to(self, v)

    def is_null(self, *args):
        return _base.GMathVec2uc_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec2uc_is_finite(self)

    def __eq__(self, v):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2uc___eq__(self, v)


    def __ne__(self, v):
        return _base.GMathVec2uc___ne__(self, v)

    def __iadd__(self, *args):
        return _base.GMathVec2uc___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec2uc___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec2uc___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec2uc___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec2uc___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec2uc___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec2uc___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec2uc___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec2uc___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec2uc_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2uc_class_info)
    else:
        class_info = _base.GMathVec2uc_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec2uc_register_methods)
    else:
        register_methods = _base.GMathVec2uc_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2uc____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2uc____class_destructor__

    def __repr__(self):
        return _base.GMathVec2uc___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2uc___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec2uc___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec2uc___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2uc
    __del__ = lambda self: None
GMathVec2uc_swigregister = _base.GMathVec2uc_swigregister
GMathVec2uc_swigregister(GMathVec2uc)

def GMathVec2uc_class_info():
    return _base.GMathVec2uc_class_info()
GMathVec2uc_class_info = _base.GMathVec2uc_class_info

def GMathVec2uc_register_methods(arg2):
    return _base.GMathVec2uc_register_methods(arg2)
GMathVec2uc_register_methods = _base.GMathVec2uc_register_methods

def GMathVec2uc____class_destructor__(instance, is_array):
    return _base.GMathVec2uc____class_destructor__(instance, is_array)
GMathVec2uc____class_destructor__ = _base.GMathVec2uc____class_destructor__

class GMathVec3uc(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3uc, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3uc, name)
    if _newclass:
        create_local_axis = staticmethod(_base.GMathVec3uc_create_local_axis)
    else:
        create_local_axis = _base.GMathVec3uc_create_local_axis

    def __init__(self, *args):
        this = _base.new_GMathVec3uc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec3uc_nullify(self)

    def get_copy(self):
        return _base.GMathVec3uc_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec3uc_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec3uc_copy_to(self, u)

    def __ne__(self, *args):
        return _base.GMathVec3uc___ne__(self, *args)

    def __eq__(self, *args):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3uc___eq__(self, *args)


    def __lt__(self, *args):
        return _base.GMathVec3uc___lt__(self, *args)

    def __gt__(self, *args):
        return _base.GMathVec3uc___gt__(self, *args)

    def __le__(self, *args):
        return _base.GMathVec3uc___le__(self, *args)

    def __ge__(self, *args):
        return _base.GMathVec3uc___ge__(self, *args)

    def absolute(self):
        return _base.GMathVec3uc_absolute(self)

    def get_sqr_norm(self, *args):
        return _base.GMathVec3uc_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec3uc_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec3uc_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec3uc_get_length(self, *args)

    def get_l1_norm_signed(self, *args):
        return _base.GMathVec3uc_get_l1_norm_signed(self, *args)

    def get_l1_norm(self, *args):
        return _base.GMathVec3uc_get_l1_norm(self, *args)

    def get_max_norm_signed(self, *args):
        return _base.GMathVec3uc_get_max_norm_signed(self, *args)

    def get_max_norm(self, *args):
        return _base.GMathVec3uc_get_max_norm(self, *args)

    def get_min_norm_signed(self, *args):
        return _base.GMathVec3uc_get_min_norm_signed(self, *args)

    def get_min_norm(self, *args):
        return _base.GMathVec3uc_get_min_norm(self, *args)

    def scale(self, s):
        return _base.GMathVec3uc_scale(self, s)

    def get_main_axis(self):
        return _base.GMathVec3uc_get_main_axis(self)

    def normalize(self, *args):
        return _base.GMathVec3uc_normalize(self, *args)

    def is_null(self, *args):
        return _base.GMathVec3uc_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec3uc_is_finite(self)

    def get_data(self, *args):
        return _base.GMathVec3uc_get_data(self, *args)

    def __iadd__(self, *args):
        return _base.GMathVec3uc___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec3uc___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec3uc___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec3uc___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec3uc___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec3uc___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec3uc___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec3uc___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec3uc___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec3uc_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3uc_class_info)
    else:
        class_info = _base.GMathVec3uc_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec3uc_register_methods)
    else:
        register_methods = _base.GMathVec3uc_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3uc____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3uc____class_destructor__

    def __repr__(self):
        return _base.GMathVec3uc___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3uc___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec3uc___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec3uc___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3uc
    __del__ = lambda self: None
GMathVec3uc_swigregister = _base.GMathVec3uc_swigregister
GMathVec3uc_swigregister(GMathVec3uc)

def GMathVec3uc_create_local_axis(v1, v2, v3):
    return _base.GMathVec3uc_create_local_axis(v1, v2, v3)
GMathVec3uc_create_local_axis = _base.GMathVec3uc_create_local_axis

def GMathVec3uc_class_info():
    return _base.GMathVec3uc_class_info()
GMathVec3uc_class_info = _base.GMathVec3uc_class_info

def GMathVec3uc_register_methods(cls):
    return _base.GMathVec3uc_register_methods(cls)
GMathVec3uc_register_methods = _base.GMathVec3uc_register_methods

def GMathVec3uc____class_destructor__(instance, is_array):
    return _base.GMathVec3uc____class_destructor__(instance, is_array)
GMathVec3uc____class_destructor__ = _base.GMathVec3uc____class_destructor__

class GMathVec4uc(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4uc, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4uc, name)

    def __init__(self, *args):
        this = _base.new_GMathVec4uc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec4uc_nullify(self)

    def get_copy(self):
        return _base.GMathVec4uc_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec4uc_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec4uc_copy_to(self, u)

    def get_value(self, index):
        return _base.GMathVec4uc_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec4uc_set_value(self, index, value)

    def get_x(self):
        return _base.GMathVec4uc_get_x(self)

    def set_x(self, x):
        return _base.GMathVec4uc_set_x(self, x)

    def get_y(self):
        return _base.GMathVec4uc_get_y(self)

    def set_y(self, y):
        return _base.GMathVec4uc_set_y(self, y)

    def get_z(self):
        return _base.GMathVec4uc_get_z(self)

    def set_z(self, z):
        return _base.GMathVec4uc_set_z(self, z)

    def get_w(self):
        return _base.GMathVec4uc_get_w(self)

    def set_w(self, w):
        return _base.GMathVec4uc_set_w(self, w)

    def get_red(self):
        return _base.GMathVec4uc_get_red(self)

    def set_red(self, red):
        return _base.GMathVec4uc_set_red(self, red)

    def get_green(self):
        return _base.GMathVec4uc_get_green(self)

    def set_green(self, green):
        return _base.GMathVec4uc_set_green(self, green)

    def get_blue(self):
        return _base.GMathVec4uc_get_blue(self)

    def set_blue(self, blue):
        return _base.GMathVec4uc_set_blue(self, blue)

    def get_alpha(self):
        return _base.GMathVec4uc_get_alpha(self)

    def set_alpha(self, alpha):
        return _base.GMathVec4uc_set_alpha(self, alpha)

    def get_sqr_norm(self, *args):
        return _base.GMathVec4uc_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec4uc_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec4uc_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec4uc_get_length(self, *args)

    def sub(self, *args):
        return _base.GMathVec4uc_sub(self, *args)

    def get_data(self, *args):
        return _base.GMathVec4uc_get_data(self, *args)

    def is_null(self, *args):
        return _base.GMathVec4uc_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec4uc_is_finite(self)

    def __iadd__(self, *args):
        return _base.GMathVec4uc___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec4uc___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec4uc___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec4uc___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec4uc___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec4uc___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec4uc___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec4uc___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec4uc___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec4uc_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4uc_class_info)
    else:
        class_info = _base.GMathVec4uc_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec4uc_register_methods)
    else:
        register_methods = _base.GMathVec4uc_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4uc____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4uc____class_destructor__

    def __repr__(self):
        return _base.GMathVec4uc___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4uc___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec4uc___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec4uc___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4uc
    __del__ = lambda self: None
GMathVec4uc_swigregister = _base.GMathVec4uc_swigregister
GMathVec4uc_swigregister(GMathVec4uc)

def GMathVec4uc_class_info():
    return _base.GMathVec4uc_class_info()
GMathVec4uc_class_info = _base.GMathVec4uc_class_info

def GMathVec4uc_register_methods(cls):
    return _base.GMathVec4uc_register_methods(cls)
GMathVec4uc_register_methods = _base.GMathVec4uc_register_methods

def GMathVec4uc____class_destructor__(instance, is_array):
    return _base.GMathVec4uc____class_destructor__(instance, is_array)
GMathVec4uc____class_destructor__ = _base.GMathVec4uc____class_destructor__

class GMathVec2ucBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2ucBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2ucBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec2ucBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec2ucBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2ucBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec2ucBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec2ucBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec2ucBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec2ucBasicArray_front(self)

    def back(self):
        return _base.GMathVec2ucBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec2ucBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec2ucBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec2ucBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec2ucBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec2ucBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2ucBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec2ucBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2ucBasicArray_class_info)
    else:
        class_info = _base.GMathVec2ucBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2ucBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2ucBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec2ucBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2ucBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec2ucBasicArray_swigregister = _base.GMathVec2ucBasicArray_swigregister
GMathVec2ucBasicArray_swigregister(GMathVec2ucBasicArray)

def GMathVec2ucBasicArray_class_info():
    return _base.GMathVec2ucBasicArray_class_info()
GMathVec2ucBasicArray_class_info = _base.GMathVec2ucBasicArray_class_info

def GMathVec2ucBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec2ucBasicArray____class_destructor__(instance, is_array)
GMathVec2ucBasicArray____class_destructor__ = _base.GMathVec2ucBasicArray____class_destructor__

class GMathVec2ucArray(GMathVec2ucBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2ucBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2ucArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2ucBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2ucArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2ucArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2ucArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2ucArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec2ucArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec2ucArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec2ucArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2ucArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2ucArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2ucArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2ucArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec2ucArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2ucArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2ucArray_class_info)
    else:
        class_info = _base.GMathVec2ucArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2ucArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2ucArray____class_destructor__
GMathVec2ucArray_swigregister = _base.GMathVec2ucArray_swigregister
GMathVec2ucArray_swigregister(GMathVec2ucArray)

def GMathVec2ucArray_class_info():
    return _base.GMathVec2ucArray_class_info()
GMathVec2ucArray_class_info = _base.GMathVec2ucArray_class_info

def GMathVec2ucArray____class_destructor__(instance, is_array):
    return _base.GMathVec2ucArray____class_destructor__(instance, is_array)
GMathVec2ucArray____class_destructor__ = _base.GMathVec2ucArray____class_destructor__

class GMathVec2ucVector(GMathVec2ucBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2ucBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2ucVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2ucBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2ucVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2ucVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2ucVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2ucVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec2ucVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec2ucVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec2ucVector_remove_last(self)

    def empty(self):
        return _base.GMathVec2ucVector_empty(self)

    def remove_all(self):
        return _base.GMathVec2ucVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec2ucVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec2ucVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec2ucVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec2ucVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec2ucVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec2ucVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec2ucVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec2ucVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec2ucVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec2ucVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec2ucVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec2ucVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec2ucVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2ucVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2ucVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2ucVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2ucVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec2ucVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec2ucVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec2ucVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec2ucVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec2ucVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2ucVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2ucVector_class_info)
    else:
        class_info = _base.GMathVec2ucVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2ucVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2ucVector____class_destructor__
GMathVec2ucVector_swigregister = _base.GMathVec2ucVector_swigregister
GMathVec2ucVector_swigregister(GMathVec2ucVector)

def GMathVec2ucVector_class_info():
    return _base.GMathVec2ucVector_class_info()
GMathVec2ucVector_class_info = _base.GMathVec2ucVector_class_info

def GMathVec2ucVector____class_destructor__(instance, is_array):
    return _base.GMathVec2ucVector____class_destructor__(instance, is_array)
GMathVec2ucVector____class_destructor__ = _base.GMathVec2ucVector____class_destructor__

class GMathVec2ucSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2ucSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2ucSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2ucSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec2ucSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec2ucSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec2ucSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec2ucSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec2ucSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec2ucSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec2ucSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec2ucSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec2ucSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec2ucSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec2ucSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec2ucSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec2ucSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec2ucSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec2ucSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec2ucSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec2ucSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec2ucSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec2ucSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2ucSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec2ucSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec2ucSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2ucSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec2ucSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec2ucSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec2ucSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2ucSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2ucSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2ucSet
    __del__ = lambda self: None
GMathVec2ucSet_swigregister = _base.GMathVec2ucSet_swigregister
GMathVec2ucSet_swigregister(GMathVec2ucSet)

def GMathVec2ucSet_get_linear_search_threshold():
    return _base.GMathVec2ucSet_get_linear_search_threshold()
GMathVec2ucSet_get_linear_search_threshold = _base.GMathVec2ucSet_get_linear_search_threshold

class GMathVec3ucBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3ucBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3ucBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec3ucBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec3ucBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3ucBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec3ucBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec3ucBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec3ucBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec3ucBasicArray_front(self)

    def back(self):
        return _base.GMathVec3ucBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec3ucBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec3ucBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec3ucBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec3ucBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec3ucBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3ucBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec3ucBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3ucBasicArray_class_info)
    else:
        class_info = _base.GMathVec3ucBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3ucBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3ucBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec3ucBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3ucBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec3ucBasicArray_swigregister = _base.GMathVec3ucBasicArray_swigregister
GMathVec3ucBasicArray_swigregister(GMathVec3ucBasicArray)

def GMathVec3ucBasicArray_class_info():
    return _base.GMathVec3ucBasicArray_class_info()
GMathVec3ucBasicArray_class_info = _base.GMathVec3ucBasicArray_class_info

def GMathVec3ucBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec3ucBasicArray____class_destructor__(instance, is_array)
GMathVec3ucBasicArray____class_destructor__ = _base.GMathVec3ucBasicArray____class_destructor__

class GMathVec3ucArray(GMathVec3ucBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3ucBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3ucArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3ucBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3ucArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3ucArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3ucArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3ucArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec3ucArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec3ucArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec3ucArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3ucArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3ucArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3ucArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3ucArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec3ucArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3ucArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3ucArray_class_info)
    else:
        class_info = _base.GMathVec3ucArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3ucArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3ucArray____class_destructor__
GMathVec3ucArray_swigregister = _base.GMathVec3ucArray_swigregister
GMathVec3ucArray_swigregister(GMathVec3ucArray)

def GMathVec3ucArray_class_info():
    return _base.GMathVec3ucArray_class_info()
GMathVec3ucArray_class_info = _base.GMathVec3ucArray_class_info

def GMathVec3ucArray____class_destructor__(instance, is_array):
    return _base.GMathVec3ucArray____class_destructor__(instance, is_array)
GMathVec3ucArray____class_destructor__ = _base.GMathVec3ucArray____class_destructor__

class GMathVec3ucVector(GMathVec3ucBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3ucBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3ucVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3ucBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3ucVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3ucVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3ucVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3ucVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec3ucVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec3ucVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec3ucVector_remove_last(self)

    def empty(self):
        return _base.GMathVec3ucVector_empty(self)

    def remove_all(self):
        return _base.GMathVec3ucVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec3ucVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec3ucVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec3ucVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec3ucVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec3ucVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec3ucVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec3ucVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec3ucVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec3ucVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec3ucVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec3ucVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec3ucVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec3ucVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3ucVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3ucVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3ucVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3ucVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec3ucVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec3ucVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec3ucVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec3ucVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec3ucVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3ucVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3ucVector_class_info)
    else:
        class_info = _base.GMathVec3ucVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3ucVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3ucVector____class_destructor__
GMathVec3ucVector_swigregister = _base.GMathVec3ucVector_swigregister
GMathVec3ucVector_swigregister(GMathVec3ucVector)

def GMathVec3ucVector_class_info():
    return _base.GMathVec3ucVector_class_info()
GMathVec3ucVector_class_info = _base.GMathVec3ucVector_class_info

def GMathVec3ucVector____class_destructor__(instance, is_array):
    return _base.GMathVec3ucVector____class_destructor__(instance, is_array)
GMathVec3ucVector____class_destructor__ = _base.GMathVec3ucVector____class_destructor__

class GMathVec3ucSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3ucSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3ucSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3ucSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec3ucSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec3ucSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec3ucSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec3ucSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec3ucSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec3ucSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec3ucSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec3ucSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec3ucSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec3ucSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec3ucSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec3ucSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec3ucSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec3ucSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec3ucSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec3ucSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec3ucSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec3ucSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec3ucSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3ucSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec3ucSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec3ucSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3ucSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec3ucSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec3ucSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec3ucSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3ucSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3ucSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3ucSet
    __del__ = lambda self: None
GMathVec3ucSet_swigregister = _base.GMathVec3ucSet_swigregister
GMathVec3ucSet_swigregister(GMathVec3ucSet)

def GMathVec3ucSet_get_linear_search_threshold():
    return _base.GMathVec3ucSet_get_linear_search_threshold()
GMathVec3ucSet_get_linear_search_threshold = _base.GMathVec3ucSet_get_linear_search_threshold

class GMathVec4ucBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4ucBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4ucBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec4ucBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec4ucBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4ucBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec4ucBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec4ucBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec4ucBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec4ucBasicArray_front(self)

    def back(self):
        return _base.GMathVec4ucBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec4ucBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec4ucBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec4ucBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec4ucBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec4ucBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4ucBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec4ucBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4ucBasicArray_class_info)
    else:
        class_info = _base.GMathVec4ucBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4ucBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4ucBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec4ucBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4ucBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec4ucBasicArray_swigregister = _base.GMathVec4ucBasicArray_swigregister
GMathVec4ucBasicArray_swigregister(GMathVec4ucBasicArray)

def GMathVec4ucBasicArray_class_info():
    return _base.GMathVec4ucBasicArray_class_info()
GMathVec4ucBasicArray_class_info = _base.GMathVec4ucBasicArray_class_info

def GMathVec4ucBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec4ucBasicArray____class_destructor__(instance, is_array)
GMathVec4ucBasicArray____class_destructor__ = _base.GMathVec4ucBasicArray____class_destructor__

class GMathVec4ucArray(GMathVec4ucBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4ucBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4ucArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4ucBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4ucArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4ucArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4ucArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4ucArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec4ucArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec4ucArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec4ucArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4ucArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4ucArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4ucArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4ucArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec4ucArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4ucArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4ucArray_class_info)
    else:
        class_info = _base.GMathVec4ucArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4ucArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4ucArray____class_destructor__
GMathVec4ucArray_swigregister = _base.GMathVec4ucArray_swigregister
GMathVec4ucArray_swigregister(GMathVec4ucArray)

def GMathVec4ucArray_class_info():
    return _base.GMathVec4ucArray_class_info()
GMathVec4ucArray_class_info = _base.GMathVec4ucArray_class_info

def GMathVec4ucArray____class_destructor__(instance, is_array):
    return _base.GMathVec4ucArray____class_destructor__(instance, is_array)
GMathVec4ucArray____class_destructor__ = _base.GMathVec4ucArray____class_destructor__

class GMathVec4ucVector(GMathVec4ucBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4ucBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4ucVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4ucBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4ucVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4ucVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4ucVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4ucVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec4ucVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec4ucVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec4ucVector_remove_last(self)

    def empty(self):
        return _base.GMathVec4ucVector_empty(self)

    def remove_all(self):
        return _base.GMathVec4ucVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec4ucVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec4ucVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec4ucVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec4ucVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec4ucVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec4ucVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec4ucVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec4ucVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec4ucVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec4ucVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec4ucVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec4ucVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec4ucVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4ucVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4ucVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4ucVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4ucVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec4ucVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec4ucVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec4ucVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec4ucVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec4ucVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4ucVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4ucVector_class_info)
    else:
        class_info = _base.GMathVec4ucVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4ucVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4ucVector____class_destructor__
GMathVec4ucVector_swigregister = _base.GMathVec4ucVector_swigregister
GMathVec4ucVector_swigregister(GMathVec4ucVector)

def GMathVec4ucVector_class_info():
    return _base.GMathVec4ucVector_class_info()
GMathVec4ucVector_class_info = _base.GMathVec4ucVector_class_info

def GMathVec4ucVector____class_destructor__(instance, is_array):
    return _base.GMathVec4ucVector____class_destructor__(instance, is_array)
GMathVec4ucVector____class_destructor__ = _base.GMathVec4ucVector____class_destructor__

class GMathVec4ucSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4ucSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4ucSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4ucSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec4ucSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec4ucSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec4ucSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec4ucSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec4ucSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec4ucSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec4ucSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec4ucSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec4ucSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec4ucSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec4ucSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec4ucSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec4ucSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec4ucSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec4ucSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec4ucSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec4ucSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec4ucSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec4ucSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec4ucSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec4ucSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec4ucSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4ucSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec4ucSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec4ucSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec4ucSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4ucSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4ucSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4ucSet
    __del__ = lambda self: None
GMathVec4ucSet_swigregister = _base.GMathVec4ucSet_swigregister
GMathVec4ucSet_swigregister(GMathVec4ucSet)

def GMathVec4ucSet_get_linear_search_threshold():
    return _base.GMathVec4ucSet_get_linear_search_threshold()
GMathVec4ucSet_get_linear_search_threshold = _base.GMathVec4ucSet_get_linear_search_threshold

class GMathVec2i(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2i, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2i, name)

    def __init__(self, *args):
        this = _base.new_GMathVec2i(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec2i_nullify(self)

    def get_value(self, index):
        return _base.GMathVec2i_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec2i_set_value(self, index, value)

    def get_width(self):
        return _base.GMathVec2i_get_width(self)

    def set_width(self, width):
        return _base.GMathVec2i_set_width(self, width)

    def get_height(self):
        return _base.GMathVec2i_get_height(self)

    def set_height(self, height):
        return _base.GMathVec2i_set_height(self, height)

    def get_x(self):
        return _base.GMathVec2i_get_x(self)

    def set_x(self, x):
        return _base.GMathVec2i_set_x(self, x)

    def get_y(self):
        return _base.GMathVec2i_get_y(self)

    def set_y(self, y):
        return _base.GMathVec2i_set_y(self, y)

    def get_red(self):
        return _base.GMathVec2i_get_red(self)

    def get_u(self):
        return _base.GMathVec2i_get_u(self)

    def set_u(self, u):
        return _base.GMathVec2i_set_u(self, u)

    def get_v(self):
        return _base.GMathVec2i_get_v(self)

    def set_v(self, v):
        return _base.GMathVec2i_set_v(self, v)

    def sub(self, *args):
        return _base.GMathVec2i_sub(self, *args)

    def absolute(self):
        return _base.GMathVec2i_absolute(self)

    def get_sqr_length(self):
        return _base.GMathVec2i_get_sqr_length(self)

    def get_length(self):
        return _base.GMathVec2i_get_length(self)

    def get_max_norm_signed(self):
        return _base.GMathVec2i_get_max_norm_signed(self)

    def get_max_norm(self):
        return _base.GMathVec2i_get_max_norm(self)

    def normalize(self, *args):
        return _base.GMathVec2i_normalize(self, *args)

    def get_copy(self):
        return _base.GMathVec2i_get_copy(self)

    def copy_from(self, v):
        return _base.GMathVec2i_copy_from(self, v)

    def copy_to(self, v):
        return _base.GMathVec2i_copy_to(self, v)

    def is_null(self, *args):
        return _base.GMathVec2i_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec2i_is_finite(self)

    def __eq__(self, v):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2i___eq__(self, v)


    def __ne__(self, v):
        return _base.GMathVec2i___ne__(self, v)

    def __iadd__(self, *args):
        return _base.GMathVec2i___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec2i___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec2i___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec2i___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec2i___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec2i___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec2i___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec2i___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec2i___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec2i_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2i_class_info)
    else:
        class_info = _base.GMathVec2i_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec2i_register_methods)
    else:
        register_methods = _base.GMathVec2i_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2i____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2i____class_destructor__

    def __repr__(self):
        return _base.GMathVec2i___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2i___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec2i___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec2i___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2i
    __del__ = lambda self: None
GMathVec2i_swigregister = _base.GMathVec2i_swigregister
GMathVec2i_swigregister(GMathVec2i)

def GMathVec2i_class_info():
    return _base.GMathVec2i_class_info()
GMathVec2i_class_info = _base.GMathVec2i_class_info

def GMathVec2i_register_methods(arg2):
    return _base.GMathVec2i_register_methods(arg2)
GMathVec2i_register_methods = _base.GMathVec2i_register_methods

def GMathVec2i____class_destructor__(instance, is_array):
    return _base.GMathVec2i____class_destructor__(instance, is_array)
GMathVec2i____class_destructor__ = _base.GMathVec2i____class_destructor__

class GMathVec3i(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3i, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3i, name)
    if _newclass:
        create_local_axis = staticmethod(_base.GMathVec3i_create_local_axis)
    else:
        create_local_axis = _base.GMathVec3i_create_local_axis

    def __init__(self, *args):
        this = _base.new_GMathVec3i(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec3i_nullify(self)

    def get_copy(self):
        return _base.GMathVec3i_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec3i_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec3i_copy_to(self, u)

    def __ne__(self, *args):
        return _base.GMathVec3i___ne__(self, *args)

    def __eq__(self, *args):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3i___eq__(self, *args)


    def __lt__(self, *args):
        return _base.GMathVec3i___lt__(self, *args)

    def __gt__(self, *args):
        return _base.GMathVec3i___gt__(self, *args)

    def __le__(self, *args):
        return _base.GMathVec3i___le__(self, *args)

    def __ge__(self, *args):
        return _base.GMathVec3i___ge__(self, *args)

    def absolute(self):
        return _base.GMathVec3i_absolute(self)

    def get_sqr_norm(self, *args):
        return _base.GMathVec3i_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec3i_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec3i_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec3i_get_length(self, *args)

    def get_l1_norm_signed(self, *args):
        return _base.GMathVec3i_get_l1_norm_signed(self, *args)

    def get_l1_norm(self, *args):
        return _base.GMathVec3i_get_l1_norm(self, *args)

    def get_max_norm_signed(self, *args):
        return _base.GMathVec3i_get_max_norm_signed(self, *args)

    def get_max_norm(self, *args):
        return _base.GMathVec3i_get_max_norm(self, *args)

    def get_min_norm_signed(self, *args):
        return _base.GMathVec3i_get_min_norm_signed(self, *args)

    def get_min_norm(self, *args):
        return _base.GMathVec3i_get_min_norm(self, *args)

    def scale(self, s):
        return _base.GMathVec3i_scale(self, s)

    def get_main_axis(self):
        return _base.GMathVec3i_get_main_axis(self)

    def normalize(self, *args):
        return _base.GMathVec3i_normalize(self, *args)

    def is_null(self, *args):
        return _base.GMathVec3i_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec3i_is_finite(self)

    def get_data(self, *args):
        return _base.GMathVec3i_get_data(self, *args)

    def __iadd__(self, *args):
        return _base.GMathVec3i___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec3i___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec3i___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec3i___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec3i___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec3i___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec3i___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec3i___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec3i___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec3i_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3i_class_info)
    else:
        class_info = _base.GMathVec3i_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec3i_register_methods)
    else:
        register_methods = _base.GMathVec3i_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3i____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3i____class_destructor__

    def __repr__(self):
        return _base.GMathVec3i___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3i___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec3i___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec3i___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3i
    __del__ = lambda self: None
GMathVec3i_swigregister = _base.GMathVec3i_swigregister
GMathVec3i_swigregister(GMathVec3i)

def GMathVec3i_create_local_axis(v1, v2, v3):
    return _base.GMathVec3i_create_local_axis(v1, v2, v3)
GMathVec3i_create_local_axis = _base.GMathVec3i_create_local_axis

def GMathVec3i_class_info():
    return _base.GMathVec3i_class_info()
GMathVec3i_class_info = _base.GMathVec3i_class_info

def GMathVec3i_register_methods(cls):
    return _base.GMathVec3i_register_methods(cls)
GMathVec3i_register_methods = _base.GMathVec3i_register_methods

def GMathVec3i____class_destructor__(instance, is_array):
    return _base.GMathVec3i____class_destructor__(instance, is_array)
GMathVec3i____class_destructor__ = _base.GMathVec3i____class_destructor__

class GMathVec4i(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4i, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4i, name)

    def __init__(self, *args):
        this = _base.new_GMathVec4i(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec4i_nullify(self)

    def get_copy(self):
        return _base.GMathVec4i_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec4i_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec4i_copy_to(self, u)

    def get_value(self, index):
        return _base.GMathVec4i_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec4i_set_value(self, index, value)

    def get_x(self):
        return _base.GMathVec4i_get_x(self)

    def set_x(self, x):
        return _base.GMathVec4i_set_x(self, x)

    def get_y(self):
        return _base.GMathVec4i_get_y(self)

    def set_y(self, y):
        return _base.GMathVec4i_set_y(self, y)

    def get_z(self):
        return _base.GMathVec4i_get_z(self)

    def set_z(self, z):
        return _base.GMathVec4i_set_z(self, z)

    def get_w(self):
        return _base.GMathVec4i_get_w(self)

    def set_w(self, w):
        return _base.GMathVec4i_set_w(self, w)

    def get_red(self):
        return _base.GMathVec4i_get_red(self)

    def set_red(self, red):
        return _base.GMathVec4i_set_red(self, red)

    def get_green(self):
        return _base.GMathVec4i_get_green(self)

    def set_green(self, green):
        return _base.GMathVec4i_set_green(self, green)

    def get_blue(self):
        return _base.GMathVec4i_get_blue(self)

    def set_blue(self, blue):
        return _base.GMathVec4i_set_blue(self, blue)

    def get_alpha(self):
        return _base.GMathVec4i_get_alpha(self)

    def set_alpha(self, alpha):
        return _base.GMathVec4i_set_alpha(self, alpha)

    def get_sqr_norm(self, *args):
        return _base.GMathVec4i_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec4i_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec4i_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec4i_get_length(self, *args)

    def sub(self, *args):
        return _base.GMathVec4i_sub(self, *args)

    def get_data(self, *args):
        return _base.GMathVec4i_get_data(self, *args)

    def is_null(self, *args):
        return _base.GMathVec4i_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec4i_is_finite(self)

    def __iadd__(self, *args):
        return _base.GMathVec4i___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec4i___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec4i___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec4i___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec4i___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec4i___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec4i___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec4i___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec4i___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec4i_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4i_class_info)
    else:
        class_info = _base.GMathVec4i_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec4i_register_methods)
    else:
        register_methods = _base.GMathVec4i_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4i____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4i____class_destructor__

    def __repr__(self):
        return _base.GMathVec4i___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4i___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec4i___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec4i___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4i
    __del__ = lambda self: None
GMathVec4i_swigregister = _base.GMathVec4i_swigregister
GMathVec4i_swigregister(GMathVec4i)

def GMathVec4i_class_info():
    return _base.GMathVec4i_class_info()
GMathVec4i_class_info = _base.GMathVec4i_class_info

def GMathVec4i_register_methods(cls):
    return _base.GMathVec4i_register_methods(cls)
GMathVec4i_register_methods = _base.GMathVec4i_register_methods

def GMathVec4i____class_destructor__(instance, is_array):
    return _base.GMathVec4i____class_destructor__(instance, is_array)
GMathVec4i____class_destructor__ = _base.GMathVec4i____class_destructor__

class GMathVec2iBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2iBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2iBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec2iBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec2iBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2iBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec2iBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec2iBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec2iBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec2iBasicArray_front(self)

    def back(self):
        return _base.GMathVec2iBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec2iBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec2iBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec2iBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec2iBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec2iBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2iBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec2iBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2iBasicArray_class_info)
    else:
        class_info = _base.GMathVec2iBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2iBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2iBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec2iBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2iBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec2iBasicArray_swigregister = _base.GMathVec2iBasicArray_swigregister
GMathVec2iBasicArray_swigregister(GMathVec2iBasicArray)

def GMathVec2iBasicArray_class_info():
    return _base.GMathVec2iBasicArray_class_info()
GMathVec2iBasicArray_class_info = _base.GMathVec2iBasicArray_class_info

def GMathVec2iBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec2iBasicArray____class_destructor__(instance, is_array)
GMathVec2iBasicArray____class_destructor__ = _base.GMathVec2iBasicArray____class_destructor__

class GMathVec2iArray(GMathVec2iBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2iBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2iArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2iBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2iArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2iArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2iArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2iArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec2iArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec2iArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec2iArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2iArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2iArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2iArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2iArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec2iArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2iArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2iArray_class_info)
    else:
        class_info = _base.GMathVec2iArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2iArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2iArray____class_destructor__
GMathVec2iArray_swigregister = _base.GMathVec2iArray_swigregister
GMathVec2iArray_swigregister(GMathVec2iArray)

def GMathVec2iArray_class_info():
    return _base.GMathVec2iArray_class_info()
GMathVec2iArray_class_info = _base.GMathVec2iArray_class_info

def GMathVec2iArray____class_destructor__(instance, is_array):
    return _base.GMathVec2iArray____class_destructor__(instance, is_array)
GMathVec2iArray____class_destructor__ = _base.GMathVec2iArray____class_destructor__

class GMathVec2iVector(GMathVec2iBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2iBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2iVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2iBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2iVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2iVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2iVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2iVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec2iVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec2iVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec2iVector_remove_last(self)

    def empty(self):
        return _base.GMathVec2iVector_empty(self)

    def remove_all(self):
        return _base.GMathVec2iVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec2iVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec2iVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec2iVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec2iVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec2iVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec2iVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec2iVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec2iVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec2iVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec2iVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec2iVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec2iVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec2iVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2iVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2iVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2iVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2iVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec2iVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec2iVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec2iVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec2iVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec2iVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2iVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2iVector_class_info)
    else:
        class_info = _base.GMathVec2iVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2iVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2iVector____class_destructor__
GMathVec2iVector_swigregister = _base.GMathVec2iVector_swigregister
GMathVec2iVector_swigregister(GMathVec2iVector)

def GMathVec2iVector_class_info():
    return _base.GMathVec2iVector_class_info()
GMathVec2iVector_class_info = _base.GMathVec2iVector_class_info

def GMathVec2iVector____class_destructor__(instance, is_array):
    return _base.GMathVec2iVector____class_destructor__(instance, is_array)
GMathVec2iVector____class_destructor__ = _base.GMathVec2iVector____class_destructor__

class GMathVec2iSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2iSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2iSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2iSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec2iSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec2iSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec2iSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec2iSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec2iSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec2iSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec2iSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec2iSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec2iSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec2iSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec2iSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec2iSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec2iSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec2iSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec2iSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec2iSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec2iSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec2iSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec2iSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2iSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec2iSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec2iSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2iSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec2iSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec2iSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec2iSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2iSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2iSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2iSet
    __del__ = lambda self: None
GMathVec2iSet_swigregister = _base.GMathVec2iSet_swigregister
GMathVec2iSet_swigregister(GMathVec2iSet)

def GMathVec2iSet_get_linear_search_threshold():
    return _base.GMathVec2iSet_get_linear_search_threshold()
GMathVec2iSet_get_linear_search_threshold = _base.GMathVec2iSet_get_linear_search_threshold

class GMathVec3iBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3iBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3iBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec3iBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec3iBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3iBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec3iBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec3iBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec3iBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec3iBasicArray_front(self)

    def back(self):
        return _base.GMathVec3iBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec3iBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec3iBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec3iBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec3iBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec3iBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3iBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec3iBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3iBasicArray_class_info)
    else:
        class_info = _base.GMathVec3iBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3iBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3iBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec3iBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3iBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec3iBasicArray_swigregister = _base.GMathVec3iBasicArray_swigregister
GMathVec3iBasicArray_swigregister(GMathVec3iBasicArray)

def GMathVec3iBasicArray_class_info():
    return _base.GMathVec3iBasicArray_class_info()
GMathVec3iBasicArray_class_info = _base.GMathVec3iBasicArray_class_info

def GMathVec3iBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec3iBasicArray____class_destructor__(instance, is_array)
GMathVec3iBasicArray____class_destructor__ = _base.GMathVec3iBasicArray____class_destructor__

class GMathVec3iArray(GMathVec3iBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3iBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3iArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3iBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3iArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3iArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3iArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3iArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec3iArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec3iArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec3iArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3iArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3iArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3iArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3iArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec3iArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3iArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3iArray_class_info)
    else:
        class_info = _base.GMathVec3iArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3iArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3iArray____class_destructor__
GMathVec3iArray_swigregister = _base.GMathVec3iArray_swigregister
GMathVec3iArray_swigregister(GMathVec3iArray)

def GMathVec3iArray_class_info():
    return _base.GMathVec3iArray_class_info()
GMathVec3iArray_class_info = _base.GMathVec3iArray_class_info

def GMathVec3iArray____class_destructor__(instance, is_array):
    return _base.GMathVec3iArray____class_destructor__(instance, is_array)
GMathVec3iArray____class_destructor__ = _base.GMathVec3iArray____class_destructor__

class GMathVec3iVector(GMathVec3iBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3iBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3iVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3iBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3iVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3iVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3iVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3iVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec3iVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec3iVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec3iVector_remove_last(self)

    def empty(self):
        return _base.GMathVec3iVector_empty(self)

    def remove_all(self):
        return _base.GMathVec3iVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec3iVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec3iVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec3iVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec3iVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec3iVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec3iVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec3iVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec3iVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec3iVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec3iVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec3iVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec3iVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec3iVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3iVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3iVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3iVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3iVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec3iVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec3iVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec3iVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec3iVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec3iVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3iVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3iVector_class_info)
    else:
        class_info = _base.GMathVec3iVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3iVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3iVector____class_destructor__
GMathVec3iVector_swigregister = _base.GMathVec3iVector_swigregister
GMathVec3iVector_swigregister(GMathVec3iVector)

def GMathVec3iVector_class_info():
    return _base.GMathVec3iVector_class_info()
GMathVec3iVector_class_info = _base.GMathVec3iVector_class_info

def GMathVec3iVector____class_destructor__(instance, is_array):
    return _base.GMathVec3iVector____class_destructor__(instance, is_array)
GMathVec3iVector____class_destructor__ = _base.GMathVec3iVector____class_destructor__

class GMathVec3iSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3iSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3iSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3iSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec3iSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec3iSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec3iSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec3iSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec3iSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec3iSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec3iSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec3iSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec3iSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec3iSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec3iSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec3iSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec3iSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec3iSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec3iSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec3iSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec3iSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec3iSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec3iSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3iSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec3iSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec3iSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3iSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec3iSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec3iSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec3iSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3iSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3iSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3iSet
    __del__ = lambda self: None
GMathVec3iSet_swigregister = _base.GMathVec3iSet_swigregister
GMathVec3iSet_swigregister(GMathVec3iSet)

def GMathVec3iSet_get_linear_search_threshold():
    return _base.GMathVec3iSet_get_linear_search_threshold()
GMathVec3iSet_get_linear_search_threshold = _base.GMathVec3iSet_get_linear_search_threshold

class GMathVec4iBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4iBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4iBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec4iBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec4iBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4iBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec4iBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec4iBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec4iBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec4iBasicArray_front(self)

    def back(self):
        return _base.GMathVec4iBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec4iBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec4iBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec4iBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec4iBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec4iBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4iBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec4iBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4iBasicArray_class_info)
    else:
        class_info = _base.GMathVec4iBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4iBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4iBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec4iBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4iBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec4iBasicArray_swigregister = _base.GMathVec4iBasicArray_swigregister
GMathVec4iBasicArray_swigregister(GMathVec4iBasicArray)

def GMathVec4iBasicArray_class_info():
    return _base.GMathVec4iBasicArray_class_info()
GMathVec4iBasicArray_class_info = _base.GMathVec4iBasicArray_class_info

def GMathVec4iBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec4iBasicArray____class_destructor__(instance, is_array)
GMathVec4iBasicArray____class_destructor__ = _base.GMathVec4iBasicArray____class_destructor__

class GMathVec4iArray(GMathVec4iBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4iBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4iArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4iBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4iArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4iArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4iArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4iArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec4iArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec4iArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec4iArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4iArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4iArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4iArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4iArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec4iArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4iArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4iArray_class_info)
    else:
        class_info = _base.GMathVec4iArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4iArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4iArray____class_destructor__
GMathVec4iArray_swigregister = _base.GMathVec4iArray_swigregister
GMathVec4iArray_swigregister(GMathVec4iArray)

def GMathVec4iArray_class_info():
    return _base.GMathVec4iArray_class_info()
GMathVec4iArray_class_info = _base.GMathVec4iArray_class_info

def GMathVec4iArray____class_destructor__(instance, is_array):
    return _base.GMathVec4iArray____class_destructor__(instance, is_array)
GMathVec4iArray____class_destructor__ = _base.GMathVec4iArray____class_destructor__

class GMathVec4iVector(GMathVec4iBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4iBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4iVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4iBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4iVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4iVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4iVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4iVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec4iVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec4iVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec4iVector_remove_last(self)

    def empty(self):
        return _base.GMathVec4iVector_empty(self)

    def remove_all(self):
        return _base.GMathVec4iVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec4iVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec4iVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec4iVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec4iVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec4iVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec4iVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec4iVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec4iVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec4iVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec4iVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec4iVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec4iVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec4iVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4iVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4iVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4iVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4iVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec4iVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec4iVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec4iVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec4iVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec4iVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4iVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4iVector_class_info)
    else:
        class_info = _base.GMathVec4iVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4iVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4iVector____class_destructor__
GMathVec4iVector_swigregister = _base.GMathVec4iVector_swigregister
GMathVec4iVector_swigregister(GMathVec4iVector)

def GMathVec4iVector_class_info():
    return _base.GMathVec4iVector_class_info()
GMathVec4iVector_class_info = _base.GMathVec4iVector_class_info

def GMathVec4iVector____class_destructor__(instance, is_array):
    return _base.GMathVec4iVector____class_destructor__(instance, is_array)
GMathVec4iVector____class_destructor__ = _base.GMathVec4iVector____class_destructor__

class GMathVec4iSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4iSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4iSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4iSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec4iSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec4iSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec4iSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec4iSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec4iSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec4iSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec4iSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec4iSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec4iSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec4iSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec4iSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec4iSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec4iSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec4iSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec4iSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec4iSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec4iSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec4iSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec4iSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec4iSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec4iSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec4iSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4iSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec4iSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec4iSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec4iSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4iSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4iSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4iSet
    __del__ = lambda self: None
GMathVec4iSet_swigregister = _base.GMathVec4iSet_swigregister
GMathVec4iSet_swigregister(GMathVec4iSet)

def GMathVec4iSet_get_linear_search_threshold():
    return _base.GMathVec4iSet_get_linear_search_threshold()
GMathVec4iSet_get_linear_search_threshold = _base.GMathVec4iSet_get_linear_search_threshold

class GMathVec2ui(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2ui, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2ui, name)

    def __init__(self, *args):
        this = _base.new_GMathVec2ui(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec2ui_nullify(self)

    def get_value(self, index):
        return _base.GMathVec2ui_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec2ui_set_value(self, index, value)

    def get_width(self):
        return _base.GMathVec2ui_get_width(self)

    def set_width(self, width):
        return _base.GMathVec2ui_set_width(self, width)

    def get_height(self):
        return _base.GMathVec2ui_get_height(self)

    def set_height(self, height):
        return _base.GMathVec2ui_set_height(self, height)

    def get_x(self):
        return _base.GMathVec2ui_get_x(self)

    def set_x(self, x):
        return _base.GMathVec2ui_set_x(self, x)

    def get_y(self):
        return _base.GMathVec2ui_get_y(self)

    def set_y(self, y):
        return _base.GMathVec2ui_set_y(self, y)

    def get_red(self):
        return _base.GMathVec2ui_get_red(self)

    def get_u(self):
        return _base.GMathVec2ui_get_u(self)

    def set_u(self, u):
        return _base.GMathVec2ui_set_u(self, u)

    def get_v(self):
        return _base.GMathVec2ui_get_v(self)

    def set_v(self, v):
        return _base.GMathVec2ui_set_v(self, v)

    def sub(self, *args):
        return _base.GMathVec2ui_sub(self, *args)

    def absolute(self):
        return _base.GMathVec2ui_absolute(self)

    def get_sqr_length(self):
        return _base.GMathVec2ui_get_sqr_length(self)

    def get_length(self):
        return _base.GMathVec2ui_get_length(self)

    def get_max_norm_signed(self):
        return _base.GMathVec2ui_get_max_norm_signed(self)

    def get_max_norm(self):
        return _base.GMathVec2ui_get_max_norm(self)

    def normalize(self, *args):
        return _base.GMathVec2ui_normalize(self, *args)

    def get_copy(self):
        return _base.GMathVec2ui_get_copy(self)

    def copy_from(self, v):
        return _base.GMathVec2ui_copy_from(self, v)

    def copy_to(self, v):
        return _base.GMathVec2ui_copy_to(self, v)

    def is_null(self, *args):
        return _base.GMathVec2ui_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec2ui_is_finite(self)

    def __eq__(self, v):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2ui___eq__(self, v)


    def __ne__(self, v):
        return _base.GMathVec2ui___ne__(self, v)

    def __iadd__(self, *args):
        return _base.GMathVec2ui___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec2ui___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec2ui___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec2ui___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec2ui___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec2ui___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec2ui___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec2ui___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec2ui___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec2ui_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2ui_class_info)
    else:
        class_info = _base.GMathVec2ui_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec2ui_register_methods)
    else:
        register_methods = _base.GMathVec2ui_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2ui____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2ui____class_destructor__

    def __repr__(self):
        return _base.GMathVec2ui___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2ui___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec2ui___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec2ui___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2ui
    __del__ = lambda self: None
GMathVec2ui_swigregister = _base.GMathVec2ui_swigregister
GMathVec2ui_swigregister(GMathVec2ui)

def GMathVec2ui_class_info():
    return _base.GMathVec2ui_class_info()
GMathVec2ui_class_info = _base.GMathVec2ui_class_info

def GMathVec2ui_register_methods(arg2):
    return _base.GMathVec2ui_register_methods(arg2)
GMathVec2ui_register_methods = _base.GMathVec2ui_register_methods

def GMathVec2ui____class_destructor__(instance, is_array):
    return _base.GMathVec2ui____class_destructor__(instance, is_array)
GMathVec2ui____class_destructor__ = _base.GMathVec2ui____class_destructor__

class GMathVec3ui(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3ui, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3ui, name)
    if _newclass:
        create_local_axis = staticmethod(_base.GMathVec3ui_create_local_axis)
    else:
        create_local_axis = _base.GMathVec3ui_create_local_axis

    def __init__(self, *args):
        this = _base.new_GMathVec3ui(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec3ui_nullify(self)

    def get_copy(self):
        return _base.GMathVec3ui_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec3ui_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec3ui_copy_to(self, u)

    def __ne__(self, *args):
        return _base.GMathVec3ui___ne__(self, *args)

    def __eq__(self, *args):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3ui___eq__(self, *args)


    def __lt__(self, *args):
        return _base.GMathVec3ui___lt__(self, *args)

    def __gt__(self, *args):
        return _base.GMathVec3ui___gt__(self, *args)

    def __le__(self, *args):
        return _base.GMathVec3ui___le__(self, *args)

    def __ge__(self, *args):
        return _base.GMathVec3ui___ge__(self, *args)

    def absolute(self):
        return _base.GMathVec3ui_absolute(self)

    def get_sqr_norm(self, *args):
        return _base.GMathVec3ui_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec3ui_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec3ui_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec3ui_get_length(self, *args)

    def get_l1_norm_signed(self, *args):
        return _base.GMathVec3ui_get_l1_norm_signed(self, *args)

    def get_l1_norm(self, *args):
        return _base.GMathVec3ui_get_l1_norm(self, *args)

    def get_max_norm_signed(self, *args):
        return _base.GMathVec3ui_get_max_norm_signed(self, *args)

    def get_max_norm(self, *args):
        return _base.GMathVec3ui_get_max_norm(self, *args)

    def get_min_norm_signed(self, *args):
        return _base.GMathVec3ui_get_min_norm_signed(self, *args)

    def get_min_norm(self, *args):
        return _base.GMathVec3ui_get_min_norm(self, *args)

    def scale(self, s):
        return _base.GMathVec3ui_scale(self, s)

    def get_main_axis(self):
        return _base.GMathVec3ui_get_main_axis(self)

    def normalize(self, *args):
        return _base.GMathVec3ui_normalize(self, *args)

    def is_null(self, *args):
        return _base.GMathVec3ui_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec3ui_is_finite(self)

    def get_data(self, *args):
        return _base.GMathVec3ui_get_data(self, *args)

    def __iadd__(self, *args):
        return _base.GMathVec3ui___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec3ui___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec3ui___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec3ui___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec3ui___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec3ui___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec3ui___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec3ui___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec3ui___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec3ui_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3ui_class_info)
    else:
        class_info = _base.GMathVec3ui_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec3ui_register_methods)
    else:
        register_methods = _base.GMathVec3ui_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3ui____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3ui____class_destructor__

    def __repr__(self):
        return _base.GMathVec3ui___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3ui___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec3ui___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec3ui___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3ui
    __del__ = lambda self: None
GMathVec3ui_swigregister = _base.GMathVec3ui_swigregister
GMathVec3ui_swigregister(GMathVec3ui)

def GMathVec3ui_create_local_axis(v1, v2, v3):
    return _base.GMathVec3ui_create_local_axis(v1, v2, v3)
GMathVec3ui_create_local_axis = _base.GMathVec3ui_create_local_axis

def GMathVec3ui_class_info():
    return _base.GMathVec3ui_class_info()
GMathVec3ui_class_info = _base.GMathVec3ui_class_info

def GMathVec3ui_register_methods(cls):
    return _base.GMathVec3ui_register_methods(cls)
GMathVec3ui_register_methods = _base.GMathVec3ui_register_methods

def GMathVec3ui____class_destructor__(instance, is_array):
    return _base.GMathVec3ui____class_destructor__(instance, is_array)
GMathVec3ui____class_destructor__ = _base.GMathVec3ui____class_destructor__

class GMathVec4ui(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4ui, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4ui, name)

    def __init__(self, *args):
        this = _base.new_GMathVec4ui(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec4ui_nullify(self)

    def get_copy(self):
        return _base.GMathVec4ui_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec4ui_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec4ui_copy_to(self, u)

    def get_value(self, index):
        return _base.GMathVec4ui_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec4ui_set_value(self, index, value)

    def get_x(self):
        return _base.GMathVec4ui_get_x(self)

    def set_x(self, x):
        return _base.GMathVec4ui_set_x(self, x)

    def get_y(self):
        return _base.GMathVec4ui_get_y(self)

    def set_y(self, y):
        return _base.GMathVec4ui_set_y(self, y)

    def get_z(self):
        return _base.GMathVec4ui_get_z(self)

    def set_z(self, z):
        return _base.GMathVec4ui_set_z(self, z)

    def get_w(self):
        return _base.GMathVec4ui_get_w(self)

    def set_w(self, w):
        return _base.GMathVec4ui_set_w(self, w)

    def get_red(self):
        return _base.GMathVec4ui_get_red(self)

    def set_red(self, red):
        return _base.GMathVec4ui_set_red(self, red)

    def get_green(self):
        return _base.GMathVec4ui_get_green(self)

    def set_green(self, green):
        return _base.GMathVec4ui_set_green(self, green)

    def get_blue(self):
        return _base.GMathVec4ui_get_blue(self)

    def set_blue(self, blue):
        return _base.GMathVec4ui_set_blue(self, blue)

    def get_alpha(self):
        return _base.GMathVec4ui_get_alpha(self)

    def set_alpha(self, alpha):
        return _base.GMathVec4ui_set_alpha(self, alpha)

    def get_sqr_norm(self, *args):
        return _base.GMathVec4ui_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec4ui_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec4ui_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec4ui_get_length(self, *args)

    def sub(self, *args):
        return _base.GMathVec4ui_sub(self, *args)

    def get_data(self, *args):
        return _base.GMathVec4ui_get_data(self, *args)

    def is_null(self, *args):
        return _base.GMathVec4ui_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec4ui_is_finite(self)

    def __iadd__(self, *args):
        return _base.GMathVec4ui___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec4ui___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec4ui___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec4ui___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec4ui___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec4ui___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec4ui___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec4ui___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec4ui___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec4ui_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4ui_class_info)
    else:
        class_info = _base.GMathVec4ui_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec4ui_register_methods)
    else:
        register_methods = _base.GMathVec4ui_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4ui____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4ui____class_destructor__

    def __repr__(self):
        return _base.GMathVec4ui___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4ui___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec4ui___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec4ui___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4ui
    __del__ = lambda self: None
GMathVec4ui_swigregister = _base.GMathVec4ui_swigregister
GMathVec4ui_swigregister(GMathVec4ui)

def GMathVec4ui_class_info():
    return _base.GMathVec4ui_class_info()
GMathVec4ui_class_info = _base.GMathVec4ui_class_info

def GMathVec4ui_register_methods(cls):
    return _base.GMathVec4ui_register_methods(cls)
GMathVec4ui_register_methods = _base.GMathVec4ui_register_methods

def GMathVec4ui____class_destructor__(instance, is_array):
    return _base.GMathVec4ui____class_destructor__(instance, is_array)
GMathVec4ui____class_destructor__ = _base.GMathVec4ui____class_destructor__

class GMathVec2uiBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2uiBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2uiBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec2uiBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec2uiBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2uiBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec2uiBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec2uiBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec2uiBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec2uiBasicArray_front(self)

    def back(self):
        return _base.GMathVec2uiBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec2uiBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec2uiBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec2uiBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec2uiBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec2uiBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2uiBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec2uiBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2uiBasicArray_class_info)
    else:
        class_info = _base.GMathVec2uiBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2uiBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2uiBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec2uiBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2uiBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec2uiBasicArray_swigregister = _base.GMathVec2uiBasicArray_swigregister
GMathVec2uiBasicArray_swigregister(GMathVec2uiBasicArray)

def GMathVec2uiBasicArray_class_info():
    return _base.GMathVec2uiBasicArray_class_info()
GMathVec2uiBasicArray_class_info = _base.GMathVec2uiBasicArray_class_info

def GMathVec2uiBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec2uiBasicArray____class_destructor__(instance, is_array)
GMathVec2uiBasicArray____class_destructor__ = _base.GMathVec2uiBasicArray____class_destructor__

class GMathVec2uiArray(GMathVec2uiBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2uiBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2uiArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2uiBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2uiArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2uiArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2uiArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2uiArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec2uiArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec2uiArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec2uiArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2uiArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2uiArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2uiArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2uiArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec2uiArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2uiArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2uiArray_class_info)
    else:
        class_info = _base.GMathVec2uiArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2uiArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2uiArray____class_destructor__
GMathVec2uiArray_swigregister = _base.GMathVec2uiArray_swigregister
GMathVec2uiArray_swigregister(GMathVec2uiArray)

def GMathVec2uiArray_class_info():
    return _base.GMathVec2uiArray_class_info()
GMathVec2uiArray_class_info = _base.GMathVec2uiArray_class_info

def GMathVec2uiArray____class_destructor__(instance, is_array):
    return _base.GMathVec2uiArray____class_destructor__(instance, is_array)
GMathVec2uiArray____class_destructor__ = _base.GMathVec2uiArray____class_destructor__

class GMathVec2uiVector(GMathVec2uiBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2uiBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2uiVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2uiBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2uiVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2uiVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2uiVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2uiVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec2uiVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec2uiVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec2uiVector_remove_last(self)

    def empty(self):
        return _base.GMathVec2uiVector_empty(self)

    def remove_all(self):
        return _base.GMathVec2uiVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec2uiVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec2uiVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec2uiVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec2uiVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec2uiVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec2uiVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec2uiVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec2uiVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec2uiVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec2uiVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec2uiVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec2uiVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec2uiVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2uiVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2uiVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2uiVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2uiVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec2uiVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec2uiVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec2uiVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec2uiVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec2uiVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2uiVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2uiVector_class_info)
    else:
        class_info = _base.GMathVec2uiVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2uiVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2uiVector____class_destructor__
GMathVec2uiVector_swigregister = _base.GMathVec2uiVector_swigregister
GMathVec2uiVector_swigregister(GMathVec2uiVector)

def GMathVec2uiVector_class_info():
    return _base.GMathVec2uiVector_class_info()
GMathVec2uiVector_class_info = _base.GMathVec2uiVector_class_info

def GMathVec2uiVector____class_destructor__(instance, is_array):
    return _base.GMathVec2uiVector____class_destructor__(instance, is_array)
GMathVec2uiVector____class_destructor__ = _base.GMathVec2uiVector____class_destructor__

class GMathVec2uiSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2uiSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2uiSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2uiSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec2uiSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec2uiSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec2uiSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec2uiSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec2uiSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec2uiSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec2uiSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec2uiSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec2uiSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec2uiSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec2uiSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec2uiSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec2uiSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec2uiSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec2uiSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec2uiSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec2uiSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec2uiSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec2uiSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2uiSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec2uiSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec2uiSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2uiSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec2uiSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec2uiSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec2uiSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2uiSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2uiSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2uiSet
    __del__ = lambda self: None
GMathVec2uiSet_swigregister = _base.GMathVec2uiSet_swigregister
GMathVec2uiSet_swigregister(GMathVec2uiSet)

def GMathVec2uiSet_get_linear_search_threshold():
    return _base.GMathVec2uiSet_get_linear_search_threshold()
GMathVec2uiSet_get_linear_search_threshold = _base.GMathVec2uiSet_get_linear_search_threshold

class GMathVec3uiBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3uiBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3uiBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec3uiBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec3uiBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3uiBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec3uiBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec3uiBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec3uiBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec3uiBasicArray_front(self)

    def back(self):
        return _base.GMathVec3uiBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec3uiBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec3uiBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec3uiBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec3uiBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec3uiBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3uiBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec3uiBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3uiBasicArray_class_info)
    else:
        class_info = _base.GMathVec3uiBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3uiBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3uiBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec3uiBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3uiBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec3uiBasicArray_swigregister = _base.GMathVec3uiBasicArray_swigregister
GMathVec3uiBasicArray_swigregister(GMathVec3uiBasicArray)

def GMathVec3uiBasicArray_class_info():
    return _base.GMathVec3uiBasicArray_class_info()
GMathVec3uiBasicArray_class_info = _base.GMathVec3uiBasicArray_class_info

def GMathVec3uiBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec3uiBasicArray____class_destructor__(instance, is_array)
GMathVec3uiBasicArray____class_destructor__ = _base.GMathVec3uiBasicArray____class_destructor__

class GMathVec3uiArray(GMathVec3uiBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3uiBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3uiArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3uiBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3uiArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3uiArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3uiArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3uiArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec3uiArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec3uiArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec3uiArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3uiArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3uiArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3uiArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3uiArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec3uiArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3uiArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3uiArray_class_info)
    else:
        class_info = _base.GMathVec3uiArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3uiArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3uiArray____class_destructor__
GMathVec3uiArray_swigregister = _base.GMathVec3uiArray_swigregister
GMathVec3uiArray_swigregister(GMathVec3uiArray)

def GMathVec3uiArray_class_info():
    return _base.GMathVec3uiArray_class_info()
GMathVec3uiArray_class_info = _base.GMathVec3uiArray_class_info

def GMathVec3uiArray____class_destructor__(instance, is_array):
    return _base.GMathVec3uiArray____class_destructor__(instance, is_array)
GMathVec3uiArray____class_destructor__ = _base.GMathVec3uiArray____class_destructor__

class GMathVec3uiVector(GMathVec3uiBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3uiBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3uiVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3uiBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3uiVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3uiVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3uiVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3uiVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec3uiVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec3uiVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec3uiVector_remove_last(self)

    def empty(self):
        return _base.GMathVec3uiVector_empty(self)

    def remove_all(self):
        return _base.GMathVec3uiVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec3uiVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec3uiVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec3uiVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec3uiVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec3uiVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec3uiVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec3uiVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec3uiVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec3uiVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec3uiVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec3uiVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec3uiVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec3uiVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3uiVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3uiVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3uiVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3uiVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec3uiVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec3uiVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec3uiVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec3uiVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec3uiVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3uiVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3uiVector_class_info)
    else:
        class_info = _base.GMathVec3uiVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3uiVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3uiVector____class_destructor__
GMathVec3uiVector_swigregister = _base.GMathVec3uiVector_swigregister
GMathVec3uiVector_swigregister(GMathVec3uiVector)

def GMathVec3uiVector_class_info():
    return _base.GMathVec3uiVector_class_info()
GMathVec3uiVector_class_info = _base.GMathVec3uiVector_class_info

def GMathVec3uiVector____class_destructor__(instance, is_array):
    return _base.GMathVec3uiVector____class_destructor__(instance, is_array)
GMathVec3uiVector____class_destructor__ = _base.GMathVec3uiVector____class_destructor__

class GMathVec3uiSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3uiSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3uiSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3uiSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec3uiSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec3uiSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec3uiSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec3uiSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec3uiSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec3uiSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec3uiSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec3uiSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec3uiSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec3uiSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec3uiSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec3uiSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec3uiSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec3uiSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec3uiSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec3uiSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec3uiSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec3uiSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec3uiSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3uiSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec3uiSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec3uiSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3uiSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec3uiSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec3uiSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec3uiSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3uiSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3uiSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3uiSet
    __del__ = lambda self: None
GMathVec3uiSet_swigregister = _base.GMathVec3uiSet_swigregister
GMathVec3uiSet_swigregister(GMathVec3uiSet)

def GMathVec3uiSet_get_linear_search_threshold():
    return _base.GMathVec3uiSet_get_linear_search_threshold()
GMathVec3uiSet_get_linear_search_threshold = _base.GMathVec3uiSet_get_linear_search_threshold

class GMathVec4uiBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4uiBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4uiBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec4uiBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec4uiBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4uiBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec4uiBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec4uiBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec4uiBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec4uiBasicArray_front(self)

    def back(self):
        return _base.GMathVec4uiBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec4uiBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec4uiBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec4uiBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec4uiBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec4uiBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4uiBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec4uiBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4uiBasicArray_class_info)
    else:
        class_info = _base.GMathVec4uiBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4uiBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4uiBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec4uiBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4uiBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec4uiBasicArray_swigregister = _base.GMathVec4uiBasicArray_swigregister
GMathVec4uiBasicArray_swigregister(GMathVec4uiBasicArray)

def GMathVec4uiBasicArray_class_info():
    return _base.GMathVec4uiBasicArray_class_info()
GMathVec4uiBasicArray_class_info = _base.GMathVec4uiBasicArray_class_info

def GMathVec4uiBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec4uiBasicArray____class_destructor__(instance, is_array)
GMathVec4uiBasicArray____class_destructor__ = _base.GMathVec4uiBasicArray____class_destructor__

class GMathVec4uiArray(GMathVec4uiBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4uiBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4uiArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4uiBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4uiArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4uiArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4uiArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4uiArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec4uiArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec4uiArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec4uiArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4uiArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4uiArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4uiArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4uiArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec4uiArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4uiArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4uiArray_class_info)
    else:
        class_info = _base.GMathVec4uiArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4uiArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4uiArray____class_destructor__
GMathVec4uiArray_swigregister = _base.GMathVec4uiArray_swigregister
GMathVec4uiArray_swigregister(GMathVec4uiArray)

def GMathVec4uiArray_class_info():
    return _base.GMathVec4uiArray_class_info()
GMathVec4uiArray_class_info = _base.GMathVec4uiArray_class_info

def GMathVec4uiArray____class_destructor__(instance, is_array):
    return _base.GMathVec4uiArray____class_destructor__(instance, is_array)
GMathVec4uiArray____class_destructor__ = _base.GMathVec4uiArray____class_destructor__

class GMathVec4uiVector(GMathVec4uiBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4uiBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4uiVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4uiBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4uiVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4uiVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4uiVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4uiVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec4uiVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec4uiVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec4uiVector_remove_last(self)

    def empty(self):
        return _base.GMathVec4uiVector_empty(self)

    def remove_all(self):
        return _base.GMathVec4uiVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec4uiVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec4uiVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec4uiVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec4uiVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec4uiVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec4uiVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec4uiVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec4uiVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec4uiVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec4uiVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec4uiVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec4uiVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec4uiVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4uiVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4uiVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4uiVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4uiVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec4uiVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec4uiVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec4uiVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec4uiVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec4uiVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4uiVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4uiVector_class_info)
    else:
        class_info = _base.GMathVec4uiVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4uiVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4uiVector____class_destructor__
GMathVec4uiVector_swigregister = _base.GMathVec4uiVector_swigregister
GMathVec4uiVector_swigregister(GMathVec4uiVector)

def GMathVec4uiVector_class_info():
    return _base.GMathVec4uiVector_class_info()
GMathVec4uiVector_class_info = _base.GMathVec4uiVector_class_info

def GMathVec4uiVector____class_destructor__(instance, is_array):
    return _base.GMathVec4uiVector____class_destructor__(instance, is_array)
GMathVec4uiVector____class_destructor__ = _base.GMathVec4uiVector____class_destructor__

class GMathVec4uiSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4uiSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4uiSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4uiSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec4uiSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec4uiSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec4uiSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec4uiSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec4uiSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec4uiSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec4uiSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec4uiSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec4uiSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec4uiSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec4uiSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec4uiSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec4uiSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec4uiSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec4uiSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec4uiSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec4uiSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec4uiSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec4uiSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec4uiSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec4uiSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec4uiSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4uiSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec4uiSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec4uiSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec4uiSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4uiSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4uiSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4uiSet
    __del__ = lambda self: None
GMathVec4uiSet_swigregister = _base.GMathVec4uiSet_swigregister
GMathVec4uiSet_swigregister(GMathVec4uiSet)

def GMathVec4uiSet_get_linear_search_threshold():
    return _base.GMathVec4uiSet_get_linear_search_threshold()
GMathVec4uiSet_get_linear_search_threshold = _base.GMathVec4uiSet_get_linear_search_threshold

class GMathVec2f(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2f, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2f, name)

    def __init__(self, *args):
        this = _base.new_GMathVec2f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec2f_nullify(self)

    def get_value(self, index):
        return _base.GMathVec2f_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec2f_set_value(self, index, value)

    def get_width(self):
        return _base.GMathVec2f_get_width(self)

    def set_width(self, width):
        return _base.GMathVec2f_set_width(self, width)

    def get_height(self):
        return _base.GMathVec2f_get_height(self)

    def set_height(self, height):
        return _base.GMathVec2f_set_height(self, height)

    def get_x(self):
        return _base.GMathVec2f_get_x(self)

    def set_x(self, x):
        return _base.GMathVec2f_set_x(self, x)

    def get_y(self):
        return _base.GMathVec2f_get_y(self)

    def set_y(self, y):
        return _base.GMathVec2f_set_y(self, y)

    def get_red(self):
        return _base.GMathVec2f_get_red(self)

    def get_u(self):
        return _base.GMathVec2f_get_u(self)

    def set_u(self, u):
        return _base.GMathVec2f_set_u(self, u)

    def get_v(self):
        return _base.GMathVec2f_get_v(self)

    def set_v(self, v):
        return _base.GMathVec2f_set_v(self, v)

    def sub(self, *args):
        return _base.GMathVec2f_sub(self, *args)

    def absolute(self):
        return _base.GMathVec2f_absolute(self)

    def get_sqr_length(self):
        return _base.GMathVec2f_get_sqr_length(self)

    def get_length(self):
        return _base.GMathVec2f_get_length(self)

    def get_max_norm_signed(self):
        return _base.GMathVec2f_get_max_norm_signed(self)

    def get_max_norm(self):
        return _base.GMathVec2f_get_max_norm(self)

    def normalize(self, *args):
        return _base.GMathVec2f_normalize(self, *args)

    def get_copy(self):
        return _base.GMathVec2f_get_copy(self)

    def copy_from(self, v):
        return _base.GMathVec2f_copy_from(self, v)

    def copy_to(self, v):
        return _base.GMathVec2f_copy_to(self, v)

    def is_null(self, *args):
        return _base.GMathVec2f_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec2f_is_finite(self)

    def __eq__(self, v):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2f___eq__(self, v)


    def __ne__(self, v):
        return _base.GMathVec2f___ne__(self, v)

    def __iadd__(self, *args):
        return _base.GMathVec2f___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec2f___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec2f___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec2f___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec2f___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec2f___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec2f___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec2f___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec2f___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec2f_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2f_class_info)
    else:
        class_info = _base.GMathVec2f_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec2f_register_methods)
    else:
        register_methods = _base.GMathVec2f_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2f____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2f____class_destructor__

    def __repr__(self):
        return _base.GMathVec2f___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2f___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec2f___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec2f___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2f
    __del__ = lambda self: None
GMathVec2f_swigregister = _base.GMathVec2f_swigregister
GMathVec2f_swigregister(GMathVec2f)

def GMathVec2f_class_info():
    return _base.GMathVec2f_class_info()
GMathVec2f_class_info = _base.GMathVec2f_class_info

def GMathVec2f_register_methods(arg2):
    return _base.GMathVec2f_register_methods(arg2)
GMathVec2f_register_methods = _base.GMathVec2f_register_methods

def GMathVec2f____class_destructor__(instance, is_array):
    return _base.GMathVec2f____class_destructor__(instance, is_array)
GMathVec2f____class_destructor__ = _base.GMathVec2f____class_destructor__

class GMathVec3f(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3f, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3f, name)
    if _newclass:
        create_local_axis = staticmethod(_base.GMathVec3f_create_local_axis)
    else:
        create_local_axis = _base.GMathVec3f_create_local_axis

    def __init__(self, *args):
        this = _base.new_GMathVec3f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec3f_nullify(self)

    def get_copy(self):
        return _base.GMathVec3f_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec3f_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec3f_copy_to(self, u)

    def __ne__(self, *args):
        return _base.GMathVec3f___ne__(self, *args)

    def __eq__(self, *args):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3f___eq__(self, *args)


    def __lt__(self, *args):
        return _base.GMathVec3f___lt__(self, *args)

    def __gt__(self, *args):
        return _base.GMathVec3f___gt__(self, *args)

    def __le__(self, *args):
        return _base.GMathVec3f___le__(self, *args)

    def __ge__(self, *args):
        return _base.GMathVec3f___ge__(self, *args)

    def absolute(self):
        return _base.GMathVec3f_absolute(self)

    def get_sqr_norm(self, *args):
        return _base.GMathVec3f_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec3f_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec3f_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec3f_get_length(self, *args)

    def get_l1_norm_signed(self, *args):
        return _base.GMathVec3f_get_l1_norm_signed(self, *args)

    def get_l1_norm(self, *args):
        return _base.GMathVec3f_get_l1_norm(self, *args)

    def get_max_norm_signed(self, *args):
        return _base.GMathVec3f_get_max_norm_signed(self, *args)

    def get_max_norm(self, *args):
        return _base.GMathVec3f_get_max_norm(self, *args)

    def get_min_norm_signed(self, *args):
        return _base.GMathVec3f_get_min_norm_signed(self, *args)

    def get_min_norm(self, *args):
        return _base.GMathVec3f_get_min_norm(self, *args)

    def scale(self, s):
        return _base.GMathVec3f_scale(self, s)

    def get_main_axis(self):
        return _base.GMathVec3f_get_main_axis(self)

    def normalize(self, *args):
        return _base.GMathVec3f_normalize(self, *args)

    def is_null(self, *args):
        return _base.GMathVec3f_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec3f_is_finite(self)

    def get_data(self, *args):
        return _base.GMathVec3f_get_data(self, *args)

    def __iadd__(self, *args):
        return _base.GMathVec3f___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec3f___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec3f___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec3f___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec3f___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec3f___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec3f___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec3f___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec3f___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec3f_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3f_class_info)
    else:
        class_info = _base.GMathVec3f_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec3f_register_methods)
    else:
        register_methods = _base.GMathVec3f_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3f____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3f____class_destructor__

    def __repr__(self):
        return _base.GMathVec3f___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3f___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec3f___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec3f___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3f
    __del__ = lambda self: None
GMathVec3f_swigregister = _base.GMathVec3f_swigregister
GMathVec3f_swigregister(GMathVec3f)

def GMathVec3f_create_local_axis(v1, v2, v3):
    return _base.GMathVec3f_create_local_axis(v1, v2, v3)
GMathVec3f_create_local_axis = _base.GMathVec3f_create_local_axis

def GMathVec3f_class_info():
    return _base.GMathVec3f_class_info()
GMathVec3f_class_info = _base.GMathVec3f_class_info

def GMathVec3f_register_methods(cls):
    return _base.GMathVec3f_register_methods(cls)
GMathVec3f_register_methods = _base.GMathVec3f_register_methods

def GMathVec3f____class_destructor__(instance, is_array):
    return _base.GMathVec3f____class_destructor__(instance, is_array)
GMathVec3f____class_destructor__ = _base.GMathVec3f____class_destructor__

class GMathVec4f(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4f, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4f, name)

    def __init__(self, *args):
        this = _base.new_GMathVec4f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec4f_nullify(self)

    def get_copy(self):
        return _base.GMathVec4f_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec4f_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec4f_copy_to(self, u)

    def get_value(self, index):
        return _base.GMathVec4f_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec4f_set_value(self, index, value)

    def get_x(self):
        return _base.GMathVec4f_get_x(self)

    def set_x(self, x):
        return _base.GMathVec4f_set_x(self, x)

    def get_y(self):
        return _base.GMathVec4f_get_y(self)

    def set_y(self, y):
        return _base.GMathVec4f_set_y(self, y)

    def get_z(self):
        return _base.GMathVec4f_get_z(self)

    def set_z(self, z):
        return _base.GMathVec4f_set_z(self, z)

    def get_w(self):
        return _base.GMathVec4f_get_w(self)

    def set_w(self, w):
        return _base.GMathVec4f_set_w(self, w)

    def get_red(self):
        return _base.GMathVec4f_get_red(self)

    def set_red(self, red):
        return _base.GMathVec4f_set_red(self, red)

    def get_green(self):
        return _base.GMathVec4f_get_green(self)

    def set_green(self, green):
        return _base.GMathVec4f_set_green(self, green)

    def get_blue(self):
        return _base.GMathVec4f_get_blue(self)

    def set_blue(self, blue):
        return _base.GMathVec4f_set_blue(self, blue)

    def get_alpha(self):
        return _base.GMathVec4f_get_alpha(self)

    def set_alpha(self, alpha):
        return _base.GMathVec4f_set_alpha(self, alpha)

    def get_sqr_norm(self, *args):
        return _base.GMathVec4f_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec4f_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec4f_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec4f_get_length(self, *args)

    def sub(self, *args):
        return _base.GMathVec4f_sub(self, *args)

    def get_data(self, *args):
        return _base.GMathVec4f_get_data(self, *args)

    def is_null(self, *args):
        return _base.GMathVec4f_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec4f_is_finite(self)

    def __iadd__(self, *args):
        return _base.GMathVec4f___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec4f___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec4f___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec4f___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec4f___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec4f___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec4f___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec4f___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec4f___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec4f_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4f_class_info)
    else:
        class_info = _base.GMathVec4f_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec4f_register_methods)
    else:
        register_methods = _base.GMathVec4f_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4f____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4f____class_destructor__

    def __repr__(self):
        return _base.GMathVec4f___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4f___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec4f___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec4f___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4f
    __del__ = lambda self: None
GMathVec4f_swigregister = _base.GMathVec4f_swigregister
GMathVec4f_swigregister(GMathVec4f)

def GMathVec4f_class_info():
    return _base.GMathVec4f_class_info()
GMathVec4f_class_info = _base.GMathVec4f_class_info

def GMathVec4f_register_methods(cls):
    return _base.GMathVec4f_register_methods(cls)
GMathVec4f_register_methods = _base.GMathVec4f_register_methods

def GMathVec4f____class_destructor__(instance, is_array):
    return _base.GMathVec4f____class_destructor__(instance, is_array)
GMathVec4f____class_destructor__ = _base.GMathVec4f____class_destructor__

class GMathVec2fBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2fBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2fBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec2fBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec2fBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2fBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec2fBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec2fBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec2fBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec2fBasicArray_front(self)

    def back(self):
        return _base.GMathVec2fBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec2fBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec2fBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec2fBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec2fBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec2fBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2fBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec2fBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2fBasicArray_class_info)
    else:
        class_info = _base.GMathVec2fBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2fBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2fBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec2fBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2fBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec2fBasicArray_swigregister = _base.GMathVec2fBasicArray_swigregister
GMathVec2fBasicArray_swigregister(GMathVec2fBasicArray)

def GMathVec2fBasicArray_class_info():
    return _base.GMathVec2fBasicArray_class_info()
GMathVec2fBasicArray_class_info = _base.GMathVec2fBasicArray_class_info

def GMathVec2fBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec2fBasicArray____class_destructor__(instance, is_array)
GMathVec2fBasicArray____class_destructor__ = _base.GMathVec2fBasicArray____class_destructor__

class GMathVec2fArray(GMathVec2fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2fArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2fArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2fArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2fArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2fArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec2fArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec2fArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec2fArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2fArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2fArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2fArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2fArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec2fArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2fArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2fArray_class_info)
    else:
        class_info = _base.GMathVec2fArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2fArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2fArray____class_destructor__
GMathVec2fArray_swigregister = _base.GMathVec2fArray_swigregister
GMathVec2fArray_swigregister(GMathVec2fArray)

def GMathVec2fArray_class_info():
    return _base.GMathVec2fArray_class_info()
GMathVec2fArray_class_info = _base.GMathVec2fArray_class_info

def GMathVec2fArray____class_destructor__(instance, is_array):
    return _base.GMathVec2fArray____class_destructor__(instance, is_array)
GMathVec2fArray____class_destructor__ = _base.GMathVec2fArray____class_destructor__

class GMathVec2fVector(GMathVec2fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2fVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2fVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2fVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2fVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2fVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec2fVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec2fVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec2fVector_remove_last(self)

    def empty(self):
        return _base.GMathVec2fVector_empty(self)

    def remove_all(self):
        return _base.GMathVec2fVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec2fVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec2fVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec2fVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec2fVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec2fVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec2fVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec2fVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec2fVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec2fVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec2fVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec2fVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec2fVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec2fVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2fVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2fVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2fVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2fVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec2fVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec2fVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec2fVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec2fVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec2fVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2fVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2fVector_class_info)
    else:
        class_info = _base.GMathVec2fVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2fVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2fVector____class_destructor__
GMathVec2fVector_swigregister = _base.GMathVec2fVector_swigregister
GMathVec2fVector_swigregister(GMathVec2fVector)

def GMathVec2fVector_class_info():
    return _base.GMathVec2fVector_class_info()
GMathVec2fVector_class_info = _base.GMathVec2fVector_class_info

def GMathVec2fVector____class_destructor__(instance, is_array):
    return _base.GMathVec2fVector____class_destructor__(instance, is_array)
GMathVec2fVector____class_destructor__ = _base.GMathVec2fVector____class_destructor__

class GMathVec2fSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2fSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2fSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2fSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec2fSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec2fSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec2fSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec2fSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec2fSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec2fSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec2fSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec2fSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec2fSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec2fSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec2fSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec2fSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec2fSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec2fSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec2fSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec2fSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec2fSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec2fSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec2fSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2fSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec2fSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec2fSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2fSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec2fSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec2fSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec2fSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2fSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2fSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2fSet
    __del__ = lambda self: None
GMathVec2fSet_swigregister = _base.GMathVec2fSet_swigregister
GMathVec2fSet_swigregister(GMathVec2fSet)

def GMathVec2fSet_get_linear_search_threshold():
    return _base.GMathVec2fSet_get_linear_search_threshold()
GMathVec2fSet_get_linear_search_threshold = _base.GMathVec2fSet_get_linear_search_threshold

class GMathVec3fBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3fBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3fBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec3fBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec3fBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3fBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec3fBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec3fBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec3fBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec3fBasicArray_front(self)

    def back(self):
        return _base.GMathVec3fBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec3fBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec3fBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec3fBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec3fBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec3fBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3fBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec3fBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3fBasicArray_class_info)
    else:
        class_info = _base.GMathVec3fBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3fBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3fBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec3fBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3fBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec3fBasicArray_swigregister = _base.GMathVec3fBasicArray_swigregister
GMathVec3fBasicArray_swigregister(GMathVec3fBasicArray)

def GMathVec3fBasicArray_class_info():
    return _base.GMathVec3fBasicArray_class_info()
GMathVec3fBasicArray_class_info = _base.GMathVec3fBasicArray_class_info

def GMathVec3fBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec3fBasicArray____class_destructor__(instance, is_array)
GMathVec3fBasicArray____class_destructor__ = _base.GMathVec3fBasicArray____class_destructor__

class GMathVec3fArray(GMathVec3fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3fArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3fArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3fArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3fArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3fArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec3fArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec3fArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec3fArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3fArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3fArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3fArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3fArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec3fArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3fArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3fArray_class_info)
    else:
        class_info = _base.GMathVec3fArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3fArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3fArray____class_destructor__
GMathVec3fArray_swigregister = _base.GMathVec3fArray_swigregister
GMathVec3fArray_swigregister(GMathVec3fArray)

def GMathVec3fArray_class_info():
    return _base.GMathVec3fArray_class_info()
GMathVec3fArray_class_info = _base.GMathVec3fArray_class_info

def GMathVec3fArray____class_destructor__(instance, is_array):
    return _base.GMathVec3fArray____class_destructor__(instance, is_array)
GMathVec3fArray____class_destructor__ = _base.GMathVec3fArray____class_destructor__

class GMathVec3fVector(GMathVec3fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3fVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3fVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3fVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3fVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3fVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec3fVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec3fVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec3fVector_remove_last(self)

    def empty(self):
        return _base.GMathVec3fVector_empty(self)

    def remove_all(self):
        return _base.GMathVec3fVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec3fVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec3fVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec3fVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec3fVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec3fVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec3fVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec3fVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec3fVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec3fVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec3fVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec3fVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec3fVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec3fVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3fVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3fVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3fVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3fVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec3fVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec3fVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec3fVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec3fVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec3fVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3fVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3fVector_class_info)
    else:
        class_info = _base.GMathVec3fVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3fVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3fVector____class_destructor__
GMathVec3fVector_swigregister = _base.GMathVec3fVector_swigregister
GMathVec3fVector_swigregister(GMathVec3fVector)

def GMathVec3fVector_class_info():
    return _base.GMathVec3fVector_class_info()
GMathVec3fVector_class_info = _base.GMathVec3fVector_class_info

def GMathVec3fVector____class_destructor__(instance, is_array):
    return _base.GMathVec3fVector____class_destructor__(instance, is_array)
GMathVec3fVector____class_destructor__ = _base.GMathVec3fVector____class_destructor__

class GMathVec3fSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3fSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3fSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3fSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec3fSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec3fSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec3fSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec3fSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec3fSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec3fSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec3fSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec3fSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec3fSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec3fSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec3fSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec3fSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec3fSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec3fSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec3fSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec3fSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec3fSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec3fSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec3fSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3fSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec3fSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec3fSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3fSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec3fSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec3fSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec3fSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3fSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3fSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3fSet
    __del__ = lambda self: None
GMathVec3fSet_swigregister = _base.GMathVec3fSet_swigregister
GMathVec3fSet_swigregister(GMathVec3fSet)

def GMathVec3fSet_get_linear_search_threshold():
    return _base.GMathVec3fSet_get_linear_search_threshold()
GMathVec3fSet_get_linear_search_threshold = _base.GMathVec3fSet_get_linear_search_threshold

class GMathVec4fBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4fBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4fBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec4fBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec4fBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4fBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec4fBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec4fBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec4fBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec4fBasicArray_front(self)

    def back(self):
        return _base.GMathVec4fBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec4fBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec4fBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec4fBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec4fBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec4fBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4fBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec4fBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4fBasicArray_class_info)
    else:
        class_info = _base.GMathVec4fBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4fBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4fBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec4fBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4fBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec4fBasicArray_swigregister = _base.GMathVec4fBasicArray_swigregister
GMathVec4fBasicArray_swigregister(GMathVec4fBasicArray)

def GMathVec4fBasicArray_class_info():
    return _base.GMathVec4fBasicArray_class_info()
GMathVec4fBasicArray_class_info = _base.GMathVec4fBasicArray_class_info

def GMathVec4fBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec4fBasicArray____class_destructor__(instance, is_array)
GMathVec4fBasicArray____class_destructor__ = _base.GMathVec4fBasicArray____class_destructor__

class GMathVec4fArray(GMathVec4fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4fArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4fArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4fArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4fArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4fArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec4fArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec4fArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec4fArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4fArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4fArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4fArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4fArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec4fArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4fArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4fArray_class_info)
    else:
        class_info = _base.GMathVec4fArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4fArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4fArray____class_destructor__
GMathVec4fArray_swigregister = _base.GMathVec4fArray_swigregister
GMathVec4fArray_swigregister(GMathVec4fArray)

def GMathVec4fArray_class_info():
    return _base.GMathVec4fArray_class_info()
GMathVec4fArray_class_info = _base.GMathVec4fArray_class_info

def GMathVec4fArray____class_destructor__(instance, is_array):
    return _base.GMathVec4fArray____class_destructor__(instance, is_array)
GMathVec4fArray____class_destructor__ = _base.GMathVec4fArray____class_destructor__

class GMathVec4fVector(GMathVec4fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4fVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4fVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4fVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4fVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4fVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec4fVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec4fVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec4fVector_remove_last(self)

    def empty(self):
        return _base.GMathVec4fVector_empty(self)

    def remove_all(self):
        return _base.GMathVec4fVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec4fVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec4fVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec4fVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec4fVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec4fVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec4fVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec4fVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec4fVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec4fVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec4fVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec4fVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec4fVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec4fVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4fVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4fVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4fVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4fVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec4fVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec4fVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec4fVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec4fVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec4fVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4fVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4fVector_class_info)
    else:
        class_info = _base.GMathVec4fVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4fVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4fVector____class_destructor__
GMathVec4fVector_swigregister = _base.GMathVec4fVector_swigregister
GMathVec4fVector_swigregister(GMathVec4fVector)

def GMathVec4fVector_class_info():
    return _base.GMathVec4fVector_class_info()
GMathVec4fVector_class_info = _base.GMathVec4fVector_class_info

def GMathVec4fVector____class_destructor__(instance, is_array):
    return _base.GMathVec4fVector____class_destructor__(instance, is_array)
GMathVec4fVector____class_destructor__ = _base.GMathVec4fVector____class_destructor__

class GMathVec4fSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4fSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4fSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4fSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec4fSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec4fSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec4fSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec4fSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec4fSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec4fSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec4fSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec4fSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec4fSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec4fSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec4fSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec4fSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec4fSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec4fSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec4fSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec4fSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec4fSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec4fSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec4fSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec4fSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec4fSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec4fSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4fSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec4fSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec4fSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec4fSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4fSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4fSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4fSet
    __del__ = lambda self: None
GMathVec4fSet_swigregister = _base.GMathVec4fSet_swigregister
GMathVec4fSet_swigregister(GMathVec4fSet)

def GMathVec4fSet_get_linear_search_threshold():
    return _base.GMathVec4fSet_get_linear_search_threshold()
GMathVec4fSet_get_linear_search_threshold = _base.GMathVec4fSet_get_linear_search_threshold

class GMathVec2d(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2d, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2d, name)

    def __init__(self, *args):
        this = _base.new_GMathVec2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec2d_nullify(self)

    def get_value(self, index):
        return _base.GMathVec2d_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec2d_set_value(self, index, value)

    def get_width(self):
        return _base.GMathVec2d_get_width(self)

    def set_width(self, width):
        return _base.GMathVec2d_set_width(self, width)

    def get_height(self):
        return _base.GMathVec2d_get_height(self)

    def set_height(self, height):
        return _base.GMathVec2d_set_height(self, height)

    def get_x(self):
        return _base.GMathVec2d_get_x(self)

    def set_x(self, x):
        return _base.GMathVec2d_set_x(self, x)

    def get_y(self):
        return _base.GMathVec2d_get_y(self)

    def set_y(self, y):
        return _base.GMathVec2d_set_y(self, y)

    def get_red(self):
        return _base.GMathVec2d_get_red(self)

    def get_u(self):
        return _base.GMathVec2d_get_u(self)

    def set_u(self, u):
        return _base.GMathVec2d_set_u(self, u)

    def get_v(self):
        return _base.GMathVec2d_get_v(self)

    def set_v(self, v):
        return _base.GMathVec2d_set_v(self, v)

    def sub(self, *args):
        return _base.GMathVec2d_sub(self, *args)

    def absolute(self):
        return _base.GMathVec2d_absolute(self)

    def get_sqr_length(self):
        return _base.GMathVec2d_get_sqr_length(self)

    def get_length(self):
        return _base.GMathVec2d_get_length(self)

    def get_max_norm_signed(self):
        return _base.GMathVec2d_get_max_norm_signed(self)

    def get_max_norm(self):
        return _base.GMathVec2d_get_max_norm(self)

    def normalize(self, *args):
        return _base.GMathVec2d_normalize(self, *args)

    def get_copy(self):
        return _base.GMathVec2d_get_copy(self)

    def copy_from(self, v):
        return _base.GMathVec2d_copy_from(self, v)

    def copy_to(self, v):
        return _base.GMathVec2d_copy_to(self, v)

    def is_null(self, *args):
        return _base.GMathVec2d_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec2d_is_finite(self)

    def __eq__(self, v):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2d___eq__(self, v)


    def __ne__(self, v):
        return _base.GMathVec2d___ne__(self, v)

    def __iadd__(self, *args):
        return _base.GMathVec2d___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec2d___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec2d___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec2d___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec2d___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec2d___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec2d___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec2d___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec2d___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec2d_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2d_class_info)
    else:
        class_info = _base.GMathVec2d_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec2d_register_methods)
    else:
        register_methods = _base.GMathVec2d_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2d____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2d____class_destructor__

    def __repr__(self):
        return _base.GMathVec2d___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2d___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec2d___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec2d___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2d
    __del__ = lambda self: None
GMathVec2d_swigregister = _base.GMathVec2d_swigregister
GMathVec2d_swigregister(GMathVec2d)

def GMathVec2d_class_info():
    return _base.GMathVec2d_class_info()
GMathVec2d_class_info = _base.GMathVec2d_class_info

def GMathVec2d_register_methods(arg2):
    return _base.GMathVec2d_register_methods(arg2)
GMathVec2d_register_methods = _base.GMathVec2d_register_methods

def GMathVec2d____class_destructor__(instance, is_array):
    return _base.GMathVec2d____class_destructor__(instance, is_array)
GMathVec2d____class_destructor__ = _base.GMathVec2d____class_destructor__

class GMathVec3d(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3d, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3d, name)
    if _newclass:
        create_local_axis = staticmethod(_base.GMathVec3d_create_local_axis)
    else:
        create_local_axis = _base.GMathVec3d_create_local_axis

    def __init__(self, *args):
        this = _base.new_GMathVec3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec3d_nullify(self)

    def get_copy(self):
        return _base.GMathVec3d_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec3d_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec3d_copy_to(self, u)

    def __ne__(self, *args):
        return _base.GMathVec3d___ne__(self, *args)

    def __eq__(self, *args):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3d___eq__(self, *args)


    def __lt__(self, *args):
        return _base.GMathVec3d___lt__(self, *args)

    def __gt__(self, *args):
        return _base.GMathVec3d___gt__(self, *args)

    def __le__(self, *args):
        return _base.GMathVec3d___le__(self, *args)

    def __ge__(self, *args):
        return _base.GMathVec3d___ge__(self, *args)

    def absolute(self):
        return _base.GMathVec3d_absolute(self)

    def get_sqr_norm(self, *args):
        return _base.GMathVec3d_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec3d_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec3d_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec3d_get_length(self, *args)

    def get_l1_norm_signed(self, *args):
        return _base.GMathVec3d_get_l1_norm_signed(self, *args)

    def get_l1_norm(self, *args):
        return _base.GMathVec3d_get_l1_norm(self, *args)

    def get_max_norm_signed(self, *args):
        return _base.GMathVec3d_get_max_norm_signed(self, *args)

    def get_max_norm(self, *args):
        return _base.GMathVec3d_get_max_norm(self, *args)

    def get_min_norm_signed(self, *args):
        return _base.GMathVec3d_get_min_norm_signed(self, *args)

    def get_min_norm(self, *args):
        return _base.GMathVec3d_get_min_norm(self, *args)

    def scale(self, s):
        return _base.GMathVec3d_scale(self, s)

    def get_main_axis(self):
        return _base.GMathVec3d_get_main_axis(self)

    def normalize(self, *args):
        return _base.GMathVec3d_normalize(self, *args)

    def is_null(self, *args):
        return _base.GMathVec3d_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec3d_is_finite(self)

    def get_data(self, *args):
        return _base.GMathVec3d_get_data(self, *args)

    def __iadd__(self, *args):
        return _base.GMathVec3d___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec3d___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec3d___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec3d___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec3d___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec3d___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec3d___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec3d___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec3d___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec3d_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3d_class_info)
    else:
        class_info = _base.GMathVec3d_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec3d_register_methods)
    else:
        register_methods = _base.GMathVec3d_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3d____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3d____class_destructor__

    def __repr__(self):
        return _base.GMathVec3d___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3d___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec3d___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec3d___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3d
    __del__ = lambda self: None
GMathVec3d_swigregister = _base.GMathVec3d_swigregister
GMathVec3d_swigregister(GMathVec3d)

def GMathVec3d_create_local_axis(v1, v2, v3):
    return _base.GMathVec3d_create_local_axis(v1, v2, v3)
GMathVec3d_create_local_axis = _base.GMathVec3d_create_local_axis

def GMathVec3d_class_info():
    return _base.GMathVec3d_class_info()
GMathVec3d_class_info = _base.GMathVec3d_class_info

def GMathVec3d_register_methods(cls):
    return _base.GMathVec3d_register_methods(cls)
GMathVec3d_register_methods = _base.GMathVec3d_register_methods

def GMathVec3d____class_destructor__(instance, is_array):
    return _base.GMathVec3d____class_destructor__(instance, is_array)
GMathVec3d____class_destructor__ = _base.GMathVec3d____class_destructor__

class GMathVec4d(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4d, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4d, name)

    def __init__(self, *args):
        this = _base.new_GMathVec4d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def nullify(self):
        return _base.GMathVec4d_nullify(self)

    def get_copy(self):
        return _base.GMathVec4d_get_copy(self)

    def copy_from(self, u):
        return _base.GMathVec4d_copy_from(self, u)

    def copy_to(self, u):
        return _base.GMathVec4d_copy_to(self, u)

    def get_value(self, index):
        return _base.GMathVec4d_get_value(self, index)

    def set_value(self, index, value):
        return _base.GMathVec4d_set_value(self, index, value)

    def get_x(self):
        return _base.GMathVec4d_get_x(self)

    def set_x(self, x):
        return _base.GMathVec4d_set_x(self, x)

    def get_y(self):
        return _base.GMathVec4d_get_y(self)

    def set_y(self, y):
        return _base.GMathVec4d_set_y(self, y)

    def get_z(self):
        return _base.GMathVec4d_get_z(self)

    def set_z(self, z):
        return _base.GMathVec4d_set_z(self, z)

    def get_w(self):
        return _base.GMathVec4d_get_w(self)

    def set_w(self, w):
        return _base.GMathVec4d_set_w(self, w)

    def get_red(self):
        return _base.GMathVec4d_get_red(self)

    def set_red(self, red):
        return _base.GMathVec4d_set_red(self, red)

    def get_green(self):
        return _base.GMathVec4d_get_green(self)

    def set_green(self, green):
        return _base.GMathVec4d_set_green(self, green)

    def get_blue(self):
        return _base.GMathVec4d_get_blue(self)

    def set_blue(self, blue):
        return _base.GMathVec4d_set_blue(self, blue)

    def get_alpha(self):
        return _base.GMathVec4d_get_alpha(self)

    def set_alpha(self, alpha):
        return _base.GMathVec4d_set_alpha(self, alpha)

    def get_sqr_norm(self, *args):
        return _base.GMathVec4d_get_sqr_norm(self, *args)

    def get_sqr_length(self, *args):
        return _base.GMathVec4d_get_sqr_length(self, *args)

    def get_norm(self, *args):
        return _base.GMathVec4d_get_norm(self, *args)

    def get_length(self, *args):
        return _base.GMathVec4d_get_length(self, *args)

    def sub(self, *args):
        return _base.GMathVec4d_sub(self, *args)

    def get_data(self, *args):
        return _base.GMathVec4d_get_data(self, *args)

    def is_null(self, *args):
        return _base.GMathVec4d_is_null(self, *args)

    def is_finite(self):
        return _base.GMathVec4d_is_finite(self)

    def __iadd__(self, *args):
        return _base.GMathVec4d___iadd__(self, *args)

    def __add__(self, *args):
        return _base.GMathVec4d___add__(self, *args)

    def __isub__(self, *args):
        return _base.GMathVec4d___isub__(self, *args)

    def __neg__(self):
        return _base.GMathVec4d___neg__(self)

    def __sub__(self, *args):
        return _base.GMathVec4d___sub__(self, *args)

    def __imul__(self, *args):
        return _base.GMathVec4d___imul__(self, *args)

    def __mul__(self, *args):
        return _base.GMathVec4d___mul__(self, *args)

    def __itruediv__(self, *args):
        return _base.GMathVec4d___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def __truediv__(self, *args):
        return _base.GMathVec4d___truediv__(self, *args)
    __div__ = __truediv__



    def get_class_info(self):
        return _base.GMathVec4d_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4d_class_info)
    else:
        class_info = _base.GMathVec4d_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathVec4d_register_methods)
    else:
        register_methods = _base.GMathVec4d_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4d____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4d____class_destructor__

    def __repr__(self):
        return _base.GMathVec4d___repr__(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4d___setitem__(self, index, value)

    def __getitem__(self, index):
        return _base.GMathVec4d___getitem__(self, index)

    def __len__(self):
        return _base.GMathVec4d___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4d
    __del__ = lambda self: None
GMathVec4d_swigregister = _base.GMathVec4d_swigregister
GMathVec4d_swigregister(GMathVec4d)

def GMathVec4d_class_info():
    return _base.GMathVec4d_class_info()
GMathVec4d_class_info = _base.GMathVec4d_class_info

def GMathVec4d_register_methods(cls):
    return _base.GMathVec4d_register_methods(cls)
GMathVec4d_register_methods = _base.GMathVec4d_register_methods

def GMathVec4d____class_destructor__(instance, is_array):
    return _base.GMathVec4d____class_destructor__(instance, is_array)
GMathVec4d____class_destructor__ = _base.GMathVec4d____class_destructor__

class GMathVec2dBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2dBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2dBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec2dBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec2dBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2dBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec2dBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec2dBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec2dBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec2dBasicArray_front(self)

    def back(self):
        return _base.GMathVec2dBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec2dBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec2dBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec2dBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec2dBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec2dBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2dBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec2dBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2dBasicArray_class_info)
    else:
        class_info = _base.GMathVec2dBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2dBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2dBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec2dBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2dBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec2dBasicArray_swigregister = _base.GMathVec2dBasicArray_swigregister
GMathVec2dBasicArray_swigregister(GMathVec2dBasicArray)

def GMathVec2dBasicArray_class_info():
    return _base.GMathVec2dBasicArray_class_info()
GMathVec2dBasicArray_class_info = _base.GMathVec2dBasicArray_class_info

def GMathVec2dBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec2dBasicArray____class_destructor__(instance, is_array)
GMathVec2dBasicArray____class_destructor__ = _base.GMathVec2dBasicArray____class_destructor__

class GMathVec2dArray(GMathVec2dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2dArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2dArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2dArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2dArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2dArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec2dArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec2dArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec2dArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2dArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2dArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2dArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2dArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec2dArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2dArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2dArray_class_info)
    else:
        class_info = _base.GMathVec2dArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2dArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2dArray____class_destructor__
GMathVec2dArray_swigregister = _base.GMathVec2dArray_swigregister
GMathVec2dArray_swigregister(GMathVec2dArray)

def GMathVec2dArray_class_info():
    return _base.GMathVec2dArray_class_info()
GMathVec2dArray_class_info = _base.GMathVec2dArray_class_info

def GMathVec2dArray____class_destructor__(instance, is_array):
    return _base.GMathVec2dArray____class_destructor__(instance, is_array)
GMathVec2dArray____class_destructor__ = _base.GMathVec2dArray____class_destructor__

class GMathVec2dVector(GMathVec2dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec2dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2dVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec2dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2dVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2dVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec2dVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec2dVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec2dVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec2dVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec2dVector_remove_last(self)

    def empty(self):
        return _base.GMathVec2dVector_empty(self)

    def remove_all(self):
        return _base.GMathVec2dVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec2dVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec2dVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec2dVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec2dVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec2dVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec2dVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec2dVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec2dVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec2dVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec2dVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec2dVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec2dVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec2dVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec2dVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec2dVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec2dVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec2dVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec2dVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec2dVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec2dVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec2dVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec2dVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec2dVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec2dVector_class_info)
    else:
        class_info = _base.GMathVec2dVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec2dVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec2dVector____class_destructor__
GMathVec2dVector_swigregister = _base.GMathVec2dVector_swigregister
GMathVec2dVector_swigregister(GMathVec2dVector)

def GMathVec2dVector_class_info():
    return _base.GMathVec2dVector_class_info()
GMathVec2dVector_class_info = _base.GMathVec2dVector_class_info

def GMathVec2dVector____class_destructor__(instance, is_array):
    return _base.GMathVec2dVector____class_destructor__(instance, is_array)
GMathVec2dVector____class_destructor__ = _base.GMathVec2dVector____class_destructor__

class GMathVec2dSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec2dSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec2dSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec2dSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec2dSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec2dSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec2dSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec2dSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec2dSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec2dSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec2dSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec2dSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec2dSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec2dSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec2dSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec2dSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec2dSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec2dSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec2dSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec2dSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec2dSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec2dSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec2dSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec2dSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec2dSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec2dSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec2dSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec2dSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec2dSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec2dSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec2dSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec2dSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec2dSet
    __del__ = lambda self: None
GMathVec2dSet_swigregister = _base.GMathVec2dSet_swigregister
GMathVec2dSet_swigregister(GMathVec2dSet)

def GMathVec2dSet_get_linear_search_threshold():
    return _base.GMathVec2dSet_get_linear_search_threshold()
GMathVec2dSet_get_linear_search_threshold = _base.GMathVec2dSet_get_linear_search_threshold

class GMathVec3dBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3dBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3dBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec3dBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec3dBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3dBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec3dBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec3dBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec3dBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec3dBasicArray_front(self)

    def back(self):
        return _base.GMathVec3dBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec3dBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec3dBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec3dBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec3dBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec3dBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3dBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec3dBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3dBasicArray_class_info)
    else:
        class_info = _base.GMathVec3dBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3dBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3dBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec3dBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3dBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec3dBasicArray_swigregister = _base.GMathVec3dBasicArray_swigregister
GMathVec3dBasicArray_swigregister(GMathVec3dBasicArray)

def GMathVec3dBasicArray_class_info():
    return _base.GMathVec3dBasicArray_class_info()
GMathVec3dBasicArray_class_info = _base.GMathVec3dBasicArray_class_info

def GMathVec3dBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec3dBasicArray____class_destructor__(instance, is_array)
GMathVec3dBasicArray____class_destructor__ = _base.GMathVec3dBasicArray____class_destructor__

class GMathVec3dArray(GMathVec3dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3dArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3dArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3dArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3dArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3dArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec3dArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec3dArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec3dArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3dArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3dArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3dArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3dArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec3dArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3dArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3dArray_class_info)
    else:
        class_info = _base.GMathVec3dArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3dArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3dArray____class_destructor__
GMathVec3dArray_swigregister = _base.GMathVec3dArray_swigregister
GMathVec3dArray_swigregister(GMathVec3dArray)

def GMathVec3dArray_class_info():
    return _base.GMathVec3dArray_class_info()
GMathVec3dArray_class_info = _base.GMathVec3dArray_class_info

def GMathVec3dArray____class_destructor__(instance, is_array):
    return _base.GMathVec3dArray____class_destructor__(instance, is_array)
GMathVec3dArray____class_destructor__ = _base.GMathVec3dArray____class_destructor__

class GMathVec3dVector(GMathVec3dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec3dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3dVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec3dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3dVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3dVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec3dVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec3dVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec3dVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec3dVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec3dVector_remove_last(self)

    def empty(self):
        return _base.GMathVec3dVector_empty(self)

    def remove_all(self):
        return _base.GMathVec3dVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec3dVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec3dVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec3dVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec3dVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec3dVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec3dVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec3dVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec3dVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec3dVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec3dVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec3dVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec3dVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec3dVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec3dVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec3dVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec3dVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec3dVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec3dVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec3dVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec3dVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec3dVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec3dVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec3dVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec3dVector_class_info)
    else:
        class_info = _base.GMathVec3dVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec3dVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec3dVector____class_destructor__
GMathVec3dVector_swigregister = _base.GMathVec3dVector_swigregister
GMathVec3dVector_swigregister(GMathVec3dVector)

def GMathVec3dVector_class_info():
    return _base.GMathVec3dVector_class_info()
GMathVec3dVector_class_info = _base.GMathVec3dVector_class_info

def GMathVec3dVector____class_destructor__(instance, is_array):
    return _base.GMathVec3dVector____class_destructor__(instance, is_array)
GMathVec3dVector____class_destructor__ = _base.GMathVec3dVector____class_destructor__

class GMathVec3dSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec3dSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec3dSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec3dSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec3dSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec3dSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec3dSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec3dSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec3dSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec3dSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec3dSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec3dSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec3dSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec3dSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec3dSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec3dSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec3dSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec3dSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec3dSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec3dSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec3dSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec3dSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec3dSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec3dSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec3dSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec3dSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec3dSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec3dSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec3dSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec3dSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec3dSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec3dSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec3dSet
    __del__ = lambda self: None
GMathVec3dSet_swigregister = _base.GMathVec3dSet_swigregister
GMathVec3dSet_swigregister(GMathVec3dSet)

def GMathVec3dSet_get_linear_search_threshold():
    return _base.GMathVec3dSet_get_linear_search_threshold()
GMathVec3dSet_get_linear_search_threshold = _base.GMathVec3dSet_get_linear_search_threshold

class GMathVec4dBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4dBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4dBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathVec4dBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathVec4dBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4dBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathVec4dBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathVec4dBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathVec4dBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathVec4dBasicArray_front(self)

    def back(self):
        return _base.GMathVec4dBasicArray_back(self)

    def exists(self, item):
        return _base.GMathVec4dBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathVec4dBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathVec4dBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathVec4dBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathVec4dBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4dBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathVec4dBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4dBasicArray_class_info)
    else:
        class_info = _base.GMathVec4dBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4dBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4dBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathVec4dBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4dBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathVec4dBasicArray_swigregister = _base.GMathVec4dBasicArray_swigregister
GMathVec4dBasicArray_swigregister(GMathVec4dBasicArray)

def GMathVec4dBasicArray_class_info():
    return _base.GMathVec4dBasicArray_class_info()
GMathVec4dBasicArray_class_info = _base.GMathVec4dBasicArray_class_info

def GMathVec4dBasicArray____class_destructor__(instance, is_array):
    return _base.GMathVec4dBasicArray____class_destructor__(instance, is_array)
GMathVec4dBasicArray____class_destructor__ = _base.GMathVec4dBasicArray____class_destructor__

class GMathVec4dArray(GMathVec4dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4dArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4dArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4dArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4dArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4dArray_append(self, *args)

    def get_count(self):
        return _base.GMathVec4dArray_get_count(self)

    def remove_all(self):
        return _base.GMathVec4dArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathVec4dArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4dArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4dArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4dArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4dArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathVec4dArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4dArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4dArray_class_info)
    else:
        class_info = _base.GMathVec4dArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4dArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4dArray____class_destructor__
GMathVec4dArray_swigregister = _base.GMathVec4dArray_swigregister
GMathVec4dArray_swigregister(GMathVec4dArray)

def GMathVec4dArray_class_info():
    return _base.GMathVec4dArray_class_info()
GMathVec4dArray_class_info = _base.GMathVec4dArray_class_info

def GMathVec4dArray____class_destructor__(instance, is_array):
    return _base.GMathVec4dArray____class_destructor__(instance, is_array)
GMathVec4dArray____class_destructor__ = _base.GMathVec4dArray____class_destructor__

class GMathVec4dVector(GMathVec4dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathVec4dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4dVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathVec4dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4dVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4dVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathVec4dVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathVec4dVector_append(self, *args)

    def add(self, element):
        return _base.GMathVec4dVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathVec4dVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathVec4dVector_remove_last(self)

    def empty(self):
        return _base.GMathVec4dVector_empty(self)

    def remove_all(self):
        return _base.GMathVec4dVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathVec4dVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathVec4dVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathVec4dVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathVec4dVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathVec4dVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathVec4dVector_get_count(self)

    def get_capacity(self):
        return _base.GMathVec4dVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathVec4dVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathVec4dVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathVec4dVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathVec4dVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathVec4dVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathVec4dVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathVec4dVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathVec4dVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathVec4dVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathVec4dVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathVec4dVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathVec4dVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathVec4dVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathVec4dVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathVec4dVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathVec4dVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathVec4dVector_class_info)
    else:
        class_info = _base.GMathVec4dVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathVec4dVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathVec4dVector____class_destructor__
GMathVec4dVector_swigregister = _base.GMathVec4dVector_swigregister
GMathVec4dVector_swigregister(GMathVec4dVector)

def GMathVec4dVector_class_info():
    return _base.GMathVec4dVector_class_info()
GMathVec4dVector_class_info = _base.GMathVec4dVector_class_info

def GMathVec4dVector____class_destructor__(instance, is_array):
    return _base.GMathVec4dVector____class_destructor__(instance, is_array)
GMathVec4dVector____class_destructor__ = _base.GMathVec4dVector____class_destructor__

class GMathVec4dSet(CoreBaseObject):
    __swig_setmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathVec4dSet, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathVec4dSet, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathVec4dSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_count(self):
        return _base.GMathVec4dSet_get_count(self)

    def exists(self, *args):
        return _base.GMathVec4dSet_exists(self, *args)

    def is_empty(self):
        return _base.GMathVec4dSet_is_empty(self)

    def is_included(self, set):
        return _base.GMathVec4dSet_is_included(self, set)

    def get_items(self):
        return _base.GMathVec4dSet_get_items(self)

    def get_item(self, index):
        return _base.GMathVec4dSet_get_item(self, index)

    def back(self, *args):
        return _base.GMathVec4dSet_back(self, *args)

    def get_array(self, array):
        return _base.GMathVec4dSet_get_array(self, array)

    def get_list(self, list):
        return _base.GMathVec4dSet_get_list(self, list)

    def get_vector(self, vector):
        return _base.GMathVec4dSet_get_vector(self, vector)

    def to_array(self):
        return _base.GMathVec4dSet_to_array(self)

    def add(self, *args):
        return _base.GMathVec4dSet_add(self, *args)

    def remove(self, index):
        return _base.GMathVec4dSet_remove(self, index)

    def remove_item(self, item):
        return _base.GMathVec4dSet_remove_item(self, item)

    def remove_set(self, set):
        return _base.GMathVec4dSet_remove_set(self, set)

    def remove_all(self):
        return _base.GMathVec4dSet_remove_all(self)

    def toggle(self, item):
        return _base.GMathVec4dSet_toggle(self, item)

    def unite(self, set):
        return _base.GMathVec4dSet_unite(self, set)

    def intersect(self, set):
        return _base.GMathVec4dSet_intersect(self, set)

    def __eq__(self, set):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathVec4dSet___eq__(self, set)


    def __ne__(self, set):
        return _base.GMathVec4dSet___ne__(self, set)

    def begin(self, *args):
        return _base.GMathVec4dSet_begin(self, *args)

    def end(self, *args):
        return _base.GMathVec4dSet_end(self, *args)
    if _newclass:
        get_linear_search_threshold = staticmethod(_base.GMathVec4dSet_get_linear_search_threshold)
    else:
        get_linear_search_threshold = _base.GMathVec4dSet_get_linear_search_threshold

    def get_memory_size(self):
        return _base.GMathVec4dSet_get_memory_size(self)

    def __setitem__(self, index, value):
        return _base.GMathVec4dSet___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathVec4dSet___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathVec4dSet
    __del__ = lambda self: None
GMathVec4dSet_swigregister = _base.GMathVec4dSet_swigregister
GMathVec4dSet_swigregister(GMathVec4dSet)

def GMathVec4dSet_get_linear_search_threshold():
    return _base.GMathVec4dSet_get_linear_search_threshold()
GMathVec4dSet_get_linear_search_threshold = _base.GMathVec4dSet_get_linear_search_threshold

class GMathBbox2f(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox2f, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox2f, name)

    def __init__(self, *args):
        this = _base.new_GMathBbox2f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_copy(self):
        return _base.GMathBbox2f_get_copy(self)

    def copy_from(self, bbox):
        return _base.GMathBbox2f_copy_from(self, bbox)

    def copy_to(self, bbox):
        return _base.GMathBbox2f_copy_to(self, bbox)

    def get_center(self):
        return _base.GMathBbox2f_get_center(self)

    def intersect(self, *args):
        return _base.GMathBbox2f_intersect(self, *args)

    def compute_interpolated_bbox(self, time, start_bbox, end_bbox):
        return _base.GMathBbox2f_compute_interpolated_bbox(self, time, start_bbox, end_bbox)

    def get_corner_vertices(self, vertices):
        return _base.GMathBbox2f_get_corner_vertices(self, vertices)

    def compute_area(self):
        return _base.GMathBbox2f_compute_area(self)

    def is_empty(self):
        return _base.GMathBbox2f_is_empty(self)

    def get_item(self, x, y):
        return _base.GMathBbox2f_get_item(self, x, y)

    def set_item(self, x, y, value):
        return _base.GMathBbox2f_set_item(self, x, y, value)

    def get_class_info(self):
        return _base.GMathBbox2f_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox2f_class_info)
    else:
        class_info = _base.GMathBbox2f_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathBbox2f_register_methods)
    else:
        register_methods = _base.GMathBbox2f_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox2f____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox2f____class_destructor__

    def __repr__(self):
        return _base.GMathBbox2f___repr__(self)

    def __getitem__(self, index):
        return _base.GMathBbox2f___getitem__(self, index)

    def __len__(self):
        return _base.GMathBbox2f___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathBbox2f
    __del__ = lambda self: None
GMathBbox2f_swigregister = _base.GMathBbox2f_swigregister
GMathBbox2f_swigregister(GMathBbox2f)

def GMathBbox2f_class_info():
    return _base.GMathBbox2f_class_info()
GMathBbox2f_class_info = _base.GMathBbox2f_class_info

def GMathBbox2f_register_methods(cls):
    return _base.GMathBbox2f_register_methods(cls)
GMathBbox2f_register_methods = _base.GMathBbox2f_register_methods

def GMathBbox2f____class_destructor__(instance, is_array):
    return _base.GMathBbox2f____class_destructor__(instance, is_array)
GMathBbox2f____class_destructor__ = _base.GMathBbox2f____class_destructor__

class GMathBbox3f(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox3f, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox3f, name)

    def __init__(self):
        this = _base.new_GMathBbox3f()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_copy(self):
        return _base.GMathBbox3f_get_copy(self)

    def copy_from(self, bbox):
        return _base.GMathBbox3f_copy_from(self, bbox)

    def copy_to(self, bbox):
        return _base.GMathBbox3f_copy_to(self, bbox)

    def get_center(self):
        return _base.GMathBbox3f_get_center(self)

    def intersect(self, *args):
        return _base.GMathBbox3f_intersect(self, *args)

    def compute_interpolated_bbox(self, time, start_bbox, end_bbox):
        return _base.GMathBbox3f_compute_interpolated_bbox(self, time, start_bbox, end_bbox)

    def get_corner_vertices(self, vertices):
        return _base.GMathBbox3f_get_corner_vertices(self, vertices)

    def transform_bbox_and_get_bbox(self, matrix, result):
        return _base.GMathBbox3f_transform_bbox_and_get_bbox(self, matrix, result)

    def compute_volume(self):
        return _base.GMathBbox3f_compute_volume(self)

    def compute_area(self):
        return _base.GMathBbox3f_compute_area(self)

    def compute_surface_area(self):
        return _base.GMathBbox3f_compute_surface_area(self)

    def get_min(self, *args):
        return _base.GMathBbox3f_get_min(self, *args)

    def get_max(self, *args):
        return _base.GMathBbox3f_get_max(self, *args)

    def is_empty(self):
        return _base.GMathBbox3f_is_empty(self)

    def is_finite(self):
        return _base.GMathBbox3f_is_finite(self)

    def get_maximum_extent(self):
        return _base.GMathBbox3f_get_maximum_extent(self)

    def get_item(self, x, y):
        return _base.GMathBbox3f_get_item(self, x, y)

    def set_item(self, x, y, value):
        return _base.GMathBbox3f_set_item(self, x, y, value)

    def get_class_info(self):
        return _base.GMathBbox3f_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox3f_class_info)
    else:
        class_info = _base.GMathBbox3f_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathBbox3f_register_methods)
    else:
        register_methods = _base.GMathBbox3f_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox3f____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox3f____class_destructor__

    def __repr__(self):
        return _base.GMathBbox3f___repr__(self)

    def __getitem__(self, index):
        return _base.GMathBbox3f___getitem__(self, index)

    def __len__(self):
        return _base.GMathBbox3f___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathBbox3f
    __del__ = lambda self: None
GMathBbox3f_swigregister = _base.GMathBbox3f_swigregister
GMathBbox3f_swigregister(GMathBbox3f)
GMathBbox3f.s_empty_box = _base.cvar.GMathBbox3f_s_empty_box

def GMathBbox3f_class_info():
    return _base.GMathBbox3f_class_info()
GMathBbox3f_class_info = _base.GMathBbox3f_class_info

def GMathBbox3f_register_methods(cls):
    return _base.GMathBbox3f_register_methods(cls)
GMathBbox3f_register_methods = _base.GMathBbox3f_register_methods

def GMathBbox3f____class_destructor__(instance, is_array):
    return _base.GMathBbox3f____class_destructor__(instance, is_array)
GMathBbox3f____class_destructor__ = _base.GMathBbox3f____class_destructor__

class GMathBbox2fBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox2fBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox2fBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathBbox2fBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathBbox2fBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox2fBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathBbox2fBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathBbox2fBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathBbox2fBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathBbox2fBasicArray_front(self)

    def back(self):
        return _base.GMathBbox2fBasicArray_back(self)

    def exists(self, item):
        return _base.GMathBbox2fBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathBbox2fBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathBbox2fBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathBbox2fBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathBbox2fBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathBbox2fBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathBbox2fBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox2fBasicArray_class_info)
    else:
        class_info = _base.GMathBbox2fBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox2fBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox2fBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathBbox2fBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathBbox2fBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathBbox2fBasicArray_swigregister = _base.GMathBbox2fBasicArray_swigregister
GMathBbox2fBasicArray_swigregister(GMathBbox2fBasicArray)

def GMathBbox2fBasicArray_class_info():
    return _base.GMathBbox2fBasicArray_class_info()
GMathBbox2fBasicArray_class_info = _base.GMathBbox2fBasicArray_class_info

def GMathBbox2fBasicArray____class_destructor__(instance, is_array):
    return _base.GMathBbox2fBasicArray____class_destructor__(instance, is_array)
GMathBbox2fBasicArray____class_destructor__ = _base.GMathBbox2fBasicArray____class_destructor__

class GMathBbox2fArray(GMathBbox2fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathBbox2fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox2fArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathBbox2fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox2fArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathBbox2fArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox2fArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathBbox2fArray_append(self, *args)

    def get_count(self):
        return _base.GMathBbox2fArray_get_count(self)

    def remove_all(self):
        return _base.GMathBbox2fArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathBbox2fArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathBbox2fArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathBbox2fArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathBbox2fArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathBbox2fArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathBbox2fArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathBbox2fArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox2fArray_class_info)
    else:
        class_info = _base.GMathBbox2fArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox2fArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox2fArray____class_destructor__
GMathBbox2fArray_swigregister = _base.GMathBbox2fArray_swigregister
GMathBbox2fArray_swigregister(GMathBbox2fArray)

def GMathBbox2fArray_class_info():
    return _base.GMathBbox2fArray_class_info()
GMathBbox2fArray_class_info = _base.GMathBbox2fArray_class_info

def GMathBbox2fArray____class_destructor__(instance, is_array):
    return _base.GMathBbox2fArray____class_destructor__(instance, is_array)
GMathBbox2fArray____class_destructor__ = _base.GMathBbox2fArray____class_destructor__

class GMathBbox2fVector(GMathBbox2fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathBbox2fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox2fVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathBbox2fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox2fVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathBbox2fVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox2fVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathBbox2fVector_append(self, *args)

    def add(self, element):
        return _base.GMathBbox2fVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathBbox2fVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathBbox2fVector_remove_last(self)

    def empty(self):
        return _base.GMathBbox2fVector_empty(self)

    def remove_all(self):
        return _base.GMathBbox2fVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathBbox2fVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathBbox2fVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathBbox2fVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathBbox2fVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathBbox2fVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathBbox2fVector_get_count(self)

    def get_capacity(self):
        return _base.GMathBbox2fVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathBbox2fVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathBbox2fVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathBbox2fVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathBbox2fVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathBbox2fVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathBbox2fVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathBbox2fVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathBbox2fVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathBbox2fVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathBbox2fVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathBbox2fVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathBbox2fVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathBbox2fVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathBbox2fVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathBbox2fVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathBbox2fVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox2fVector_class_info)
    else:
        class_info = _base.GMathBbox2fVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox2fVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox2fVector____class_destructor__
GMathBbox2fVector_swigregister = _base.GMathBbox2fVector_swigregister
GMathBbox2fVector_swigregister(GMathBbox2fVector)

def GMathBbox2fVector_class_info():
    return _base.GMathBbox2fVector_class_info()
GMathBbox2fVector_class_info = _base.GMathBbox2fVector_class_info

def GMathBbox2fVector____class_destructor__(instance, is_array):
    return _base.GMathBbox2fVector____class_destructor__(instance, is_array)
GMathBbox2fVector____class_destructor__ = _base.GMathBbox2fVector____class_destructor__

class GMathBbox3fBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox3fBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox3fBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathBbox3fBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathBbox3fBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox3fBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathBbox3fBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathBbox3fBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathBbox3fBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathBbox3fBasicArray_front(self)

    def back(self):
        return _base.GMathBbox3fBasicArray_back(self)

    def exists(self, item):
        return _base.GMathBbox3fBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathBbox3fBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathBbox3fBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathBbox3fBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathBbox3fBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathBbox3fBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathBbox3fBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox3fBasicArray_class_info)
    else:
        class_info = _base.GMathBbox3fBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox3fBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox3fBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathBbox3fBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathBbox3fBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathBbox3fBasicArray_swigregister = _base.GMathBbox3fBasicArray_swigregister
GMathBbox3fBasicArray_swigregister(GMathBbox3fBasicArray)

def GMathBbox3fBasicArray_class_info():
    return _base.GMathBbox3fBasicArray_class_info()
GMathBbox3fBasicArray_class_info = _base.GMathBbox3fBasicArray_class_info

def GMathBbox3fBasicArray____class_destructor__(instance, is_array):
    return _base.GMathBbox3fBasicArray____class_destructor__(instance, is_array)
GMathBbox3fBasicArray____class_destructor__ = _base.GMathBbox3fBasicArray____class_destructor__

class GMathBbox3fArray(GMathBbox3fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathBbox3fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox3fArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathBbox3fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox3fArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathBbox3fArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox3fArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathBbox3fArray_append(self, *args)

    def get_count(self):
        return _base.GMathBbox3fArray_get_count(self)

    def remove_all(self):
        return _base.GMathBbox3fArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathBbox3fArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathBbox3fArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathBbox3fArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathBbox3fArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathBbox3fArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathBbox3fArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathBbox3fArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox3fArray_class_info)
    else:
        class_info = _base.GMathBbox3fArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox3fArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox3fArray____class_destructor__
GMathBbox3fArray_swigregister = _base.GMathBbox3fArray_swigregister
GMathBbox3fArray_swigregister(GMathBbox3fArray)

def GMathBbox3fArray_class_info():
    return _base.GMathBbox3fArray_class_info()
GMathBbox3fArray_class_info = _base.GMathBbox3fArray_class_info

def GMathBbox3fArray____class_destructor__(instance, is_array):
    return _base.GMathBbox3fArray____class_destructor__(instance, is_array)
GMathBbox3fArray____class_destructor__ = _base.GMathBbox3fArray____class_destructor__

class GMathBbox3fVector(GMathBbox3fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathBbox3fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox3fVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathBbox3fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox3fVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathBbox3fVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox3fVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathBbox3fVector_append(self, *args)

    def add(self, element):
        return _base.GMathBbox3fVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathBbox3fVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathBbox3fVector_remove_last(self)

    def empty(self):
        return _base.GMathBbox3fVector_empty(self)

    def remove_all(self):
        return _base.GMathBbox3fVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathBbox3fVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathBbox3fVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathBbox3fVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathBbox3fVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathBbox3fVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathBbox3fVector_get_count(self)

    def get_capacity(self):
        return _base.GMathBbox3fVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathBbox3fVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathBbox3fVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathBbox3fVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathBbox3fVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathBbox3fVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathBbox3fVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathBbox3fVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathBbox3fVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathBbox3fVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathBbox3fVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathBbox3fVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathBbox3fVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathBbox3fVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathBbox3fVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathBbox3fVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathBbox3fVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox3fVector_class_info)
    else:
        class_info = _base.GMathBbox3fVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox3fVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox3fVector____class_destructor__
GMathBbox3fVector_swigregister = _base.GMathBbox3fVector_swigregister
GMathBbox3fVector_swigregister(GMathBbox3fVector)

def GMathBbox3fVector_class_info():
    return _base.GMathBbox3fVector_class_info()
GMathBbox3fVector_class_info = _base.GMathBbox3fVector_class_info

def GMathBbox3fVector____class_destructor__(instance, is_array):
    return _base.GMathBbox3fVector____class_destructor__(instance, is_array)
GMathBbox3fVector____class_destructor__ = _base.GMathBbox3fVector____class_destructor__

class GMathBbox2d(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox2d, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox2d, name)

    def __init__(self, *args):
        this = _base.new_GMathBbox2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_copy(self):
        return _base.GMathBbox2d_get_copy(self)

    def copy_from(self, bbox):
        return _base.GMathBbox2d_copy_from(self, bbox)

    def copy_to(self, bbox):
        return _base.GMathBbox2d_copy_to(self, bbox)

    def get_center(self):
        return _base.GMathBbox2d_get_center(self)

    def intersect(self, *args):
        return _base.GMathBbox2d_intersect(self, *args)

    def compute_interpolated_bbox(self, time, start_bbox, end_bbox):
        return _base.GMathBbox2d_compute_interpolated_bbox(self, time, start_bbox, end_bbox)

    def get_corner_vertices(self, vertices):
        return _base.GMathBbox2d_get_corner_vertices(self, vertices)

    def compute_area(self):
        return _base.GMathBbox2d_compute_area(self)

    def is_empty(self):
        return _base.GMathBbox2d_is_empty(self)

    def get_item(self, x, y):
        return _base.GMathBbox2d_get_item(self, x, y)

    def set_item(self, x, y, value):
        return _base.GMathBbox2d_set_item(self, x, y, value)

    def get_class_info(self):
        return _base.GMathBbox2d_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox2d_class_info)
    else:
        class_info = _base.GMathBbox2d_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathBbox2d_register_methods)
    else:
        register_methods = _base.GMathBbox2d_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox2d____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox2d____class_destructor__

    def __repr__(self):
        return _base.GMathBbox2d___repr__(self)

    def __getitem__(self, index):
        return _base.GMathBbox2d___getitem__(self, index)

    def __len__(self):
        return _base.GMathBbox2d___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathBbox2d
    __del__ = lambda self: None
GMathBbox2d_swigregister = _base.GMathBbox2d_swigregister
GMathBbox2d_swigregister(GMathBbox2d)

def GMathBbox2d_class_info():
    return _base.GMathBbox2d_class_info()
GMathBbox2d_class_info = _base.GMathBbox2d_class_info

def GMathBbox2d_register_methods(cls):
    return _base.GMathBbox2d_register_methods(cls)
GMathBbox2d_register_methods = _base.GMathBbox2d_register_methods

def GMathBbox2d____class_destructor__(instance, is_array):
    return _base.GMathBbox2d____class_destructor__(instance, is_array)
GMathBbox2d____class_destructor__ = _base.GMathBbox2d____class_destructor__

class GMathBbox3d(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox3d, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox3d, name)

    def __init__(self):
        this = _base.new_GMathBbox3d()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_copy(self):
        return _base.GMathBbox3d_get_copy(self)

    def copy_from(self, bbox):
        return _base.GMathBbox3d_copy_from(self, bbox)

    def copy_to(self, bbox):
        return _base.GMathBbox3d_copy_to(self, bbox)

    def get_center(self):
        return _base.GMathBbox3d_get_center(self)

    def intersect(self, *args):
        return _base.GMathBbox3d_intersect(self, *args)

    def compute_interpolated_bbox(self, time, start_bbox, end_bbox):
        return _base.GMathBbox3d_compute_interpolated_bbox(self, time, start_bbox, end_bbox)

    def get_corner_vertices(self, vertices):
        return _base.GMathBbox3d_get_corner_vertices(self, vertices)

    def transform_bbox_and_get_bbox(self, matrix, result):
        return _base.GMathBbox3d_transform_bbox_and_get_bbox(self, matrix, result)

    def compute_volume(self):
        return _base.GMathBbox3d_compute_volume(self)

    def compute_area(self):
        return _base.GMathBbox3d_compute_area(self)

    def compute_surface_area(self):
        return _base.GMathBbox3d_compute_surface_area(self)

    def get_min(self, *args):
        return _base.GMathBbox3d_get_min(self, *args)

    def get_max(self, *args):
        return _base.GMathBbox3d_get_max(self, *args)

    def is_empty(self):
        return _base.GMathBbox3d_is_empty(self)

    def is_finite(self):
        return _base.GMathBbox3d_is_finite(self)

    def get_maximum_extent(self):
        return _base.GMathBbox3d_get_maximum_extent(self)

    def get_item(self, x, y):
        return _base.GMathBbox3d_get_item(self, x, y)

    def set_item(self, x, y, value):
        return _base.GMathBbox3d_set_item(self, x, y, value)

    def get_class_info(self):
        return _base.GMathBbox3d_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox3d_class_info)
    else:
        class_info = _base.GMathBbox3d_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathBbox3d_register_methods)
    else:
        register_methods = _base.GMathBbox3d_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox3d____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox3d____class_destructor__

    def __repr__(self):
        return _base.GMathBbox3d___repr__(self)

    def __getitem__(self, index):
        return _base.GMathBbox3d___getitem__(self, index)

    def __len__(self):
        return _base.GMathBbox3d___len__(self)

    def __nonzero__(self): return True

    __swig_destroy__ = _base.delete_GMathBbox3d
    __del__ = lambda self: None
GMathBbox3d_swigregister = _base.GMathBbox3d_swigregister
GMathBbox3d_swigregister(GMathBbox3d)
GMathBbox3d.s_empty_box = _base.cvar.GMathBbox3d_s_empty_box

def GMathBbox3d_class_info():
    return _base.GMathBbox3d_class_info()
GMathBbox3d_class_info = _base.GMathBbox3d_class_info

def GMathBbox3d_register_methods(cls):
    return _base.GMathBbox3d_register_methods(cls)
GMathBbox3d_register_methods = _base.GMathBbox3d_register_methods

def GMathBbox3d____class_destructor__(instance, is_array):
    return _base.GMathBbox3d____class_destructor__(instance, is_array)
GMathBbox3d____class_destructor__ = _base.GMathBbox3d____class_destructor__

class GMathBbox2dBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox2dBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox2dBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathBbox2dBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathBbox2dBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox2dBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathBbox2dBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathBbox2dBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathBbox2dBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathBbox2dBasicArray_front(self)

    def back(self):
        return _base.GMathBbox2dBasicArray_back(self)

    def exists(self, item):
        return _base.GMathBbox2dBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathBbox2dBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathBbox2dBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathBbox2dBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathBbox2dBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathBbox2dBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathBbox2dBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox2dBasicArray_class_info)
    else:
        class_info = _base.GMathBbox2dBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox2dBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox2dBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathBbox2dBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathBbox2dBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathBbox2dBasicArray_swigregister = _base.GMathBbox2dBasicArray_swigregister
GMathBbox2dBasicArray_swigregister(GMathBbox2dBasicArray)

def GMathBbox2dBasicArray_class_info():
    return _base.GMathBbox2dBasicArray_class_info()
GMathBbox2dBasicArray_class_info = _base.GMathBbox2dBasicArray_class_info

def GMathBbox2dBasicArray____class_destructor__(instance, is_array):
    return _base.GMathBbox2dBasicArray____class_destructor__(instance, is_array)
GMathBbox2dBasicArray____class_destructor__ = _base.GMathBbox2dBasicArray____class_destructor__

class GMathBbox2dArray(GMathBbox2dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathBbox2dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox2dArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathBbox2dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox2dArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathBbox2dArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox2dArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathBbox2dArray_append(self, *args)

    def get_count(self):
        return _base.GMathBbox2dArray_get_count(self)

    def remove_all(self):
        return _base.GMathBbox2dArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathBbox2dArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathBbox2dArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathBbox2dArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathBbox2dArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathBbox2dArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathBbox2dArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathBbox2dArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox2dArray_class_info)
    else:
        class_info = _base.GMathBbox2dArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox2dArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox2dArray____class_destructor__
GMathBbox2dArray_swigregister = _base.GMathBbox2dArray_swigregister
GMathBbox2dArray_swigregister(GMathBbox2dArray)

def GMathBbox2dArray_class_info():
    return _base.GMathBbox2dArray_class_info()
GMathBbox2dArray_class_info = _base.GMathBbox2dArray_class_info

def GMathBbox2dArray____class_destructor__(instance, is_array):
    return _base.GMathBbox2dArray____class_destructor__(instance, is_array)
GMathBbox2dArray____class_destructor__ = _base.GMathBbox2dArray____class_destructor__

class GMathBbox2dVector(GMathBbox2dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathBbox2dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox2dVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathBbox2dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox2dVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathBbox2dVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox2dVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathBbox2dVector_append(self, *args)

    def add(self, element):
        return _base.GMathBbox2dVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathBbox2dVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathBbox2dVector_remove_last(self)

    def empty(self):
        return _base.GMathBbox2dVector_empty(self)

    def remove_all(self):
        return _base.GMathBbox2dVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathBbox2dVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathBbox2dVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathBbox2dVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathBbox2dVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathBbox2dVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathBbox2dVector_get_count(self)

    def get_capacity(self):
        return _base.GMathBbox2dVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathBbox2dVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathBbox2dVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathBbox2dVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathBbox2dVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathBbox2dVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathBbox2dVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathBbox2dVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathBbox2dVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathBbox2dVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathBbox2dVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathBbox2dVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathBbox2dVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathBbox2dVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathBbox2dVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathBbox2dVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathBbox2dVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox2dVector_class_info)
    else:
        class_info = _base.GMathBbox2dVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox2dVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox2dVector____class_destructor__
GMathBbox2dVector_swigregister = _base.GMathBbox2dVector_swigregister
GMathBbox2dVector_swigregister(GMathBbox2dVector)

def GMathBbox2dVector_class_info():
    return _base.GMathBbox2dVector_class_info()
GMathBbox2dVector_class_info = _base.GMathBbox2dVector_class_info

def GMathBbox2dVector____class_destructor__(instance, is_array):
    return _base.GMathBbox2dVector____class_destructor__(instance, is_array)
GMathBbox2dVector____class_destructor__ = _base.GMathBbox2dVector____class_destructor__

class GMathBbox3dBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox3dBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox3dBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathBbox3dBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathBbox3dBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox3dBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathBbox3dBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathBbox3dBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathBbox3dBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathBbox3dBasicArray_front(self)

    def back(self):
        return _base.GMathBbox3dBasicArray_back(self)

    def exists(self, item):
        return _base.GMathBbox3dBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathBbox3dBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathBbox3dBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathBbox3dBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathBbox3dBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathBbox3dBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathBbox3dBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox3dBasicArray_class_info)
    else:
        class_info = _base.GMathBbox3dBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox3dBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox3dBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathBbox3dBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathBbox3dBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathBbox3dBasicArray_swigregister = _base.GMathBbox3dBasicArray_swigregister
GMathBbox3dBasicArray_swigregister(GMathBbox3dBasicArray)

def GMathBbox3dBasicArray_class_info():
    return _base.GMathBbox3dBasicArray_class_info()
GMathBbox3dBasicArray_class_info = _base.GMathBbox3dBasicArray_class_info

def GMathBbox3dBasicArray____class_destructor__(instance, is_array):
    return _base.GMathBbox3dBasicArray____class_destructor__(instance, is_array)
GMathBbox3dBasicArray____class_destructor__ = _base.GMathBbox3dBasicArray____class_destructor__

class GMathBbox3dArray(GMathBbox3dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathBbox3dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox3dArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathBbox3dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox3dArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathBbox3dArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox3dArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathBbox3dArray_append(self, *args)

    def get_count(self):
        return _base.GMathBbox3dArray_get_count(self)

    def remove_all(self):
        return _base.GMathBbox3dArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathBbox3dArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathBbox3dArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathBbox3dArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathBbox3dArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathBbox3dArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathBbox3dArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathBbox3dArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox3dArray_class_info)
    else:
        class_info = _base.GMathBbox3dArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox3dArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox3dArray____class_destructor__
GMathBbox3dArray_swigregister = _base.GMathBbox3dArray_swigregister
GMathBbox3dArray_swigregister(GMathBbox3dArray)

def GMathBbox3dArray_class_info():
    return _base.GMathBbox3dArray_class_info()
GMathBbox3dArray_class_info = _base.GMathBbox3dArray_class_info

def GMathBbox3dArray____class_destructor__(instance, is_array):
    return _base.GMathBbox3dArray____class_destructor__(instance, is_array)
GMathBbox3dArray____class_destructor__ = _base.GMathBbox3dArray____class_destructor__

class GMathBbox3dVector(GMathBbox3dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathBbox3dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathBbox3dVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathBbox3dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathBbox3dVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathBbox3dVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathBbox3dVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathBbox3dVector_append(self, *args)

    def add(self, element):
        return _base.GMathBbox3dVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathBbox3dVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathBbox3dVector_remove_last(self)

    def empty(self):
        return _base.GMathBbox3dVector_empty(self)

    def remove_all(self):
        return _base.GMathBbox3dVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathBbox3dVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathBbox3dVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathBbox3dVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathBbox3dVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathBbox3dVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathBbox3dVector_get_count(self)

    def get_capacity(self):
        return _base.GMathBbox3dVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathBbox3dVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathBbox3dVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathBbox3dVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathBbox3dVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathBbox3dVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathBbox3dVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathBbox3dVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathBbox3dVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathBbox3dVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathBbox3dVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathBbox3dVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathBbox3dVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathBbox3dVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathBbox3dVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathBbox3dVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathBbox3dVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathBbox3dVector_class_info)
    else:
        class_info = _base.GMathBbox3dVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathBbox3dVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathBbox3dVector____class_destructor__
GMathBbox3dVector_swigregister = _base.GMathBbox3dVector_swigregister
GMathBbox3dVector_swigregister(GMathBbox3dVector)

def GMathBbox3dVector_class_info():
    return _base.GMathBbox3dVector_class_info()
GMathBbox3dVector_class_info = _base.GMathBbox3dVector_class_info

def GMathBbox3dVector____class_destructor__(instance, is_array):
    return _base.GMathBbox3dVector____class_destructor__(instance, is_array)
GMathBbox3dVector____class_destructor__ = _base.GMathBbox3dVector____class_destructor__

class GMathMatrix3x3f(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix3x3f, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix3x3f, name)

    def __init__(self, *args):
        this = _base.new_GMathMatrix3x3f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        get_identity = staticmethod(_base.GMathMatrix3x3f_get_identity)
    else:
        get_identity = _base.GMathMatrix3x3f_get_identity

    def get_copy(self):
        return _base.GMathMatrix3x3f_get_copy(self)

    def copy_from(self, m):
        return _base.GMathMatrix3x3f_copy_from(self, m)

    def copy_to(self, u):
        return _base.GMathMatrix3x3f_copy_to(self, u)

    def __eq__(self, m):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathMatrix3x3f___eq__(self, m)


    def __ne__(self, m):
        return _base.GMathMatrix3x3f___ne__(self, m)

    def nullify(self):
        return _base.GMathMatrix3x3f_nullify(self)

    def set_identity(self):
        return _base.GMathMatrix3x3f_set_identity(self)

    def set_frame(self, x, y, z):
        return _base.GMathMatrix3x3f_set_frame(self, x, y, z)

    def set_rotation(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix3x3f_set_rotation(self, r, order)

    def multiply_left(self, m):
        return _base.GMathMatrix3x3f_multiply_left(self, m)

    def multiply_right(self, m):
        return _base.GMathMatrix3x3f_multiply_right(self, m)

    def multiply_transpose_left(self, *args):
        return _base.GMathMatrix3x3f_multiply_transpose_left(self, *args)

    def multiply_transpose_right(self, *args):
        return _base.GMathMatrix3x3f_multiply_transpose_right(self, *args)

    def rotate(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix3x3f_rotate(self, r, order)

    def transpose(self, *args):
        return _base.GMathMatrix3x3f_transpose(self, *args)

    def compute_euler_angles(self, *args):
        return _base.GMathMatrix3x3f_compute_euler_angles(self, *args)

    def get_item(self, x, y):
        return _base.GMathMatrix3x3f_get_item(self, x, y)

    def set_item(self, x, y, value):
        return _base.GMathMatrix3x3f_set_item(self, x, y, value)

    def get_x_axis(self):
        return _base.GMathMatrix3x3f_get_x_axis(self)

    def get_y_axis(self):
        return _base.GMathMatrix3x3f_get_y_axis(self)

    def get_z_axis(self):
        return _base.GMathMatrix3x3f_get_z_axis(self)

    def fast_interpolate(self, *args):
        return _base.GMathMatrix3x3f_fast_interpolate(self, *args)

    def is_finite(self):
        return _base.GMathMatrix3x3f_is_finite(self)

    def get_class_info(self):
        return _base.GMathMatrix3x3f_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix3x3f_class_info)
    else:
        class_info = _base.GMathMatrix3x3f_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathMatrix3x3f_register_methods)
    else:
        register_methods = _base.GMathMatrix3x3f_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix3x3f____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix3x3f____class_destructor__
    if _newclass:
        multiply = staticmethod(_base.GMathMatrix3x3f_multiply)
    else:
        multiply = _base.GMathMatrix3x3f_multiply
    if _newclass:
        multiply_transpose = staticmethod(_base.GMathMatrix3x3f_multiply_transpose)
    else:
        multiply_transpose = _base.GMathMatrix3x3f_multiply_transpose

    def __repr__(self):
        return _base.GMathMatrix3x3f___repr__(self)
    __swig_destroy__ = _base.delete_GMathMatrix3x3f
    __del__ = lambda self: None
GMathMatrix3x3f_swigregister = _base.GMathMatrix3x3f_swigregister
GMathMatrix3x3f_swigregister(GMathMatrix3x3f)

def GMathMatrix3x3f_get_identity():
    return _base.GMathMatrix3x3f_get_identity()
GMathMatrix3x3f_get_identity = _base.GMathMatrix3x3f_get_identity

def GMathMatrix3x3f_class_info():
    return _base.GMathMatrix3x3f_class_info()
GMathMatrix3x3f_class_info = _base.GMathMatrix3x3f_class_info

def GMathMatrix3x3f_register_methods(cls):
    return _base.GMathMatrix3x3f_register_methods(cls)
GMathMatrix3x3f_register_methods = _base.GMathMatrix3x3f_register_methods

def GMathMatrix3x3f____class_destructor__(instance, is_array):
    return _base.GMathMatrix3x3f____class_destructor__(instance, is_array)
GMathMatrix3x3f____class_destructor__ = _base.GMathMatrix3x3f____class_destructor__

def GMathMatrix3x3f_multiply(*args):
    return _base.GMathMatrix3x3f_multiply(*args)
GMathMatrix3x3f_multiply = _base.GMathMatrix3x3f_multiply

def GMathMatrix3x3f_multiply_transpose(*args):
    return _base.GMathMatrix3x3f_multiply_transpose(*args)
GMathMatrix3x3f_multiply_transpose = _base.GMathMatrix3x3f_multiply_transpose

class GMathMatrix4x4f(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix4x4f, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix4x4f, name)

    def __init__(self, *args):
        this = _base.new_GMathMatrix4x4f(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        get_identity = staticmethod(_base.GMathMatrix4x4f_get_identity)
    else:
        get_identity = _base.GMathMatrix4x4f_get_identity

    def get_copy(self):
        return _base.GMathMatrix4x4f_get_copy(self)

    def copy_from(self, m):
        return _base.GMathMatrix4x4f_copy_from(self, m)

    def copy_to(self, m):
        return _base.GMathMatrix4x4f_copy_to(self, m)

    def __eq__(self, m):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathMatrix4x4f___eq__(self, m)


    def __ne__(self, m):
        return _base.GMathMatrix4x4f___ne__(self, m)

    def nullify(self):
        return _base.GMathMatrix4x4f_nullify(self)

    def set_identity(self):
        return _base.GMathMatrix4x4f_set_identity(self)

    def make_translation(self, *args):
        return _base.GMathMatrix4x4f_make_translation(self, *args)

    def make_inverse(self, t, r, s):
        return _base.GMathMatrix4x4f_make_inverse(self, t, r, s)

    def make_frame(self, x, y, z):
        return _base.GMathMatrix4x4f_make_frame(self, x, y, z)

    def make_rotation_Z(self, angle_radians):
        return _base.GMathMatrix4x4f_make_rotation_Z(self, angle_radians)

    def make_rotation(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix4x4f_make_rotation(self, r, order)

    def make_scaling(self, *args):
        return _base.GMathMatrix4x4f_make_scaling(self, *args)

    def make_shearing(self, *args):
        return _base.GMathMatrix4x4f_make_shearing(self, *args)

    def make_perspective(self, l, r, b, t, n, f):
        return _base.GMathMatrix4x4f_make_perspective(self, l, r, b, t, n, f)

    def compose(self, *args):
        return _base.GMathMatrix4x4f_compose(self, *args)

    def set_translation(self, t):
        return _base.GMathMatrix4x4f_set_translation(self, t)

    def set_frame(self, x, y, z):
        return _base.GMathMatrix4x4f_set_frame(self, x, y, z)

    def set_rotation(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix4x4f_set_rotation(self, r, order)

    def set_scaling(self, s):
        return _base.GMathMatrix4x4f_set_scaling(self, s)

    def multiply_left(self, m):
        return _base.GMathMatrix4x4f_multiply_left(self, m)

    def multiply_right(self, m):
        return _base.GMathMatrix4x4f_multiply_right(self, m)

    def multiply_transpose_left(self, *args):
        return _base.GMathMatrix4x4f_multiply_transpose_left(self, *args)

    def multiply_transpose_right(self, *args):
        return _base.GMathMatrix4x4f_multiply_transpose_right(self, *args)

    def rotate(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix4x4f_rotate(self, r, order)

    def scale(self, *args):
        return _base.GMathMatrix4x4f_scale(self, *args)

    def shear(self, *args):
        return _base.GMathMatrix4x4f_shear(self, *args)
    if _newclass:
        get_inverse = staticmethod(_base.GMathMatrix4x4f_get_inverse)
    else:
        get_inverse = _base.GMathMatrix4x4f_get_inverse

    def invert(self):
        return _base.GMathMatrix4x4f_invert(self)

    def transpose(self, *args):
        return _base.GMathMatrix4x4f_transpose(self, *args)

    def extract_translation(self, *args):
        return _base.GMathMatrix4x4f_extract_translation(self, *args)

    def compute_euler_angles(self, *args):
        return _base.GMathMatrix4x4f_compute_euler_angles(self, *args)

    def decompose(self, *args):
        return _base.GMathMatrix4x4f_decompose(self, *args)

    def extract_rotation(self, r):
        return _base.GMathMatrix4x4f_extract_rotation(self, r)

    def extract_frame(self, x, y, z):
        return _base.GMathMatrix4x4f_extract_frame(self, x, y, z)

    def extract_shearing(self, shear):
        return _base.GMathMatrix4x4f_extract_shearing(self, shear)

    def extract_scaling(self, scale):
        return _base.GMathMatrix4x4f_extract_scaling(self, scale)

    def make_orthonormal(self):
        return _base.GMathMatrix4x4f_make_orthonormal(self)
    if _newclass:
        get_determinant = staticmethod(_base.GMathMatrix4x4f_get_determinant)
    else:
        get_determinant = _base.GMathMatrix4x4f_get_determinant

    def set_item(self, x, y, value):
        return _base.GMathMatrix4x4f_set_item(self, x, y, value)

    def fast_interpolate(self, *args):
        return _base.GMathMatrix4x4f_fast_interpolate(self, *args)

    def equals(self, *args):
        return _base.GMathMatrix4x4f_equals(self, *args)

    def is_finite(self):
        return _base.GMathMatrix4x4f_is_finite(self)

    def get_class_info(self):
        return _base.GMathMatrix4x4f_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix4x4f_class_info)
    else:
        class_info = _base.GMathMatrix4x4f_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathMatrix4x4f_register_methods)
    else:
        register_methods = _base.GMathMatrix4x4f_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix4x4f____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix4x4f____class_destructor__
    if _newclass:
        multiply = staticmethod(_base.GMathMatrix4x4f_multiply)
    else:
        multiply = _base.GMathMatrix4x4f_multiply
    if _newclass:
        multiply_transpose = staticmethod(_base.GMathMatrix4x4f_multiply_transpose)
    else:
        multiply_transpose = _base.GMathMatrix4x4f_multiply_transpose

    def __repr__(self):
        return _base.GMathMatrix4x4f___repr__(self)

    def get_item(self, *args):
        return _base.GMathMatrix4x4f_get_item(self, *args)
    __swig_destroy__ = _base.delete_GMathMatrix4x4f
    __del__ = lambda self: None
GMathMatrix4x4f_swigregister = _base.GMathMatrix4x4f_swigregister
GMathMatrix4x4f_swigregister(GMathMatrix4x4f)

def GMathMatrix4x4f_get_identity():
    return _base.GMathMatrix4x4f_get_identity()
GMathMatrix4x4f_get_identity = _base.GMathMatrix4x4f_get_identity

def GMathMatrix4x4f_get_inverse(m, result):
    return _base.GMathMatrix4x4f_get_inverse(m, result)
GMathMatrix4x4f_get_inverse = _base.GMathMatrix4x4f_get_inverse

def GMathMatrix4x4f_get_determinant(*args):
    return _base.GMathMatrix4x4f_get_determinant(*args)
GMathMatrix4x4f_get_determinant = _base.GMathMatrix4x4f_get_determinant

def GMathMatrix4x4f_class_info():
    return _base.GMathMatrix4x4f_class_info()
GMathMatrix4x4f_class_info = _base.GMathMatrix4x4f_class_info

def GMathMatrix4x4f_register_methods(cls):
    return _base.GMathMatrix4x4f_register_methods(cls)
GMathMatrix4x4f_register_methods = _base.GMathMatrix4x4f_register_methods

def GMathMatrix4x4f____class_destructor__(instance, is_array):
    return _base.GMathMatrix4x4f____class_destructor__(instance, is_array)
GMathMatrix4x4f____class_destructor__ = _base.GMathMatrix4x4f____class_destructor__

def GMathMatrix4x4f_multiply(*args):
    return _base.GMathMatrix4x4f_multiply(*args)
GMathMatrix4x4f_multiply = _base.GMathMatrix4x4f_multiply

def GMathMatrix4x4f_multiply_transpose(*args):
    return _base.GMathMatrix4x4f_multiply_transpose(*args)
GMathMatrix4x4f_multiply_transpose = _base.GMathMatrix4x4f_multiply_transpose

class GMathMatrix3x3fBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix3x3fBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix3x3fBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathMatrix3x3fBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathMatrix3x3fBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix3x3fBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathMatrix3x3fBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathMatrix3x3fBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathMatrix3x3fBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathMatrix3x3fBasicArray_front(self)

    def back(self):
        return _base.GMathMatrix3x3fBasicArray_back(self)

    def exists(self, item):
        return _base.GMathMatrix3x3fBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathMatrix3x3fBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathMatrix3x3fBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathMatrix3x3fBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathMatrix3x3fBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathMatrix3x3fBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathMatrix3x3fBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix3x3fBasicArray_class_info)
    else:
        class_info = _base.GMathMatrix3x3fBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix3x3fBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix3x3fBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathMatrix3x3fBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathMatrix3x3fBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathMatrix3x3fBasicArray_swigregister = _base.GMathMatrix3x3fBasicArray_swigregister
GMathMatrix3x3fBasicArray_swigregister(GMathMatrix3x3fBasicArray)

def GMathMatrix3x3fBasicArray_class_info():
    return _base.GMathMatrix3x3fBasicArray_class_info()
GMathMatrix3x3fBasicArray_class_info = _base.GMathMatrix3x3fBasicArray_class_info

def GMathMatrix3x3fBasicArray____class_destructor__(instance, is_array):
    return _base.GMathMatrix3x3fBasicArray____class_destructor__(instance, is_array)
GMathMatrix3x3fBasicArray____class_destructor__ = _base.GMathMatrix3x3fBasicArray____class_destructor__

class GMathMatrix3x3fArray(GMathMatrix3x3fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathMatrix3x3fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix3x3fArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathMatrix3x3fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix3x3fArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathMatrix3x3fArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix3x3fArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathMatrix3x3fArray_append(self, *args)

    def get_count(self):
        return _base.GMathMatrix3x3fArray_get_count(self)

    def remove_all(self):
        return _base.GMathMatrix3x3fArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathMatrix3x3fArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathMatrix3x3fArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathMatrix3x3fArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathMatrix3x3fArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathMatrix3x3fArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathMatrix3x3fArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathMatrix3x3fArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix3x3fArray_class_info)
    else:
        class_info = _base.GMathMatrix3x3fArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix3x3fArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix3x3fArray____class_destructor__
GMathMatrix3x3fArray_swigregister = _base.GMathMatrix3x3fArray_swigregister
GMathMatrix3x3fArray_swigregister(GMathMatrix3x3fArray)

def GMathMatrix3x3fArray_class_info():
    return _base.GMathMatrix3x3fArray_class_info()
GMathMatrix3x3fArray_class_info = _base.GMathMatrix3x3fArray_class_info

def GMathMatrix3x3fArray____class_destructor__(instance, is_array):
    return _base.GMathMatrix3x3fArray____class_destructor__(instance, is_array)
GMathMatrix3x3fArray____class_destructor__ = _base.GMathMatrix3x3fArray____class_destructor__

class GMathMatrix3x3fVector(GMathMatrix3x3fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathMatrix3x3fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix3x3fVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathMatrix3x3fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix3x3fVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathMatrix3x3fVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix3x3fVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathMatrix3x3fVector_append(self, *args)

    def add(self, element):
        return _base.GMathMatrix3x3fVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathMatrix3x3fVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathMatrix3x3fVector_remove_last(self)

    def empty(self):
        return _base.GMathMatrix3x3fVector_empty(self)

    def remove_all(self):
        return _base.GMathMatrix3x3fVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathMatrix3x3fVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathMatrix3x3fVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathMatrix3x3fVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathMatrix3x3fVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathMatrix3x3fVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathMatrix3x3fVector_get_count(self)

    def get_capacity(self):
        return _base.GMathMatrix3x3fVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathMatrix3x3fVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathMatrix3x3fVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathMatrix3x3fVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathMatrix3x3fVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathMatrix3x3fVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathMatrix3x3fVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathMatrix3x3fVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathMatrix3x3fVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathMatrix3x3fVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathMatrix3x3fVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathMatrix3x3fVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathMatrix3x3fVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathMatrix3x3fVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathMatrix3x3fVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathMatrix3x3fVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathMatrix3x3fVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix3x3fVector_class_info)
    else:
        class_info = _base.GMathMatrix3x3fVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix3x3fVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix3x3fVector____class_destructor__
GMathMatrix3x3fVector_swigregister = _base.GMathMatrix3x3fVector_swigregister
GMathMatrix3x3fVector_swigregister(GMathMatrix3x3fVector)

def GMathMatrix3x3fVector_class_info():
    return _base.GMathMatrix3x3fVector_class_info()
GMathMatrix3x3fVector_class_info = _base.GMathMatrix3x3fVector_class_info

def GMathMatrix3x3fVector____class_destructor__(instance, is_array):
    return _base.GMathMatrix3x3fVector____class_destructor__(instance, is_array)
GMathMatrix3x3fVector____class_destructor__ = _base.GMathMatrix3x3fVector____class_destructor__

class GMathMatrix4x4fBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix4x4fBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix4x4fBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathMatrix4x4fBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathMatrix4x4fBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix4x4fBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathMatrix4x4fBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathMatrix4x4fBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathMatrix4x4fBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathMatrix4x4fBasicArray_front(self)

    def back(self):
        return _base.GMathMatrix4x4fBasicArray_back(self)

    def exists(self, item):
        return _base.GMathMatrix4x4fBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathMatrix4x4fBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathMatrix4x4fBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathMatrix4x4fBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathMatrix4x4fBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathMatrix4x4fBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathMatrix4x4fBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix4x4fBasicArray_class_info)
    else:
        class_info = _base.GMathMatrix4x4fBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix4x4fBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix4x4fBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathMatrix4x4fBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathMatrix4x4fBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathMatrix4x4fBasicArray_swigregister = _base.GMathMatrix4x4fBasicArray_swigregister
GMathMatrix4x4fBasicArray_swigregister(GMathMatrix4x4fBasicArray)

def GMathMatrix4x4fBasicArray_class_info():
    return _base.GMathMatrix4x4fBasicArray_class_info()
GMathMatrix4x4fBasicArray_class_info = _base.GMathMatrix4x4fBasicArray_class_info

def GMathMatrix4x4fBasicArray____class_destructor__(instance, is_array):
    return _base.GMathMatrix4x4fBasicArray____class_destructor__(instance, is_array)
GMathMatrix4x4fBasicArray____class_destructor__ = _base.GMathMatrix4x4fBasicArray____class_destructor__

class GMathMatrix4x4fArray(GMathMatrix4x4fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathMatrix4x4fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix4x4fArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathMatrix4x4fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix4x4fArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathMatrix4x4fArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix4x4fArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathMatrix4x4fArray_append(self, *args)

    def get_count(self):
        return _base.GMathMatrix4x4fArray_get_count(self)

    def remove_all(self):
        return _base.GMathMatrix4x4fArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathMatrix4x4fArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathMatrix4x4fArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathMatrix4x4fArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathMatrix4x4fArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathMatrix4x4fArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathMatrix4x4fArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathMatrix4x4fArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix4x4fArray_class_info)
    else:
        class_info = _base.GMathMatrix4x4fArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix4x4fArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix4x4fArray____class_destructor__
GMathMatrix4x4fArray_swigregister = _base.GMathMatrix4x4fArray_swigregister
GMathMatrix4x4fArray_swigregister(GMathMatrix4x4fArray)

def GMathMatrix4x4fArray_class_info():
    return _base.GMathMatrix4x4fArray_class_info()
GMathMatrix4x4fArray_class_info = _base.GMathMatrix4x4fArray_class_info

def GMathMatrix4x4fArray____class_destructor__(instance, is_array):
    return _base.GMathMatrix4x4fArray____class_destructor__(instance, is_array)
GMathMatrix4x4fArray____class_destructor__ = _base.GMathMatrix4x4fArray____class_destructor__

class GMathMatrix4x4fVector(GMathMatrix4x4fBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathMatrix4x4fBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix4x4fVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathMatrix4x4fBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix4x4fVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathMatrix4x4fVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix4x4fVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathMatrix4x4fVector_append(self, *args)

    def add(self, element):
        return _base.GMathMatrix4x4fVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathMatrix4x4fVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathMatrix4x4fVector_remove_last(self)

    def empty(self):
        return _base.GMathMatrix4x4fVector_empty(self)

    def remove_all(self):
        return _base.GMathMatrix4x4fVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathMatrix4x4fVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathMatrix4x4fVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathMatrix4x4fVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathMatrix4x4fVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathMatrix4x4fVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathMatrix4x4fVector_get_count(self)

    def get_capacity(self):
        return _base.GMathMatrix4x4fVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathMatrix4x4fVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathMatrix4x4fVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathMatrix4x4fVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathMatrix4x4fVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathMatrix4x4fVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathMatrix4x4fVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathMatrix4x4fVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathMatrix4x4fVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathMatrix4x4fVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathMatrix4x4fVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathMatrix4x4fVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathMatrix4x4fVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathMatrix4x4fVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathMatrix4x4fVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathMatrix4x4fVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathMatrix4x4fVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix4x4fVector_class_info)
    else:
        class_info = _base.GMathMatrix4x4fVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix4x4fVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix4x4fVector____class_destructor__
GMathMatrix4x4fVector_swigregister = _base.GMathMatrix4x4fVector_swigregister
GMathMatrix4x4fVector_swigregister(GMathMatrix4x4fVector)

def GMathMatrix4x4fVector_class_info():
    return _base.GMathMatrix4x4fVector_class_info()
GMathMatrix4x4fVector_class_info = _base.GMathMatrix4x4fVector_class_info

def GMathMatrix4x4fVector____class_destructor__(instance, is_array):
    return _base.GMathMatrix4x4fVector____class_destructor__(instance, is_array)
GMathMatrix4x4fVector____class_destructor__ = _base.GMathMatrix4x4fVector____class_destructor__

class GMathMatrix3x3d(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix3x3d, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix3x3d, name)

    def __init__(self, *args):
        this = _base.new_GMathMatrix3x3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        get_identity = staticmethod(_base.GMathMatrix3x3d_get_identity)
    else:
        get_identity = _base.GMathMatrix3x3d_get_identity

    def get_copy(self):
        return _base.GMathMatrix3x3d_get_copy(self)

    def copy_from(self, m):
        return _base.GMathMatrix3x3d_copy_from(self, m)

    def copy_to(self, u):
        return _base.GMathMatrix3x3d_copy_to(self, u)

    def __eq__(self, m):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathMatrix3x3d___eq__(self, m)


    def __ne__(self, m):
        return _base.GMathMatrix3x3d___ne__(self, m)

    def nullify(self):
        return _base.GMathMatrix3x3d_nullify(self)

    def set_identity(self):
        return _base.GMathMatrix3x3d_set_identity(self)

    def set_frame(self, x, y, z):
        return _base.GMathMatrix3x3d_set_frame(self, x, y, z)

    def set_rotation(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix3x3d_set_rotation(self, r, order)

    def multiply_left(self, m):
        return _base.GMathMatrix3x3d_multiply_left(self, m)

    def multiply_right(self, m):
        return _base.GMathMatrix3x3d_multiply_right(self, m)

    def multiply_transpose_left(self, *args):
        return _base.GMathMatrix3x3d_multiply_transpose_left(self, *args)

    def multiply_transpose_right(self, *args):
        return _base.GMathMatrix3x3d_multiply_transpose_right(self, *args)

    def rotate(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix3x3d_rotate(self, r, order)

    def transpose(self, *args):
        return _base.GMathMatrix3x3d_transpose(self, *args)

    def compute_euler_angles(self, *args):
        return _base.GMathMatrix3x3d_compute_euler_angles(self, *args)

    def get_item(self, x, y):
        return _base.GMathMatrix3x3d_get_item(self, x, y)

    def set_item(self, x, y, value):
        return _base.GMathMatrix3x3d_set_item(self, x, y, value)

    def get_x_axis(self):
        return _base.GMathMatrix3x3d_get_x_axis(self)

    def get_y_axis(self):
        return _base.GMathMatrix3x3d_get_y_axis(self)

    def get_z_axis(self):
        return _base.GMathMatrix3x3d_get_z_axis(self)

    def fast_interpolate(self, *args):
        return _base.GMathMatrix3x3d_fast_interpolate(self, *args)

    def is_finite(self):
        return _base.GMathMatrix3x3d_is_finite(self)

    def get_class_info(self):
        return _base.GMathMatrix3x3d_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix3x3d_class_info)
    else:
        class_info = _base.GMathMatrix3x3d_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathMatrix3x3d_register_methods)
    else:
        register_methods = _base.GMathMatrix3x3d_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix3x3d____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix3x3d____class_destructor__
    if _newclass:
        multiply = staticmethod(_base.GMathMatrix3x3d_multiply)
    else:
        multiply = _base.GMathMatrix3x3d_multiply
    if _newclass:
        multiply_transpose = staticmethod(_base.GMathMatrix3x3d_multiply_transpose)
    else:
        multiply_transpose = _base.GMathMatrix3x3d_multiply_transpose

    def __repr__(self):
        return _base.GMathMatrix3x3d___repr__(self)
    __swig_destroy__ = _base.delete_GMathMatrix3x3d
    __del__ = lambda self: None
GMathMatrix3x3d_swigregister = _base.GMathMatrix3x3d_swigregister
GMathMatrix3x3d_swigregister(GMathMatrix3x3d)

def GMathMatrix3x3d_get_identity():
    return _base.GMathMatrix3x3d_get_identity()
GMathMatrix3x3d_get_identity = _base.GMathMatrix3x3d_get_identity

def GMathMatrix3x3d_class_info():
    return _base.GMathMatrix3x3d_class_info()
GMathMatrix3x3d_class_info = _base.GMathMatrix3x3d_class_info

def GMathMatrix3x3d_register_methods(cls):
    return _base.GMathMatrix3x3d_register_methods(cls)
GMathMatrix3x3d_register_methods = _base.GMathMatrix3x3d_register_methods

def GMathMatrix3x3d____class_destructor__(instance, is_array):
    return _base.GMathMatrix3x3d____class_destructor__(instance, is_array)
GMathMatrix3x3d____class_destructor__ = _base.GMathMatrix3x3d____class_destructor__

def GMathMatrix3x3d_multiply(*args):
    return _base.GMathMatrix3x3d_multiply(*args)
GMathMatrix3x3d_multiply = _base.GMathMatrix3x3d_multiply

def GMathMatrix3x3d_multiply_transpose(*args):
    return _base.GMathMatrix3x3d_multiply_transpose(*args)
GMathMatrix3x3d_multiply_transpose = _base.GMathMatrix3x3d_multiply_transpose

class GMathMatrix4x4d(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix4x4d, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix4x4d, name)

    def __init__(self, *args):
        this = _base.new_GMathMatrix4x4d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        get_identity = staticmethod(_base.GMathMatrix4x4d_get_identity)
    else:
        get_identity = _base.GMathMatrix4x4d_get_identity

    def get_copy(self):
        return _base.GMathMatrix4x4d_get_copy(self)

    def copy_from(self, m):
        return _base.GMathMatrix4x4d_copy_from(self, m)

    def copy_to(self, m):
        return _base.GMathMatrix4x4d_copy_to(self, m)

    def __eq__(self, m):

        if not isinstance(obj, type(self)):
            return False


        return _base.GMathMatrix4x4d___eq__(self, m)


    def __ne__(self, m):
        return _base.GMathMatrix4x4d___ne__(self, m)

    def nullify(self):
        return _base.GMathMatrix4x4d_nullify(self)

    def set_identity(self):
        return _base.GMathMatrix4x4d_set_identity(self)

    def make_translation(self, *args):
        return _base.GMathMatrix4x4d_make_translation(self, *args)

    def make_inverse(self, t, r, s):
        return _base.GMathMatrix4x4d_make_inverse(self, t, r, s)

    def make_frame(self, x, y, z):
        return _base.GMathMatrix4x4d_make_frame(self, x, y, z)

    def make_rotation_Z(self, angle_radians):
        return _base.GMathMatrix4x4d_make_rotation_Z(self, angle_radians)

    def make_rotation(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix4x4d_make_rotation(self, r, order)

    def make_scaling(self, *args):
        return _base.GMathMatrix4x4d_make_scaling(self, *args)

    def make_shearing(self, *args):
        return _base.GMathMatrix4x4d_make_shearing(self, *args)

    def make_perspective(self, l, r, b, t, n, f):
        return _base.GMathMatrix4x4d_make_perspective(self, l, r, b, t, n, f)

    def compose(self, *args):
        return _base.GMathMatrix4x4d_compose(self, *args)

    def set_translation(self, t):
        return _base.GMathMatrix4x4d_set_translation(self, t)

    def set_frame(self, x, y, z):
        return _base.GMathMatrix4x4d_set_frame(self, x, y, z)

    def set_rotation(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix4x4d_set_rotation(self, r, order)

    def set_scaling(self, s):
        return _base.GMathMatrix4x4d_set_scaling(self, s)

    def multiply_left(self, m):
        return _base.GMathMatrix4x4d_multiply_left(self, m)

    def multiply_right(self, m):
        return _base.GMathMatrix4x4d_multiply_right(self, m)

    def multiply_transpose_left(self, *args):
        return _base.GMathMatrix4x4d_multiply_transpose_left(self, *args)

    def multiply_transpose_right(self, *args):
        return _base.GMathMatrix4x4d_multiply_transpose_right(self, *args)

    def rotate(self, r, order=GMATH_ROTATION_ORDER_ZXY):
        return _base.GMathMatrix4x4d_rotate(self, r, order)

    def scale(self, *args):
        return _base.GMathMatrix4x4d_scale(self, *args)

    def shear(self, *args):
        return _base.GMathMatrix4x4d_shear(self, *args)
    if _newclass:
        get_inverse = staticmethod(_base.GMathMatrix4x4d_get_inverse)
    else:
        get_inverse = _base.GMathMatrix4x4d_get_inverse

    def invert(self):
        return _base.GMathMatrix4x4d_invert(self)

    def transpose(self, *args):
        return _base.GMathMatrix4x4d_transpose(self, *args)

    def extract_translation(self, *args):
        return _base.GMathMatrix4x4d_extract_translation(self, *args)

    def compute_euler_angles(self, *args):
        return _base.GMathMatrix4x4d_compute_euler_angles(self, *args)

    def decompose(self, *args):
        return _base.GMathMatrix4x4d_decompose(self, *args)

    def extract_rotation(self, r):
        return _base.GMathMatrix4x4d_extract_rotation(self, r)

    def extract_frame(self, x, y, z):
        return _base.GMathMatrix4x4d_extract_frame(self, x, y, z)

    def extract_shearing(self, shear):
        return _base.GMathMatrix4x4d_extract_shearing(self, shear)

    def extract_scaling(self, scale):
        return _base.GMathMatrix4x4d_extract_scaling(self, scale)

    def make_orthonormal(self):
        return _base.GMathMatrix4x4d_make_orthonormal(self)
    if _newclass:
        get_determinant = staticmethod(_base.GMathMatrix4x4d_get_determinant)
    else:
        get_determinant = _base.GMathMatrix4x4d_get_determinant

    def set_item(self, x, y, value):
        return _base.GMathMatrix4x4d_set_item(self, x, y, value)

    def fast_interpolate(self, *args):
        return _base.GMathMatrix4x4d_fast_interpolate(self, *args)

    def equals(self, *args):
        return _base.GMathMatrix4x4d_equals(self, *args)

    def is_finite(self):
        return _base.GMathMatrix4x4d_is_finite(self)

    def get_class_info(self):
        return _base.GMathMatrix4x4d_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix4x4d_class_info)
    else:
        class_info = _base.GMathMatrix4x4d_class_info
    if _newclass:
        register_methods = staticmethod(_base.GMathMatrix4x4d_register_methods)
    else:
        register_methods = _base.GMathMatrix4x4d_register_methods
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix4x4d____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix4x4d____class_destructor__
    if _newclass:
        multiply = staticmethod(_base.GMathMatrix4x4d_multiply)
    else:
        multiply = _base.GMathMatrix4x4d_multiply
    if _newclass:
        multiply_transpose = staticmethod(_base.GMathMatrix4x4d_multiply_transpose)
    else:
        multiply_transpose = _base.GMathMatrix4x4d_multiply_transpose

    def __repr__(self):
        return _base.GMathMatrix4x4d___repr__(self)

    def get_item(self, *args):
        return _base.GMathMatrix4x4d_get_item(self, *args)
    __swig_destroy__ = _base.delete_GMathMatrix4x4d
    __del__ = lambda self: None
GMathMatrix4x4d_swigregister = _base.GMathMatrix4x4d_swigregister
GMathMatrix4x4d_swigregister(GMathMatrix4x4d)

def GMathMatrix4x4d_get_identity():
    return _base.GMathMatrix4x4d_get_identity()
GMathMatrix4x4d_get_identity = _base.GMathMatrix4x4d_get_identity

def GMathMatrix4x4d_get_inverse(m, result):
    return _base.GMathMatrix4x4d_get_inverse(m, result)
GMathMatrix4x4d_get_inverse = _base.GMathMatrix4x4d_get_inverse

def GMathMatrix4x4d_get_determinant(*args):
    return _base.GMathMatrix4x4d_get_determinant(*args)
GMathMatrix4x4d_get_determinant = _base.GMathMatrix4x4d_get_determinant

def GMathMatrix4x4d_class_info():
    return _base.GMathMatrix4x4d_class_info()
GMathMatrix4x4d_class_info = _base.GMathMatrix4x4d_class_info

def GMathMatrix4x4d_register_methods(cls):
    return _base.GMathMatrix4x4d_register_methods(cls)
GMathMatrix4x4d_register_methods = _base.GMathMatrix4x4d_register_methods

def GMathMatrix4x4d____class_destructor__(instance, is_array):
    return _base.GMathMatrix4x4d____class_destructor__(instance, is_array)
GMathMatrix4x4d____class_destructor__ = _base.GMathMatrix4x4d____class_destructor__

def GMathMatrix4x4d_multiply(*args):
    return _base.GMathMatrix4x4d_multiply(*args)
GMathMatrix4x4d_multiply = _base.GMathMatrix4x4d_multiply

def GMathMatrix4x4d_multiply_transpose(*args):
    return _base.GMathMatrix4x4d_multiply_transpose(*args)
GMathMatrix4x4d_multiply_transpose = _base.GMathMatrix4x4d_multiply_transpose

class GMathMatrix3x3dBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix3x3dBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix3x3dBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathMatrix3x3dBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathMatrix3x3dBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix3x3dBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathMatrix3x3dBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathMatrix3x3dBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathMatrix3x3dBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathMatrix3x3dBasicArray_front(self)

    def back(self):
        return _base.GMathMatrix3x3dBasicArray_back(self)

    def exists(self, item):
        return _base.GMathMatrix3x3dBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathMatrix3x3dBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathMatrix3x3dBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathMatrix3x3dBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathMatrix3x3dBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathMatrix3x3dBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathMatrix3x3dBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix3x3dBasicArray_class_info)
    else:
        class_info = _base.GMathMatrix3x3dBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix3x3dBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix3x3dBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathMatrix3x3dBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathMatrix3x3dBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathMatrix3x3dBasicArray_swigregister = _base.GMathMatrix3x3dBasicArray_swigregister
GMathMatrix3x3dBasicArray_swigregister(GMathMatrix3x3dBasicArray)

def GMathMatrix3x3dBasicArray_class_info():
    return _base.GMathMatrix3x3dBasicArray_class_info()
GMathMatrix3x3dBasicArray_class_info = _base.GMathMatrix3x3dBasicArray_class_info

def GMathMatrix3x3dBasicArray____class_destructor__(instance, is_array):
    return _base.GMathMatrix3x3dBasicArray____class_destructor__(instance, is_array)
GMathMatrix3x3dBasicArray____class_destructor__ = _base.GMathMatrix3x3dBasicArray____class_destructor__

class GMathMatrix3x3dArray(GMathMatrix3x3dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathMatrix3x3dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix3x3dArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathMatrix3x3dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix3x3dArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathMatrix3x3dArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix3x3dArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathMatrix3x3dArray_append(self, *args)

    def get_count(self):
        return _base.GMathMatrix3x3dArray_get_count(self)

    def remove_all(self):
        return _base.GMathMatrix3x3dArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathMatrix3x3dArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathMatrix3x3dArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathMatrix3x3dArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathMatrix3x3dArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathMatrix3x3dArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathMatrix3x3dArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathMatrix3x3dArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix3x3dArray_class_info)
    else:
        class_info = _base.GMathMatrix3x3dArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix3x3dArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix3x3dArray____class_destructor__
GMathMatrix3x3dArray_swigregister = _base.GMathMatrix3x3dArray_swigregister
GMathMatrix3x3dArray_swigregister(GMathMatrix3x3dArray)

def GMathMatrix3x3dArray_class_info():
    return _base.GMathMatrix3x3dArray_class_info()
GMathMatrix3x3dArray_class_info = _base.GMathMatrix3x3dArray_class_info

def GMathMatrix3x3dArray____class_destructor__(instance, is_array):
    return _base.GMathMatrix3x3dArray____class_destructor__(instance, is_array)
GMathMatrix3x3dArray____class_destructor__ = _base.GMathMatrix3x3dArray____class_destructor__

class GMathMatrix3x3dVector(GMathMatrix3x3dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathMatrix3x3dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix3x3dVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathMatrix3x3dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix3x3dVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathMatrix3x3dVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix3x3dVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathMatrix3x3dVector_append(self, *args)

    def add(self, element):
        return _base.GMathMatrix3x3dVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathMatrix3x3dVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathMatrix3x3dVector_remove_last(self)

    def empty(self):
        return _base.GMathMatrix3x3dVector_empty(self)

    def remove_all(self):
        return _base.GMathMatrix3x3dVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathMatrix3x3dVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathMatrix3x3dVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathMatrix3x3dVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathMatrix3x3dVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathMatrix3x3dVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathMatrix3x3dVector_get_count(self)

    def get_capacity(self):
        return _base.GMathMatrix3x3dVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathMatrix3x3dVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathMatrix3x3dVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathMatrix3x3dVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathMatrix3x3dVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathMatrix3x3dVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathMatrix3x3dVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathMatrix3x3dVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathMatrix3x3dVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathMatrix3x3dVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathMatrix3x3dVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathMatrix3x3dVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathMatrix3x3dVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathMatrix3x3dVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathMatrix3x3dVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathMatrix3x3dVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathMatrix3x3dVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix3x3dVector_class_info)
    else:
        class_info = _base.GMathMatrix3x3dVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix3x3dVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix3x3dVector____class_destructor__
GMathMatrix3x3dVector_swigregister = _base.GMathMatrix3x3dVector_swigregister
GMathMatrix3x3dVector_swigregister(GMathMatrix3x3dVector)

def GMathMatrix3x3dVector_class_info():
    return _base.GMathMatrix3x3dVector_class_info()
GMathMatrix3x3dVector_class_info = _base.GMathMatrix3x3dVector_class_info

def GMathMatrix3x3dVector____class_destructor__(instance, is_array):
    return _base.GMathMatrix3x3dVector____class_destructor__(instance, is_array)
GMathMatrix3x3dVector____class_destructor__ = _base.GMathMatrix3x3dVector____class_destructor__

class GMathMatrix4x4dBasicArray(CoreBaseType):
    __swig_setmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix4x4dBasicArray, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreBaseType]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix4x4dBasicArray, name)
    __repr__ = _swig_repr
    INVALID_INDEX = _base.GMathMatrix4x4dBasicArray_INVALID_INDEX

    def __init__(self, *args):
        this = _base.new_GMathMatrix4x4dBasicArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix4x4dBasicArray
    __del__ = lambda self: None

    def get_count(self):
        return _base.GMathMatrix4x4dBasicArray_get_count(self)

    def get_item(self, index):
        return _base.GMathMatrix4x4dBasicArray_get_item(self, index)

    def set_item(self, index, item):
        return _base.GMathMatrix4x4dBasicArray_set_item(self, index, item)

    def front(self):
        return _base.GMathMatrix4x4dBasicArray_front(self)

    def back(self):
        return _base.GMathMatrix4x4dBasicArray_back(self)

    def exists(self, item):
        return _base.GMathMatrix4x4dBasicArray_exists(self, item)

    def get_index(self, item):
        return _base.GMathMatrix4x4dBasicArray_get_index(self, item)

    def sub(self, index, count):
        return _base.GMathMatrix4x4dBasicArray_sub(self, index, count)

    def get_memory_size(self):
        return _base.GMathMatrix4x4dBasicArray_get_memory_size(self)

    def begin(self, *args):
        return _base.GMathMatrix4x4dBasicArray_begin(self, *args)

    def end(self, *args):
        return _base.GMathMatrix4x4dBasicArray_end(self, *args)

    def get_class_info(self):
        return _base.GMathMatrix4x4dBasicArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix4x4dBasicArray_class_info)
    else:
        class_info = _base.GMathMatrix4x4dBasicArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix4x4dBasicArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix4x4dBasicArray____class_destructor__

    def __setitem__(self, index, value):
        return _base.GMathMatrix4x4dBasicArray___setitem__(self, index, value)

    def __len__(self):
        return _base.GMathMatrix4x4dBasicArray___len__(self)

    def __getitem__(self, index):
        if (index < self.get_count()):
            return self.get_item(index)
        else:
            raise IndexError("The index (" + str(index) + ") is out of range")
    def __nonzero__(self): return True

GMathMatrix4x4dBasicArray_swigregister = _base.GMathMatrix4x4dBasicArray_swigregister
GMathMatrix4x4dBasicArray_swigregister(GMathMatrix4x4dBasicArray)

def GMathMatrix4x4dBasicArray_class_info():
    return _base.GMathMatrix4x4dBasicArray_class_info()
GMathMatrix4x4dBasicArray_class_info = _base.GMathMatrix4x4dBasicArray_class_info

def GMathMatrix4x4dBasicArray____class_destructor__(instance, is_array):
    return _base.GMathMatrix4x4dBasicArray____class_destructor__(instance, is_array)
GMathMatrix4x4dBasicArray____class_destructor__ = _base.GMathMatrix4x4dBasicArray____class_destructor__

class GMathMatrix4x4dArray(GMathMatrix4x4dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathMatrix4x4dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix4x4dArray, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathMatrix4x4dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix4x4dArray, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathMatrix4x4dArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix4x4dArray
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathMatrix4x4dArray_append(self, *args)

    def get_count(self):
        return _base.GMathMatrix4x4dArray_get_count(self)

    def remove_all(self):
        return _base.GMathMatrix4x4dArray_remove_all(self)

    def resize(self, *args):
        return _base.GMathMatrix4x4dArray_resize(self, *args)

    def copy_from(self, *args):
        return _base.GMathMatrix4x4dArray_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathMatrix4x4dArray_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathMatrix4x4dArray_get_list(self, list)

    def set_list(self, list):
        return _base.GMathMatrix4x4dArray_set_list(self, list)

    def get_memory_size(self):
        return _base.GMathMatrix4x4dArray_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathMatrix4x4dArray_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix4x4dArray_class_info)
    else:
        class_info = _base.GMathMatrix4x4dArray_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix4x4dArray____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix4x4dArray____class_destructor__
GMathMatrix4x4dArray_swigregister = _base.GMathMatrix4x4dArray_swigregister
GMathMatrix4x4dArray_swigregister(GMathMatrix4x4dArray)

def GMathMatrix4x4dArray_class_info():
    return _base.GMathMatrix4x4dArray_class_info()
GMathMatrix4x4dArray_class_info = _base.GMathMatrix4x4dArray_class_info

def GMathMatrix4x4dArray____class_destructor__(instance, is_array):
    return _base.GMathMatrix4x4dArray____class_destructor__(instance, is_array)
GMathMatrix4x4dArray____class_destructor__ = _base.GMathMatrix4x4dArray____class_destructor__

class GMathMatrix4x4dVector(GMathMatrix4x4dBasicArray):
    __swig_setmethods__ = {}
    for _s in [GMathMatrix4x4dBasicArray]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GMathMatrix4x4dVector, name, value)
    __swig_getmethods__ = {}
    for _s in [GMathMatrix4x4dBasicArray]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, GMathMatrix4x4dVector, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_GMathMatrix4x4dVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_GMathMatrix4x4dVector
    __del__ = lambda self: None

    def append(self, *args):
        return _base.GMathMatrix4x4dVector_append(self, *args)

    def add(self, element):
        return _base.GMathMatrix4x4dVector_add(self, element)

    def insert(self, element, index):
        return _base.GMathMatrix4x4dVector_insert(self, element, index)

    def remove_last(self):
        return _base.GMathMatrix4x4dVector_remove_last(self)

    def empty(self):
        return _base.GMathMatrix4x4dVector_empty(self)

    def remove_all(self):
        return _base.GMathMatrix4x4dVector_remove_all(self)

    def clear(self, *args):
        return _base.GMathMatrix4x4dVector_clear(self, *args)

    def remove(self, *args):
        return _base.GMathMatrix4x4dVector_remove(self, *args)

    def is_empty(self):
        return _base.GMathMatrix4x4dVector_is_empty(self)

    def remove_item(self, item, preserve_order):
        return _base.GMathMatrix4x4dVector_remove_item(self, item, preserve_order)

    def remove_items(self, item):
        return _base.GMathMatrix4x4dVector_remove_items(self, item)

    def get_count(self):
        return _base.GMathMatrix4x4dVector_get_count(self)

    def get_capacity(self):
        return _base.GMathMatrix4x4dVector_get_capacity(self)

    def set_count(self, *args):
        return _base.GMathMatrix4x4dVector_set_count(self, *args)

    def set_capacity(self, *args):
        return _base.GMathMatrix4x4dVector_set_capacity(self, *args)

    def refit(self):
        return _base.GMathMatrix4x4dVector_refit(self)

    def swap(self, swap_v1, swap_v2):
        return _base.GMathMatrix4x4dVector_swap(self, swap_v1, swap_v2)

    def resize(self, *args):
        return _base.GMathMatrix4x4dVector_resize(self, *args)

    def reserve(self, *args):
        return _base.GMathMatrix4x4dVector_reserve(self, *args)

    def copy_from(self, *args):
        return _base.GMathMatrix4x4dVector_copy_from(self, *args)

    def copy_to(self, dest):
        return _base.GMathMatrix4x4dVector_copy_to(self, dest)

    def get_list(self, list):
        return _base.GMathMatrix4x4dVector_get_list(self, list)

    def set_list(self, list):
        return _base.GMathMatrix4x4dVector_set_list(self, list)

    def get_array(self, array):
        return _base.GMathMatrix4x4dVector_get_array(self, array)

    def set_array(self, array):
        return _base.GMathMatrix4x4dVector_set_array(self, array)

    def move(self, arg2, to):
        return _base.GMathMatrix4x4dVector_move(self, arg2, to)

    def item(self, index):
        return _base.GMathMatrix4x4dVector_item(self, index)

    def get_memory_size(self):
        return _base.GMathMatrix4x4dVector_get_memory_size(self)

    def get_class_info(self):
        return _base.GMathMatrix4x4dVector_get_class_info(self)
    if _newclass:
        class_info = staticmethod(_base.GMathMatrix4x4dVector_class_info)
    else:
        class_info = _base.GMathMatrix4x4dVector_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.GMathMatrix4x4dVector____class_destructor__)
    else:
        ___class_destructor__ = _base.GMathMatrix4x4dVector____class_destructor__
GMathMatrix4x4dVector_swigregister = _base.GMathMatrix4x4dVector_swigregister
GMathMatrix4x4dVector_swigregister(GMathMatrix4x4dVector)

def GMathMatrix4x4dVector_class_info():
    return _base.GMathMatrix4x4dVector_class_info()
GMathMatrix4x4dVector_class_info = _base.GMathMatrix4x4dVector_class_info

def GMathMatrix4x4dVector____class_destructor__(instance, is_array):
    return _base.GMathMatrix4x4dVector____class_destructor__(instance, is_array)
GMathMatrix4x4dVector____class_destructor__ = _base.GMathMatrix4x4dVector____class_destructor__

class EventObject(CoreCustomData):
    __swig_setmethods__ = {}
    for _s in [CoreCustomData]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EventObject, name, value)
    __swig_getmethods__ = {}
    for _s in [CoreCustomData]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EventObject, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_EventObject(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_EventObject
    __del__ = lambda self: None

    def disconnect_all(self, *args):
        return _base.EventObject_disconnect_all(self, *args)

    def remove_all_connection(self):
        return _base.EventObject_remove_all_connection(self)

    def is_connected(self, sender, event_id, data):
        return _base.EventObject_is_connected(self, sender, event_id, data)

    def set_mute(self, mute):
        return _base.EventObject_set_mute(self, mute)

    def is_mute(self):
        return _base.EventObject_is_mute(self)
    if _newclass:
        raise_event = staticmethod(_base.EventObject_raise_event)
    else:
        raise_event = _base.EventObject_raise_event

    def disconnect(self, *args):
        return _base.EventObject_disconnect(self, *args)

    def get_sender_count(self):
        return _base.EventObject_get_sender_count(self)

    def get_receiver_count(self):
        return _base.EventObject_get_receiver_count(self)

    def get_memory_size(self):
        return _base.EventObject_get_memory_size(self)
    if _newclass:
        class_info = staticmethod(_base.EventObject_class_info)
    else:
        class_info = _base.EventObject_class_info
    if _newclass:
        ___class_destructor__ = staticmethod(_base.EventObject____class_destructor__)
    else:
        ___class_destructor__ = _base.EventObject____class_destructor__

    def get_class_info(self):
        return _base.EventObject_get_class_info(self)

    def __event_object_callback_wrapper__(self, sender, evtid, method):
        return _base.EventObject___event_object_callback_wrapper__(self, sender, evtid, method)

    def connect(self, sender, eventid, method):
        if not issubclass(sender.__class__, EventObject):
            raise TypeError('The specified sender should inherit from EventObject.')
        if isinstance(eventid, basestring) == False:
            raise TypeError('The specified eventid should be a string.')
        if getattr(method, '__call__') == None or issubclass(getattr(method, 'im_class'), self.__class__) == False:
            raise TypeError('The specified method should be a method of class ' + self.__class__.__name__  + '.')
        if getattr(self.__class__, method.__name__).func_code.co_argcount != 3:
            raise TypeError('The specified method prototype mismatch, expecting:\ndef method(self, sender, eventid).')
        self.__event_object_callback_wrapper__(sender, eventid, method)

EventObject_swigregister = _base.EventObject_swigregister
EventObject_swigregister(EventObject)
EVT_ID_DESTROY = cvar.EVT_ID_DESTROY

def EventObject_raise_event(*args):
    return _base.EventObject_raise_event(*args)
EventObject_raise_event = _base.EventObject_raise_event

def EventObject_class_info():
    return _base.EventObject_class_info()
EventObject_class_info = _base.EventObject_class_info

def EventObject____class_destructor__(instance, is_array):
    return _base.EventObject____class_destructor__(instance, is_array)
EventObject____class_destructor__ = _base.EventObject____class_destructor__

class PyEventObjectHandler(EventObject):
    __swig_setmethods__ = {}
    for _s in [EventObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PyEventObjectHandler, name, value)
    __swig_getmethods__ = {}
    for _s in [EventObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PyEventObjectHandler, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _base.new_PyEventObjectHandler()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_PyEventObjectHandler
    __del__ = lambda self: None

    def cleanup(self):
        return _base.PyEventObjectHandler_cleanup(self)
PyEventObjectHandler_swigregister = _base.PyEventObjectHandler_swigregister
PyEventObjectHandler_swigregister(PyEventObjectHandler)

class SysStatMemory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatMemory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatMemory, name)
    __repr__ = _swig_repr
    __swig_setmethods__["total"] = _base.SysStatMemory_total_set
    __swig_getmethods__["total"] = _base.SysStatMemory_total_get
    if _newclass:
        total = _swig_property(_base.SysStatMemory_total_get, _base.SysStatMemory_total_set)
    __swig_setmethods__["peak"] = _base.SysStatMemory_peak_set
    __swig_getmethods__["peak"] = _base.SysStatMemory_peak_get
    if _newclass:
        peak = _swig_property(_base.SysStatMemory_peak_get, _base.SysStatMemory_peak_set)
    __swig_setmethods__["unaccounted"] = _base.SysStatMemory_unaccounted_set
    __swig_getmethods__["unaccounted"] = _base.SysStatMemory_unaccounted_get
    if _newclass:
        unaccounted = _swig_property(_base.SysStatMemory_unaccounted_get, _base.SysStatMemory_unaccounted_set)
    __swig_setmethods__["free"] = _base.SysStatMemory_free_set
    __swig_getmethods__["free"] = _base.SysStatMemory_free_get
    if _newclass:
        free = _swig_property(_base.SysStatMemory_free_get, _base.SysStatMemory_free_set)

    def __init__(self):
        this = _base.new_SysStatMemory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatMemory
    __del__ = lambda self: None
SysStatMemory_swigregister = _base.SysStatMemory_swigregister
SysStatMemory_swigregister(SysStatMemory)

class SysStatApplication(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatApplication, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatApplication, name)
    __repr__ = _swig_repr
    __swig_setmethods__["core"] = _base.SysStatApplication_core_set
    __swig_getmethods__["core"] = _base.SysStatApplication_core_get
    if _newclass:
        core = _swig_property(_base.SysStatApplication_core_get, _base.SysStatApplication_core_set)
    __swig_setmethods__["image_history"] = _base.SysStatApplication_image_history_set
    __swig_getmethods__["image_history"] = _base.SysStatApplication_image_history_get
    if _newclass:
        image_history = _swig_property(_base.SysStatApplication_image_history_get, _base.SysStatApplication_image_history_set)
    __swig_setmethods__["widgets"] = _base.SysStatApplication_widgets_set
    __swig_getmethods__["widgets"] = _base.SysStatApplication_widgets_get
    if _newclass:
        widgets = _swig_property(_base.SysStatApplication_widgets_get, _base.SysStatApplication_widgets_set)
    __swig_setmethods__["total"] = _base.SysStatApplication_total_set
    __swig_getmethods__["total"] = _base.SysStatApplication_total_get
    if _newclass:
        total = _swig_property(_base.SysStatApplication_total_get, _base.SysStatApplication_total_set)

    def __init__(self):
        this = _base.new_SysStatApplication()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatApplication
    __del__ = lambda self: None
SysStatApplication_swigregister = _base.SysStatApplication_swigregister
SysStatApplication_swigregister(SysStatApplication)

class SysStatSceneMemory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatSceneMemory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatSceneMemory, name)
    __repr__ = _swig_repr
    __swig_setmethods__["total"] = _base.SysStatSceneMemory_total_set
    __swig_getmethods__["total"] = _base.SysStatSceneMemory_total_get
    if _newclass:
        total = _swig_property(_base.SysStatSceneMemory_total_get, _base.SysStatSceneMemory_total_set)
    __swig_setmethods__["factory"] = _base.SysStatSceneMemory_factory_set
    __swig_getmethods__["factory"] = _base.SysStatSceneMemory_factory_get
    if _newclass:
        factory = _swig_property(_base.SysStatSceneMemory_factory_get, _base.SysStatSceneMemory_factory_set)
    __swig_setmethods__["objects"] = _base.SysStatSceneMemory_objects_set
    __swig_getmethods__["objects"] = _base.SysStatSceneMemory_objects_get
    if _newclass:
        objects = _swig_property(_base.SysStatSceneMemory_objects_get, _base.SysStatSceneMemory_objects_set)
    __swig_setmethods__["attributes"] = _base.SysStatSceneMemory_attributes_set
    __swig_getmethods__["attributes"] = _base.SysStatSceneMemory_attributes_get
    if _newclass:
        attributes = _swig_property(_base.SysStatSceneMemory_attributes_get, _base.SysStatSceneMemory_attributes_set)
    __swig_setmethods__["modules"] = _base.SysStatSceneMemory_modules_set
    __swig_getmethods__["modules"] = _base.SysStatSceneMemory_modules_get
    if _newclass:
        modules = _swig_property(_base.SysStatSceneMemory_modules_get, _base.SysStatSceneMemory_modules_set)

    def __init__(self):
        this = _base.new_SysStatSceneMemory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatSceneMemory
    __del__ = lambda self: None
SysStatSceneMemory_swigregister = _base.SysStatSceneMemory_swigregister
SysStatSceneMemory_swigregister(SysStatSceneMemory)

class SysStatSceneCount(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatSceneCount, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatSceneCount, name)
    __repr__ = _swig_repr
    __swig_setmethods__["objects"] = _base.SysStatSceneCount_objects_set
    __swig_getmethods__["objects"] = _base.SysStatSceneCount_objects_get
    if _newclass:
        objects = _swig_property(_base.SysStatSceneCount_objects_get, _base.SysStatSceneCount_objects_set)
    __swig_setmethods__["attributes"] = _base.SysStatSceneCount_attributes_set
    __swig_getmethods__["attributes"] = _base.SysStatSceneCount_attributes_get
    if _newclass:
        attributes = _swig_property(_base.SysStatSceneCount_attributes_get, _base.SysStatSceneCount_attributes_set)
    __swig_setmethods__["local_attributes"] = _base.SysStatSceneCount_local_attributes_set
    __swig_getmethods__["local_attributes"] = _base.SysStatSceneCount_local_attributes_get
    if _newclass:
        local_attributes = _swig_property(_base.SysStatSceneCount_local_attributes_get, _base.SysStatSceneCount_local_attributes_set)
    __swig_setmethods__["values"] = _base.SysStatSceneCount_values_set
    __swig_getmethods__["values"] = _base.SysStatSceneCount_values_get
    if _newclass:
        values = _swig_property(_base.SysStatSceneCount_values_get, _base.SysStatSceneCount_values_set)

    def __init__(self):
        this = _base.new_SysStatSceneCount()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatSceneCount
    __del__ = lambda self: None
SysStatSceneCount_swigregister = _base.SysStatSceneCount_swigregister
SysStatSceneCount_swigregister(SysStatSceneCount)

class SysStatScene(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatScene, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatScene, name)
    __repr__ = _swig_repr
    __swig_setmethods__["memory"] = _base.SysStatScene_memory_set
    __swig_getmethods__["memory"] = _base.SysStatScene_memory_get
    if _newclass:
        memory = _swig_property(_base.SysStatScene_memory_get, _base.SysStatScene_memory_set)
    __swig_setmethods__["count"] = _base.SysStatScene_count_set
    __swig_getmethods__["count"] = _base.SysStatScene_count_get
    if _newclass:
        count = _swig_property(_base.SysStatScene_count_get, _base.SysStatScene_count_set)

    def __init__(self):
        this = _base.new_SysStatScene()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatScene
    __del__ = lambda self: None
SysStatScene_swigregister = _base.SysStatScene_swigregister
SysStatScene_swigregister(SysStatScene)

class SysStatResourceMemory(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatResourceMemory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatResourceMemory, name)
    __repr__ = _swig_repr
    __swig_setmethods__["total"] = _base.SysStatResourceMemory_total_set
    __swig_getmethods__["total"] = _base.SysStatResourceMemory_total_get
    if _newclass:
        total = _swig_property(_base.SysStatResourceMemory_total_get, _base.SysStatResourceMemory_total_set)
    __swig_setmethods__["texture_cache"] = _base.SysStatResourceMemory_texture_cache_set
    __swig_getmethods__["texture_cache"] = _base.SysStatResourceMemory_texture_cache_get
    if _newclass:
        texture_cache = _swig_property(_base.SysStatResourceMemory_texture_cache_get, _base.SysStatResourceMemory_texture_cache_set)
    __swig_setmethods__["streamed_texture_cache"] = _base.SysStatResourceMemory_streamed_texture_cache_set
    __swig_getmethods__["streamed_texture_cache"] = _base.SysStatResourceMemory_streamed_texture_cache_get
    if _newclass:
        streamed_texture_cache = _swig_property(_base.SysStatResourceMemory_streamed_texture_cache_get, _base.SysStatResourceMemory_streamed_texture_cache_set)
    __swig_setmethods__["geometries"] = _base.SysStatResourceMemory_geometries_set
    __swig_getmethods__["geometries"] = _base.SysStatResourceMemory_geometries_get
    if _newclass:
        geometries = _swig_property(_base.SysStatResourceMemory_geometries_get, _base.SysStatResourceMemory_geometries_set)
    __swig_setmethods__["accels"] = _base.SysStatResourceMemory_accels_set
    __swig_getmethods__["accels"] = _base.SysStatResourceMemory_accels_get
    if _newclass:
        accels = _swig_property(_base.SysStatResourceMemory_accels_get, _base.SysStatResourceMemory_accels_set)
    __swig_setmethods__["images"] = _base.SysStatResourceMemory_images_set
    __swig_getmethods__["images"] = _base.SysStatResourceMemory_images_get
    if _newclass:
        images = _swig_property(_base.SysStatResourceMemory_images_get, _base.SysStatResourceMemory_images_set)
    __swig_setmethods__["empty"] = _base.SysStatResourceMemory_empty_set
    __swig_getmethods__["empty"] = _base.SysStatResourceMemory_empty_get
    if _newclass:
        empty = _swig_property(_base.SysStatResourceMemory_empty_get, _base.SysStatResourceMemory_empty_set)
    __swig_setmethods__["misc"] = _base.SysStatResourceMemory_misc_set
    __swig_getmethods__["misc"] = _base.SysStatResourceMemory_misc_get
    if _newclass:
        misc = _swig_property(_base.SysStatResourceMemory_misc_get, _base.SysStatResourceMemory_misc_set)

    def __init__(self):
        this = _base.new_SysStatResourceMemory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatResourceMemory
    __del__ = lambda self: None
SysStatResourceMemory_swigregister = _base.SysStatResourceMemory_swigregister
SysStatResourceMemory_swigregister(SysStatResourceMemory)

class SysStatResourceCount(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatResourceCount, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatResourceCount, name)
    __repr__ = _swig_repr
    __swig_setmethods__["total"] = _base.SysStatResourceCount_total_set
    __swig_getmethods__["total"] = _base.SysStatResourceCount_total_get
    if _newclass:
        total = _swig_property(_base.SysStatResourceCount_total_get, _base.SysStatResourceCount_total_set)
    __swig_setmethods__["geometries"] = _base.SysStatResourceCount_geometries_set
    __swig_getmethods__["geometries"] = _base.SysStatResourceCount_geometries_get
    if _newclass:
        geometries = _swig_property(_base.SysStatResourceCount_geometries_get, _base.SysStatResourceCount_geometries_set)
    __swig_setmethods__["accels"] = _base.SysStatResourceCount_accels_set
    __swig_getmethods__["accels"] = _base.SysStatResourceCount_accels_get
    if _newclass:
        accels = _swig_property(_base.SysStatResourceCount_accels_get, _base.SysStatResourceCount_accels_set)
    __swig_setmethods__["images"] = _base.SysStatResourceCount_images_set
    __swig_getmethods__["images"] = _base.SysStatResourceCount_images_get
    if _newclass:
        images = _swig_property(_base.SysStatResourceCount_images_get, _base.SysStatResourceCount_images_set)
    __swig_setmethods__["empty"] = _base.SysStatResourceCount_empty_set
    __swig_getmethods__["empty"] = _base.SysStatResourceCount_empty_get
    if _newclass:
        empty = _swig_property(_base.SysStatResourceCount_empty_get, _base.SysStatResourceCount_empty_set)
    __swig_setmethods__["misc"] = _base.SysStatResourceCount_misc_set
    __swig_getmethods__["misc"] = _base.SysStatResourceCount_misc_get
    if _newclass:
        misc = _swig_property(_base.SysStatResourceCount_misc_get, _base.SysStatResourceCount_misc_set)

    def __init__(self):
        this = _base.new_SysStatResourceCount()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatResourceCount
    __del__ = lambda self: None
SysStatResourceCount_swigregister = _base.SysStatResourceCount_swigregister
SysStatResourceCount_swigregister(SysStatResourceCount)

class SysStatResource(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatResource, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatResource, name)
    __repr__ = _swig_repr
    __swig_setmethods__["memory"] = _base.SysStatResource_memory_set
    __swig_getmethods__["memory"] = _base.SysStatResource_memory_get
    if _newclass:
        memory = _swig_property(_base.SysStatResource_memory_get, _base.SysStatResource_memory_set)
    __swig_setmethods__["count"] = _base.SysStatResource_count_set
    __swig_getmethods__["count"] = _base.SysStatResource_count_get
    if _newclass:
        count = _swig_property(_base.SysStatResource_count_get, _base.SysStatResource_count_set)

    def __init__(self):
        this = _base.new_SysStatResource()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatResource
    __del__ = lambda self: None
SysStatResource_swigregister = _base.SysStatResource_swigregister
SysStatResource_swigregister(SysStatResource)

class SysStatLiteResource(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatLiteResource, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatLiteResource, name)
    __repr__ = _swig_repr
    __swig_setmethods__["memory"] = _base.SysStatLiteResource_memory_set
    __swig_getmethods__["memory"] = _base.SysStatLiteResource_memory_get
    if _newclass:
        memory = _swig_property(_base.SysStatLiteResource_memory_get, _base.SysStatLiteResource_memory_set)
    __swig_setmethods__["count"] = _base.SysStatLiteResource_count_set
    __swig_getmethods__["count"] = _base.SysStatLiteResource_count_get
    if _newclass:
        count = _swig_property(_base.SysStatLiteResource_count_get, _base.SysStatLiteResource_count_set)

    def __init__(self):
        this = _base.new_SysStatLiteResource()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_SysStatLiteResource
    __del__ = lambda self: None
SysStatLiteResource_swigregister = _base.SysStatLiteResource_swigregister
SysStatLiteResource_swigregister(SysStatLiteResource)

class SysStatistic(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SysStatistic, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SysStatistic, name)
    __repr__ = _swig_repr
    __swig_setmethods__["memory"] = _base.SysStatistic_memory_set
    __swig_getmethods__["memory"] = _base.SysStatistic_memory_get
    if _newclass:
        memory = _swig_property(_base.SysStatistic_memory_get, _base.SysStatistic_memory_set)
    __swig_setmethods__["application"] = _base.SysStatistic_application_set
    __swig_getmethods__["application"] = _base.SysStatistic_application_get
    if _newclass:
        application = _swig_property(_base.SysStatistic_application_get, _base.SysStatistic_application_set)
    __swig_setmethods__["scene"] = _base.SysStatistic_scene_set
    __swig_getmethods__["scene"] = _base.SysStatistic_scene_get
    if _newclass:
        scene = _swig_property(_base.SysStatistic_scene_get, _base.SysStatistic_scene_set)
    __swig_setmethods__["resource"] = _base.SysStatistic_resource_set
    __swig_getmethods__["resource"] = _base.SysStatistic_resource_get
    if _newclass:
        resource = _swig_property(_base.SysStatistic_resource_get, _base.SysStatistic_resource_set)
    __swig_setmethods__["lite_resource"] = _base.SysStatistic_lite_resource_set
    __swig_getmethods__["lite_resource"] = _base.SysStatistic_lite_resource_get
    if _newclass:
        lite_resource = _swig_property(_base.SysStatistic_lite_resource_get, _base.SysStatistic_lite_resource_set)

    def __init__(self):
        this = _base.new_SysStatistic()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get_digest(self):
        return _base.SysStatistic_get_digest(self)
    if _newclass:
        get_readable_size = staticmethod(_base.SysStatistic_get_readable_size)
    else:
        get_readable_size = _base.SysStatistic_get_readable_size
    __swig_destroy__ = _base.delete_SysStatistic
    __del__ = lambda self: None
SysStatistic_swigregister = _base.SysStatistic_swigregister
SysStatistic_swigregister(SysStatistic)

def SysStatistic_get_readable_size(size):
    return _base.SysStatistic_get_readable_size(size)
SysStatistic_get_readable_size = _base.SysStatistic_get_readable_size

class ParserEntry(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParserEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParserEntry, name)
    __repr__ = _swig_repr
    TYPE_REGULAR = _base.ParserEntry_TYPE_REGULAR
    TYPE_KEYWORD = _base.ParserEntry_TYPE_KEYWORD
    TYPE_FUNCTION = _base.ParserEntry_TYPE_FUNCTION
    TYPE_RAW_TEXT = _base.ParserEntry_TYPE_RAW_TEXT

    def __init__(self, *args):
        this = _base.new_ParserEntry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ParserEntry
    __del__ = lambda self: None

    def copy_from(self, entry):
        return _base.ParserEntry_copy_from(self, entry)

    def get_name(self):
        return _base.ParserEntry_get_name(self)

    def rename(self, name):
        return _base.ParserEntry_rename(self, name)

    def get_line(self):
        return _base.ParserEntry_get_line(self)

    def get_column(self):
        return _base.ParserEntry_get_column(self)

    def get_value_count(self):
        return _base.ParserEntry_get_value_count(self)

    def get_value_type(self, index=0):
        return _base.ParserEntry_get_value_type(self, index)

    def reset(self):
        return _base.ParserEntry_reset(self)

    def is_group(self):
        return _base.ParserEntry_is_group(self)

    def get_type(self):
        return _base.ParserEntry_get_type(self)

    def is_array(self):
        return _base.ParserEntry_is_array(self)

    def set_array(self, flag, count=0):
        return _base.ParserEntry_set_array(self, flag, count)

    def get_array_count(self):
        return _base.ParserEntry_get_array_count(self)

    def is_template(self):
        return _base.ParserEntry_is_template(self)

    def set_template(self, type):
        return _base.ParserEntry_set_template(self, type)

    def get_template(self):
        return _base.ParserEntry_get_template(self)

    def set_as_raw_text(self, is_raw_text):
        return _base.ParserEntry_set_as_raw_text(self, is_raw_text)

    def is_value_bool(self, index=0):
        return _base.ParserEntry_is_value_bool(self, index)

    def is_value_char(self, index=0):
        return _base.ParserEntry_is_value_char(self, index)

    def is_value_int(self, index=0):
        return _base.ParserEntry_is_value_int(self, index)

    def is_value_double(self, index=0):
        return _base.ParserEntry_is_value_double(self, index)

    def is_value_string(self, index=0):
        return _base.ParserEntry_is_value_string(self, index)

    def is_value_group(self, index=0):
        return _base.ParserEntry_is_value_group(self, index)

    def add_bool(self, value):
        return _base.ParserEntry_add_bool(self, value)

    def add_char(self, value):
        return _base.ParserEntry_add_char(self, value)

    def add_int(self, value):
        return _base.ParserEntry_add_int(self, value)

    def add_double(self, value):
        return _base.ParserEntry_add_double(self, value)

    def add_vec2i(self, value):
        return _base.ParserEntry_add_vec2i(self, value)

    def add_vec2d(self, value):
        return _base.ParserEntry_add_vec2d(self, value)

    def add_vec3d(self, value):
        return _base.ParserEntry_add_vec3d(self, value)

    def add_vec4d(self, value):
        return _base.ParserEntry_add_vec4d(self, value)

    def add_string(self, value):
        return _base.ParserEntry_add_string(self, value)

    def add_binary_data(self, data, size):
        return _base.ParserEntry_add_binary_data(self, data, size)

    def add_word(self, *args):
        return _base.ParserEntry_add_word(self, *args)

    def add_group(self, group=None):
        return _base.ParserEntry_add_group(self, group)

    def remove_value(self, *args):
        return _base.ParserEntry_remove_value(self, *args)

    def move_value(self, arg2, to):
        return _base.ParserEntry_move_value(self, arg2, to)

    def has_value(self):
        return _base.ParserEntry_has_value(self)

    def get_bool(self, index=0):
        return _base.ParserEntry_get_bool(self, index)

    def get_char(self, index=0):
        return _base.ParserEntry_get_char(self, index)

    def get_int(self, index=0):
        return _base.ParserEntry_get_int(self, index)

    def get_double(self, index=0):
        return _base.ParserEntry_get_double(self, index)

    def get_vec2i(self, index=0):
        return _base.ParserEntry_get_vec2i(self, index)

    def get_vec2d(self, index=0):
        return _base.ParserEntry_get_vec2d(self, index)

    def get_vec3d(self, index=0):
        return _base.ParserEntry_get_vec3d(self, index)

    def get_vec4d(self, index=0):
        return _base.ParserEntry_get_vec4d(self, index)

    def get_string(self, index=0):
        return _base.ParserEntry_get_string(self, index)

    def get_binary_data(self, index=0):
        return _base.ParserEntry_get_binary_data(self, index)

    def get_binary_data_size(self, index=0):
        return _base.ParserEntry_get_binary_data_size(self, index)

    def get_word(self, index=0):
        return _base.ParserEntry_get_word(self, index)

    def get_group(self, index=0):
        return _base.ParserEntry_get_group(self, index)

    def set_bool(self, value, index=0):
        return _base.ParserEntry_set_bool(self, value, index)

    def set_int(self, value, index=0):
        return _base.ParserEntry_set_int(self, value, index)

    def set_double(self, value, index=0):
        return _base.ParserEntry_set_double(self, value, index)

    def set_string(self, value, index=0):
        return _base.ParserEntry_set_string(self, value, index)

    def set_binary_data(self, data, size, index=0):
        return _base.ParserEntry_set_binary_data(self, data, size, index)

    def get_text(self, text, multiline=False, offset=1):
        return _base.ParserEntry_get_text(self, text, multiline, offset)

    def get_value_text(self, text, multiline=False, offset=1):
        return _base.ParserEntry_get_value_text(self, text, multiline, offset)

    def get_encrypted_text(self, *args):
        return _base.ParserEntry_get_encrypted_text(self, *args)

    def get_binary(self):
        return _base.ParserEntry_get_binary(self)

    def set_binary(self, buffer, position):
        return _base.ParserEntry_set_binary(self, buffer, position)
ParserEntry_swigregister = _base.ParserEntry_swigregister
ParserEntry_swigregister(ParserEntry)

class ParserFile(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParserFile, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParserFile, name)
    __repr__ = _swig_repr
    MODE_TEXT = _base.ParserFile_MODE_TEXT
    MODE_BINARY = _base.ParserFile_MODE_BINARY

    def __init__(self, *args):
        this = _base.new_ParserFile(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ParserFile
    __del__ = lambda self: None

    def get_filename(self):
        return _base.ParserFile_get_filename(self)

    def set_filename(self, filename):
        return _base.ParserFile_set_filename(self, filename)

    def get_root(self):
        return _base.ParserFile_get_root(self)

    def get_text(self, text):
        return _base.ParserFile_get_text(self, text)

    def get_binary(self):
        return _base.ParserFile_get_binary(self)

    def set_binary(self, buffer):
        return _base.ParserFile_set_binary(self, buffer)

    def read(self, *args):
        return _base.ParserFile_read(self, *args)

    def write(self, *args):
        return _base.ParserFile_write(self, *args)

    def clear(self):
        return _base.ParserFile_clear(self)

    def get_search_paths(self):
        return _base.ParserFile_get_search_paths(self)

    def set_search_paths(self, paths):
        return _base.ParserFile_set_search_paths(self, paths)

    def is_encrypted(self):
        return _base.ParserFile_is_encrypted(self)

    def get_serial_version(self):
        return _base.ParserFile_get_serial_version(self)

    def get_dependencies(self):
        return _base.ParserFile_get_dependencies(self)
ParserFile_swigregister = _base.ParserFile_swigregister
ParserFile_swigregister(ParserFile)

class ParserGroup(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParserGroup, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParserGroup, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ParserGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ParserGroup
    __del__ = lambda self: None

    def add_entry(self, name, line=0, column=0):
        return _base.ParserGroup_add_entry(self, name, line, column)

    def add_group(self, name):
        return _base.ParserGroup_add_group(self, name)

    def move_entry(self, *args):
        return _base.ParserGroup_move_entry(self, *args)

    def detach_entry(self, index):
        return _base.ParserGroup_detach_entry(self, index)

    def move_entries(self, group):
        return _base.ParserGroup_move_entries(self, group)

    def remove_entry(self, name):
        return _base.ParserGroup_remove_entry(self, name)

    def get_name(self):
        return _base.ParserGroup_get_name(self)

    def get_entry_count(self):
        return _base.ParserGroup_get_entry_count(self)

    def get_entry(self, *args):
        return _base.ParserGroup_get_entry(self, *args)

    def get_entries(self, entry_name):
        return _base.ParserGroup_get_entries(self, entry_name)

    def get_keyword(self, name):
        return _base.ParserGroup_get_keyword(self, name)

    def get_text(self, text, with_header, multiline=True, offset=1):
        return _base.ParserGroup_get_text(self, text, with_header, multiline, offset)

    def set_text(self, *args):
        return _base.ParserGroup_set_text(self, *args)

    def get_encrypted_text(self, *args):
        return _base.ParserGroup_get_encrypted_text(self, *args)

    def set_encrypted_text(self, *args):
        return _base.ParserGroup_set_encrypted_text(self, *args)

    def set_source_entry(self, entry):
        return _base.ParserGroup_set_source_entry(self, entry)

    def get_source_entry(self):
        return _base.ParserGroup_get_source_entry(self)

    def get_binary(self, named):
        return _base.ParserGroup_get_binary(self, named)

    def set_binary(self, buffer, position):
        return _base.ParserGroup_set_binary(self, buffer, position)

    def set(self, group):
        return _base.ParserGroup_set(self, group)

    def clear(self):
        return _base.ParserGroup_clear(self)
ParserGroup_swigregister = _base.ParserGroup_swigregister
ParserGroup_swigregister(ParserGroup)

class ParserValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParserValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParserValue, name)
    __repr__ = _swig_repr
    TYPE_UNKNOWN = _base.ParserValue_TYPE_UNKNOWN
    TYPE_GROUP = _base.ParserValue_TYPE_GROUP
    TYPE_BOOL = _base.ParserValue_TYPE_BOOL
    TYPE_CHAR = _base.ParserValue_TYPE_CHAR
    TYPE_INT = _base.ParserValue_TYPE_INT
    TYPE_DOUBLE = _base.ParserValue_TYPE_DOUBLE
    TYPE_STRING = _base.ParserValue_TYPE_STRING
    TYPE_BINARY_DATA = _base.ParserValue_TYPE_BINARY_DATA
    TYPE_WORD = _base.ParserValue_TYPE_WORD
    if _newclass:
        get_type_name = staticmethod(_base.ParserValue_get_type_name)
    else:
        get_type_name = _base.ParserValue_get_type_name

    def __init__(self, *args):
        this = _base.new_ParserValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ParserValue
    __del__ = lambda self: None

    def set_bool(self, value):
        return _base.ParserValue_set_bool(self, value)

    def set_char(self, value):
        return _base.ParserValue_set_char(self, value)

    def set_int(self, value):
        return _base.ParserValue_set_int(self, value)

    def set_double(self, value):
        return _base.ParserValue_set_double(self, value)

    def set_string(self, value):
        return _base.ParserValue_set_string(self, value)

    def set_binary_data(self, data, size):
        return _base.ParserValue_set_binary_data(self, data, size)

    def get_as_bool(self):
        return _base.ParserValue_get_as_bool(self)

    def get_as_char(self):
        return _base.ParserValue_get_as_char(self)

    def get_as_int(self):
        return _base.ParserValue_get_as_int(self)

    def get_as_double(self):
        return _base.ParserValue_get_as_double(self)

    def get_as_binary_data(self, size):
        return _base.ParserValue_get_as_binary_data(self, size)

    def get_as_string(self):
        return _base.ParserValue_get_as_string(self)

    def get_text(self, text, multiline, offset):
        return _base.ParserValue_get_text(self, text, multiline, offset)
    __swig_setmethods__["m_type"] = _base.ParserValue_m_type_set
    __swig_getmethods__["m_type"] = _base.ParserValue_m_type_get
    if _newclass:
        m_type = _swig_property(_base.ParserValue_m_type_get, _base.ParserValue_m_type_set)
    __swig_setmethods__["m_has_value"] = _base.ParserValue_m_has_value_set
    __swig_getmethods__["m_has_value"] = _base.ParserValue_m_has_value_get
    if _newclass:
        m_has_value = _swig_property(_base.ParserValue_m_has_value_get, _base.ParserValue_m_has_value_set)
    __swig_setmethods__["m_has_data"] = _base.ParserValue_m_has_data_set
    __swig_getmethods__["m_has_data"] = _base.ParserValue_m_has_data_get
    if _newclass:
        m_has_data = _swig_property(_base.ParserValue_m_has_data_get, _base.ParserValue_m_has_data_set)

    def make_value(self):
        return _base.ParserValue_make_value(self)

    def get_binary(self, buffer, count, with_type):
        return _base.ParserValue_get_binary(self, buffer, count, with_type)
    if _newclass:
        bool_to_bin = staticmethod(_base.ParserValue_bool_to_bin)
    else:
        bool_to_bin = _base.ParserValue_bool_to_bin
    if _newclass:
        char_to_bin = staticmethod(_base.ParserValue_char_to_bin)
    else:
        char_to_bin = _base.ParserValue_char_to_bin
    if _newclass:
        int_to_bin = staticmethod(_base.ParserValue_int_to_bin)
    else:
        int_to_bin = _base.ParserValue_int_to_bin
    if _newclass:
        double_to_bin = staticmethod(_base.ParserValue_double_to_bin)
    else:
        double_to_bin = _base.ParserValue_double_to_bin
    if _newclass:
        string_to_bin = staticmethod(_base.ParserValue_string_to_bin)
    else:
        string_to_bin = _base.ParserValue_string_to_bin
    if _newclass:
        binary_data_to_bin = staticmethod(_base.ParserValue_binary_data_to_bin)
    else:
        binary_data_to_bin = _base.ParserValue_binary_data_to_bin
    if _newclass:
        group_to_bin = staticmethod(_base.ParserValue_group_to_bin)
    else:
        group_to_bin = _base.ParserValue_group_to_bin
    if _newclass:
        size_to_bin = staticmethod(_base.ParserValue_size_to_bin)
    else:
        size_to_bin = _base.ParserValue_size_to_bin
    if _newclass:
        bin_to_bool = staticmethod(_base.ParserValue_bin_to_bool)
    else:
        bin_to_bool = _base.ParserValue_bin_to_bool
    if _newclass:
        bin_to_char = staticmethod(_base.ParserValue_bin_to_char)
    else:
        bin_to_char = _base.ParserValue_bin_to_char
    if _newclass:
        bin_to_int = staticmethod(_base.ParserValue_bin_to_int)
    else:
        bin_to_int = _base.ParserValue_bin_to_int
    if _newclass:
        bin_to_double = staticmethod(_base.ParserValue_bin_to_double)
    else:
        bin_to_double = _base.ParserValue_bin_to_double
    if _newclass:
        bin_to_string = staticmethod(_base.ParserValue_bin_to_string)
    else:
        bin_to_string = _base.ParserValue_bin_to_string
    if _newclass:
        bin_to_binary_data = staticmethod(_base.ParserValue_bin_to_binary_data)
    else:
        bin_to_binary_data = _base.ParserValue_bin_to_binary_data
    if _newclass:
        bin_to_size = staticmethod(_base.ParserValue_bin_to_size)
    else:
        bin_to_size = _base.ParserValue_bin_to_size
    if _newclass:
        bin_to_value = staticmethod(_base.ParserValue_bin_to_value)
    else:
        bin_to_value = _base.ParserValue_bin_to_value
    if _newclass:
        word_to_binary_data = staticmethod(_base.ParserValue_word_to_binary_data)
    else:
        word_to_binary_data = _base.ParserValue_word_to_binary_data

    def clear(self):
        return _base.ParserValue_clear(self)
ParserValue_swigregister = _base.ParserValue_swigregister
ParserValue_swigregister(ParserValue)

def ParserValue_get_type_name(type):
    return _base.ParserValue_get_type_name(type)
ParserValue_get_type_name = _base.ParserValue_get_type_name

def ParserValue_bool_to_bin(buffer, value):
    return _base.ParserValue_bool_to_bin(buffer, value)
ParserValue_bool_to_bin = _base.ParserValue_bool_to_bin

def ParserValue_char_to_bin(buffer, value):
    return _base.ParserValue_char_to_bin(buffer, value)
ParserValue_char_to_bin = _base.ParserValue_char_to_bin

def ParserValue_int_to_bin(buffer, value):
    return _base.ParserValue_int_to_bin(buffer, value)
ParserValue_int_to_bin = _base.ParserValue_int_to_bin

def ParserValue_double_to_bin(buffer, value):
    return _base.ParserValue_double_to_bin(buffer, value)
ParserValue_double_to_bin = _base.ParserValue_double_to_bin

def ParserValue_string_to_bin(buffer, value):
    return _base.ParserValue_string_to_bin(buffer, value)
ParserValue_string_to_bin = _base.ParserValue_string_to_bin

def ParserValue_binary_data_to_bin(buffer, data, size):
    return _base.ParserValue_binary_data_to_bin(buffer, data, size)
ParserValue_binary_data_to_bin = _base.ParserValue_binary_data_to_bin

def ParserValue_group_to_bin(buffer, group):
    return _base.ParserValue_group_to_bin(buffer, group)
ParserValue_group_to_bin = _base.ParserValue_group_to_bin

def ParserValue_size_to_bin(buffer, value):
    return _base.ParserValue_size_to_bin(buffer, value)
ParserValue_size_to_bin = _base.ParserValue_size_to_bin

def ParserValue_bin_to_bool(buffer, position):
    return _base.ParserValue_bin_to_bool(buffer, position)
ParserValue_bin_to_bool = _base.ParserValue_bin_to_bool

def ParserValue_bin_to_char(buffer, position):
    return _base.ParserValue_bin_to_char(buffer, position)
ParserValue_bin_to_char = _base.ParserValue_bin_to_char

def ParserValue_bin_to_int(buffer, position):
    return _base.ParserValue_bin_to_int(buffer, position)
ParserValue_bin_to_int = _base.ParserValue_bin_to_int

def ParserValue_bin_to_double(buffer, position):
    return _base.ParserValue_bin_to_double(buffer, position)
ParserValue_bin_to_double = _base.ParserValue_bin_to_double

def ParserValue_bin_to_string(buffer, position):
    return _base.ParserValue_bin_to_string(buffer, position)
ParserValue_bin_to_string = _base.ParserValue_bin_to_string

def ParserValue_bin_to_binary_data(buffer, position, size):
    return _base.ParserValue_bin_to_binary_data(buffer, position, size)
ParserValue_bin_to_binary_data = _base.ParserValue_bin_to_binary_data

def ParserValue_bin_to_size(buffer, position):
    return _base.ParserValue_bin_to_size(buffer, position)
ParserValue_bin_to_size = _base.ParserValue_bin_to_size

def ParserValue_bin_to_value(buffer, position):
    return _base.ParserValue_bin_to_value(buffer, position)
ParserValue_bin_to_value = _base.ParserValue_bin_to_value

def ParserValue_word_to_binary_data(data, size, word):
    return _base.ParserValue_word_to_binary_data(data, size, word)
ParserValue_word_to_binary_data = _base.ParserValue_word_to_binary_data

PARSER_SERIAL_VERSION_TOKEN = _base.PARSER_SERIAL_VERSION_TOKEN
PARSER_SERIAL_VERSION = _base.PARSER_SERIAL_VERSION
class ParserWord(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ParserWord, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ParserWord, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _base.new_ParserWord(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _base.delete_ParserWord
    __del__ = lambda self: None
    TYPE_IDENTIFIER = _base.ParserWord_TYPE_IDENTIFIER
    TYPE_OPERATOR = _base.ParserWord_TYPE_OPERATOR
    TYPE_SEPARATOR = _base.ParserWord_TYPE_SEPARATOR
    TYPE_KEYWORD = _base.ParserWord_TYPE_KEYWORD
    TYPE_BOOL = _base.ParserWord_TYPE_BOOL
    TYPE_BINARY_DATA = _base.ParserWord_TYPE_BINARY_DATA
    TYPE_BRACE = _base.ParserWord_TYPE_BRACE
    TYPE_INT = _base.ParserWord_TYPE_INT
    TYPE_DOUBLE = _base.ParserWord_TYPE_DOUBLE
    TYPE_STRING = _base.ParserWord_TYPE_STRING
    TYPE_EMPTY_TAG = _base.ParserWord_TYPE_EMPTY_TAG
    TYPE_SYNTAX_ERROR = _base.ParserWord_TYPE_SYNTAX_ERROR
    TYPE_COUNT = _base.ParserWord_TYPE_COUNT
    if _newclass:
        is_value_type = staticmethod(_base.ParserWord_is_value_type)
    else:
        is_value_type = _base.ParserWord_is_value_type

    def get_string(self):
        return _base.ParserWord_get_string(self)

    def get_string_0100(self, result):
        return _base.ParserWord_get_string_0100(self, result)

    def get_string_0110(self, result):
        return _base.ParserWord_get_string_0110(self, result)

    def __iadd__(self, i):
        return _base.ParserWord___iadd__(self, i)

    def __eq__(self, string):

        if not isinstance(obj, type(self)):
            return False


        return _base.ParserWord___eq__(self, string)


    def get_length(self):
        return _base.ParserWord_get_length(self)

    def clear(self):
        return _base.ParserWord_clear(self)

    def is_empty(self):
        return _base.ParserWord_is_empty(self)

    def set_brace(self, flag):
        return _base.ParserWord_set_brace(self, flag)

    def get_line(self):
        return _base.ParserWord_get_line(self)

    def get_column(self):
        return _base.ParserWord_get_column(self)

    def set_line(self, line):
        return _base.ParserWord_set_line(self, line)

    def set_column(self, column):
        return _base.ParserWord_set_column(self, column)

    def is_array(self):
        return _base.ParserWord_is_array(self)

    def get_array_count(self):
        return _base.ParserWord_get_array_count(self)

    def has_template(self):
        return _base.ParserWord_has_template(self)

    def get_template(self):
        return _base.ParserWord_get_template(self)

    def is_identifier(self):
        return _base.ParserWord_is_identifier(self)

    def is_operator(self):
        return _base.ParserWord_is_operator(self)

    def is_separator(self):
        return _base.ParserWord_is_separator(self)

    def is_keyword(self):
        return _base.ParserWord_is_keyword(self)

    def is_bool(self):
        return _base.ParserWord_is_bool(self)

    def is_binary_data(self):
        return _base.ParserWord_is_binary_data(self)

    def is_brace(self):
        return _base.ParserWord_is_brace(self)

    def is_int(self):
        return _base.ParserWord_is_int(self)

    def is_double(self):
        return _base.ParserWord_is_double(self)

    def is_string(self):
        return _base.ParserWord_is_string(self)

    def is_empty_tag(self):
        return _base.ParserWord_is_empty_tag(self)

    def is_value(self, type):
        return _base.ParserWord_is_value(self, type)

    def get_type(self):
        return _base.ParserWord_get_type(self)
ParserWord_swigregister = _base.ParserWord_swigregister
ParserWord_swigregister(ParserWord)

def ParserWord_is_value_type(type):
    return _base.ParserWord_is_value_type(type)
ParserWord_is_value_type = _base.ParserWord_is_value_type

# This file is compatible with both classic and new-style classes.


